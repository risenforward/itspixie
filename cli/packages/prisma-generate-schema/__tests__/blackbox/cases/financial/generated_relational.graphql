enum ACH_TYPE {
  SAVINGS
  CHECKING
}

type AggregateCampus {
  count: Int!
}

type AggregateFinancialAccount {
  count: Int!
}

type AggregateFinancialPaymentDetail {
  count: Int!
}

type AggregateFinancialScheduledTransaction {
  count: Int!
}

type AggregateFinancialTransaction {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type AggregateGroupInvite {
  count: Int!
}

type AggregateGroupMember {
  count: Int!
}

type AggregateGroupRole {
  count: Int!
}

type AggregateGroupType {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregatePerson {
  count: Int!
}

type AggregatePhoneNumber {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Campus {
  id: ID!
  accounts(where: FinancialAccountWhereInput, orderBy: FinancialAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialAccount!]
  description: String
  isActive: Boolean
  organization: Group
  location: Location
  name: String!
  phoneNumbers(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber!]
}

type CampusConnection {
  pageInfo: PageInfo!
  edges: [CampusEdge]!
  aggregate: AggregateCampus!
}

input CampusCreateInput {
  accounts: FinancialAccountCreateManyWithoutCampusesInput
  description: String
  isActive: Boolean
  organization: GroupCreateOneInput
  location: LocationCreateOneInput
  name: String!
  phoneNumbers: PhoneNumberCreateManyInput
}

input CampusCreateManyWithoutAccountsInput {
  create: [CampusCreateWithoutAccountsInput!]
  connect: [CampusWhereUniqueInput!]
}

input CampusCreateWithoutAccountsInput {
  description: String
  isActive: Boolean
  organization: GroupCreateOneInput
  location: LocationCreateOneInput
  name: String!
  phoneNumbers: PhoneNumberCreateManyInput
}

type CampusEdge {
  node: Campus!
  cursor: String!
}

enum CampusOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  isActive_ASC
  isActive_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CampusPreviousValues {
  id: ID!
  description: String
  isActive: Boolean
  name: String!
}

input CampusScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CampusScalarWhereInput!]
  OR: [CampusScalarWhereInput!]
  NOT: [CampusScalarWhereInput!]
}

type CampusSubscriptionPayload {
  mutation: MutationType!
  node: Campus
  updatedFields: [String!]
  previousValues: CampusPreviousValues
}

input CampusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CampusWhereInput
  AND: [CampusSubscriptionWhereInput!]
  OR: [CampusSubscriptionWhereInput!]
  NOT: [CampusSubscriptionWhereInput!]
}

input CampusUpdateInput {
  accounts: FinancialAccountUpdateManyWithoutCampusesInput
  description: String
  isActive: Boolean
  organization: GroupUpdateOneInput
  location: LocationUpdateOneInput
  name: String
  phoneNumbers: PhoneNumberUpdateManyInput
}

input CampusUpdateManyDataInput {
  description: String
  isActive: Boolean
  name: String
}

input CampusUpdateManyMutationInput {
  description: String
  isActive: Boolean
  name: String
}

input CampusUpdateManyWithoutAccountsInput {
  create: [CampusCreateWithoutAccountsInput!]
  delete: [CampusWhereUniqueInput!]
  connect: [CampusWhereUniqueInput!]
  disconnect: [CampusWhereUniqueInput!]
  update: [CampusUpdateWithWhereUniqueWithoutAccountsInput!]
  upsert: [CampusUpsertWithWhereUniqueWithoutAccountsInput!]
  deleteMany: [CampusScalarWhereInput!]
  updateMany: [CampusUpdateManyWithWhereNestedInput!]
}

input CampusUpdateManyWithWhereNestedInput {
  where: CampusScalarWhereInput!
  data: CampusUpdateManyDataInput!
}

input CampusUpdateWithoutAccountsDataInput {
  description: String
  isActive: Boolean
  organization: GroupUpdateOneInput
  location: LocationUpdateOneInput
  name: String
  phoneNumbers: PhoneNumberUpdateManyInput
}

input CampusUpdateWithWhereUniqueWithoutAccountsInput {
  where: CampusWhereUniqueInput!
  data: CampusUpdateWithoutAccountsDataInput!
}

input CampusUpsertWithWhereUniqueWithoutAccountsInput {
  where: CampusWhereUniqueInput!
  update: CampusUpdateWithoutAccountsDataInput!
  create: CampusCreateWithoutAccountsInput!
}

input CampusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  accounts_every: FinancialAccountWhereInput
  accounts_some: FinancialAccountWhereInput
  accounts_none: FinancialAccountWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  organization: GroupWhereInput
  location: LocationWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phoneNumbers_every: PhoneNumberWhereInput
  phoneNumbers_some: PhoneNumberWhereInput
  phoneNumbers_none: PhoneNumberWhereInput
  AND: [CampusWhereInput!]
  OR: [CampusWhereInput!]
  NOT: [CampusWhereInput!]
}

input CampusWhereUniqueInput {
  id: ID
}

enum CREDIT_CARD {
  VISA
  MASTERCARD
  AMEX
  DISCOVER
}

enum CURRENCY_TYPE {
  ACH
  CC
}

scalar DateTime

type FinancialAccount {
  id: ID!
  key: String
  campuses(where: CampusWhereInput, orderBy: CampusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Campus!]
  description: String!
  isActive: Boolean!
  name: String
}

type FinancialAccountConnection {
  pageInfo: PageInfo!
  edges: [FinancialAccountEdge]!
  aggregate: AggregateFinancialAccount!
}

input FinancialAccountCreateInput {
  key: String
  campuses: CampusCreateManyWithoutAccountsInput
  description: String!
  isActive: Boolean!
  name: String
}

input FinancialAccountCreateManyWithoutCampusesInput {
  create: [FinancialAccountCreateWithoutCampusesInput!]
  connect: [FinancialAccountWhereUniqueInput!]
}

input FinancialAccountCreateOneInput {
  create: FinancialAccountCreateInput
  connect: FinancialAccountWhereUniqueInput
}

input FinancialAccountCreateWithoutCampusesInput {
  key: String
  description: String!
  isActive: Boolean!
  name: String
}

type FinancialAccountEdge {
  node: FinancialAccount!
  cursor: String!
}

enum FinancialAccountOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
  description_ASC
  description_DESC
  isActive_ASC
  isActive_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FinancialAccountPreviousValues {
  id: ID!
  key: String
  description: String!
  isActive: Boolean!
  name: String
}

input FinancialAccountScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [FinancialAccountScalarWhereInput!]
  OR: [FinancialAccountScalarWhereInput!]
  NOT: [FinancialAccountScalarWhereInput!]
}

type FinancialAccountSubscriptionPayload {
  mutation: MutationType!
  node: FinancialAccount
  updatedFields: [String!]
  previousValues: FinancialAccountPreviousValues
}

input FinancialAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FinancialAccountWhereInput
  AND: [FinancialAccountSubscriptionWhereInput!]
  OR: [FinancialAccountSubscriptionWhereInput!]
  NOT: [FinancialAccountSubscriptionWhereInput!]
}

input FinancialAccountUpdateDataInput {
  key: String
  campuses: CampusUpdateManyWithoutAccountsInput
  description: String
  isActive: Boolean
  name: String
}

input FinancialAccountUpdateInput {
  key: String
  campuses: CampusUpdateManyWithoutAccountsInput
  description: String
  isActive: Boolean
  name: String
}

input FinancialAccountUpdateManyDataInput {
  key: String
  description: String
  isActive: Boolean
  name: String
}

input FinancialAccountUpdateManyMutationInput {
  key: String
  description: String
  isActive: Boolean
  name: String
}

input FinancialAccountUpdateManyWithoutCampusesInput {
  create: [FinancialAccountCreateWithoutCampusesInput!]
  delete: [FinancialAccountWhereUniqueInput!]
  connect: [FinancialAccountWhereUniqueInput!]
  disconnect: [FinancialAccountWhereUniqueInput!]
  update: [FinancialAccountUpdateWithWhereUniqueWithoutCampusesInput!]
  upsert: [FinancialAccountUpsertWithWhereUniqueWithoutCampusesInput!]
  deleteMany: [FinancialAccountScalarWhereInput!]
  updateMany: [FinancialAccountUpdateManyWithWhereNestedInput!]
}

input FinancialAccountUpdateManyWithWhereNestedInput {
  where: FinancialAccountScalarWhereInput!
  data: FinancialAccountUpdateManyDataInput!
}

input FinancialAccountUpdateOneInput {
  create: FinancialAccountCreateInput
  update: FinancialAccountUpdateDataInput
  upsert: FinancialAccountUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FinancialAccountWhereUniqueInput
}

input FinancialAccountUpdateWithoutCampusesDataInput {
  key: String
  description: String
  isActive: Boolean
  name: String
}

input FinancialAccountUpdateWithWhereUniqueWithoutCampusesInput {
  where: FinancialAccountWhereUniqueInput!
  data: FinancialAccountUpdateWithoutCampusesDataInput!
}

input FinancialAccountUpsertNestedInput {
  update: FinancialAccountUpdateDataInput!
  create: FinancialAccountCreateInput!
}

input FinancialAccountUpsertWithWhereUniqueWithoutCampusesInput {
  where: FinancialAccountWhereUniqueInput!
  update: FinancialAccountUpdateWithoutCampusesDataInput!
  create: FinancialAccountCreateWithoutCampusesInput!
}

input FinancialAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  campuses_every: CampusWhereInput
  campuses_some: CampusWhereInput
  campuses_none: CampusWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [FinancialAccountWhereInput!]
  OR: [FinancialAccountWhereInput!]
  NOT: [FinancialAccountWhereInput!]
}

input FinancialAccountWhereUniqueInput {
  id: ID
  key: String
}

type FinancialPaymentDetail {
  id: ID!
  accountNumberMasked: String!
  billingLocation: Location
  creditCardType: CREDIT_CARD
  achType: ACH_TYPE
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime!
  nameOnCard: String
}

type FinancialPaymentDetailConnection {
  pageInfo: PageInfo!
  edges: [FinancialPaymentDetailEdge]!
  aggregate: AggregateFinancialPaymentDetail!
}

input FinancialPaymentDetailCreateInput {
  accountNumberMasked: String!
  billingLocation: LocationCreateOneInput
  creditCardType: CREDIT_CARD
  achType: ACH_TYPE
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime!
  nameOnCard: String
}

input FinancialPaymentDetailCreateOneInput {
  create: FinancialPaymentDetailCreateInput
  connect: FinancialPaymentDetailWhereUniqueInput
}

type FinancialPaymentDetailEdge {
  node: FinancialPaymentDetail!
  cursor: String!
}

enum FinancialPaymentDetailOrderByInput {
  id_ASC
  id_DESC
  accountNumberMasked_ASC
  accountNumberMasked_DESC
  creditCardType_ASC
  creditCardType_DESC
  achType_ASC
  achType_DESC
  currencyType_ASC
  currencyType_DESC
  expirationDate_ASC
  expirationDate_DESC
  nameOnCard_ASC
  nameOnCard_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FinancialPaymentDetailPreviousValues {
  id: ID!
  accountNumberMasked: String!
  creditCardType: CREDIT_CARD
  achType: ACH_TYPE
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime!
  nameOnCard: String
}

type FinancialPaymentDetailSubscriptionPayload {
  mutation: MutationType!
  node: FinancialPaymentDetail
  updatedFields: [String!]
  previousValues: FinancialPaymentDetailPreviousValues
}

input FinancialPaymentDetailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FinancialPaymentDetailWhereInput
  AND: [FinancialPaymentDetailSubscriptionWhereInput!]
  OR: [FinancialPaymentDetailSubscriptionWhereInput!]
  NOT: [FinancialPaymentDetailSubscriptionWhereInput!]
}

input FinancialPaymentDetailUpdateDataInput {
  accountNumberMasked: String
  billingLocation: LocationUpdateOneInput
  creditCardType: CREDIT_CARD
  achType: ACH_TYPE
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime
  nameOnCard: String
}

input FinancialPaymentDetailUpdateInput {
  accountNumberMasked: String
  billingLocation: LocationUpdateOneInput
  creditCardType: CREDIT_CARD
  achType: ACH_TYPE
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime
  nameOnCard: String
}

input FinancialPaymentDetailUpdateManyMutationInput {
  accountNumberMasked: String
  creditCardType: CREDIT_CARD
  achType: ACH_TYPE
  currencyType: CURRENCY_TYPE
  expirationDate: DateTime
  nameOnCard: String
}

input FinancialPaymentDetailUpdateOneInput {
  create: FinancialPaymentDetailCreateInput
  update: FinancialPaymentDetailUpdateDataInput
  upsert: FinancialPaymentDetailUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FinancialPaymentDetailWhereUniqueInput
}

input FinancialPaymentDetailUpsertNestedInput {
  update: FinancialPaymentDetailUpdateDataInput!
  create: FinancialPaymentDetailCreateInput!
}

input FinancialPaymentDetailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  accountNumberMasked: String
  accountNumberMasked_not: String
  accountNumberMasked_in: [String!]
  accountNumberMasked_not_in: [String!]
  accountNumberMasked_lt: String
  accountNumberMasked_lte: String
  accountNumberMasked_gt: String
  accountNumberMasked_gte: String
  accountNumberMasked_contains: String
  accountNumberMasked_not_contains: String
  accountNumberMasked_starts_with: String
  accountNumberMasked_not_starts_with: String
  accountNumberMasked_ends_with: String
  accountNumberMasked_not_ends_with: String
  billingLocation: LocationWhereInput
  creditCardType: CREDIT_CARD
  creditCardType_not: CREDIT_CARD
  creditCardType_in: [CREDIT_CARD!]
  creditCardType_not_in: [CREDIT_CARD!]
  achType: ACH_TYPE
  achType_not: ACH_TYPE
  achType_in: [ACH_TYPE!]
  achType_not_in: [ACH_TYPE!]
  currencyType: CURRENCY_TYPE
  currencyType_not: CURRENCY_TYPE
  currencyType_in: [CURRENCY_TYPE!]
  currencyType_not_in: [CURRENCY_TYPE!]
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  nameOnCard: String
  nameOnCard_not: String
  nameOnCard_in: [String!]
  nameOnCard_not_in: [String!]
  nameOnCard_lt: String
  nameOnCard_lte: String
  nameOnCard_gt: String
  nameOnCard_gte: String
  nameOnCard_contains: String
  nameOnCard_not_contains: String
  nameOnCard_starts_with: String
  nameOnCard_not_starts_with: String
  nameOnCard_ends_with: String
  nameOnCard_not_ends_with: String
  AND: [FinancialPaymentDetailWhereInput!]
  OR: [FinancialPaymentDetailWhereInput!]
  NOT: [FinancialPaymentDetailWhereInput!]
}

input FinancialPaymentDetailWhereUniqueInput {
  id: ID
}

type FinancialScheduledTransaction {
  id: ID!
  person: Person
  endDate: DateTime
  payment: FinancialPaymentDetail
  isActive: Boolean!
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  transactions(where: FinancialTransactionWhereInput, orderBy: FinancialTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialTransaction!]
  account: FinancialAccount
  amount: Float!
}

type FinancialScheduledTransactionConnection {
  pageInfo: PageInfo!
  edges: [FinancialScheduledTransactionEdge]!
  aggregate: AggregateFinancialScheduledTransaction!
}

input FinancialScheduledTransactionCreateInput {
  person: PersonCreateOneWithoutScheduledTransactionsInput
  endDate: DateTime
  payment: FinancialPaymentDetailCreateOneInput
  isActive: Boolean!
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  transactions: FinancialTransactionCreateManyWithoutScheduledTransactionInput
  account: FinancialAccountCreateOneInput
  amount: Float!
}

input FinancialScheduledTransactionCreateManyWithoutPersonInput {
  create: [FinancialScheduledTransactionCreateWithoutPersonInput!]
  connect: [FinancialScheduledTransactionWhereUniqueInput!]
}

input FinancialScheduledTransactionCreateOneWithoutTransactionsInput {
  create: FinancialScheduledTransactionCreateWithoutTransactionsInput
  connect: FinancialScheduledTransactionWhereUniqueInput
}

input FinancialScheduledTransactionCreateWithoutPersonInput {
  endDate: DateTime
  payment: FinancialPaymentDetailCreateOneInput
  isActive: Boolean!
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  transactions: FinancialTransactionCreateManyWithoutScheduledTransactionInput
  account: FinancialAccountCreateOneInput
  amount: Float!
}

input FinancialScheduledTransactionCreateWithoutTransactionsInput {
  person: PersonCreateOneWithoutScheduledTransactionsInput
  endDate: DateTime
  payment: FinancialPaymentDetailCreateOneInput
  isActive: Boolean!
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  account: FinancialAccountCreateOneInput
  amount: Float!
}

type FinancialScheduledTransactionEdge {
  node: FinancialScheduledTransaction!
  cursor: String!
}

enum FinancialScheduledTransactionOrderByInput {
  id_ASC
  id_DESC
  endDate_ASC
  endDate_DESC
  isActive_ASC
  isActive_DESC
  startDate_ASC
  startDate_DESC
  frequency_ASC
  frequency_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FinancialScheduledTransactionPreviousValues {
  id: ID!
  endDate: DateTime
  isActive: Boolean!
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  amount: Float!
}

input FinancialScheduledTransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  isActive: Boolean
  isActive_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  frequency: TRANSACTION_FREQUENCY
  frequency_not: TRANSACTION_FREQUENCY
  frequency_in: [TRANSACTION_FREQUENCY!]
  frequency_not_in: [TRANSACTION_FREQUENCY!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [FinancialScheduledTransactionScalarWhereInput!]
  OR: [FinancialScheduledTransactionScalarWhereInput!]
  NOT: [FinancialScheduledTransactionScalarWhereInput!]
}

type FinancialScheduledTransactionSubscriptionPayload {
  mutation: MutationType!
  node: FinancialScheduledTransaction
  updatedFields: [String!]
  previousValues: FinancialScheduledTransactionPreviousValues
}

input FinancialScheduledTransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FinancialScheduledTransactionWhereInput
  AND: [FinancialScheduledTransactionSubscriptionWhereInput!]
  OR: [FinancialScheduledTransactionSubscriptionWhereInput!]
  NOT: [FinancialScheduledTransactionSubscriptionWhereInput!]
}

input FinancialScheduledTransactionUpdateInput {
  person: PersonUpdateOneWithoutScheduledTransactionsInput
  endDate: DateTime
  payment: FinancialPaymentDetailUpdateOneInput
  isActive: Boolean
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  transactions: FinancialTransactionUpdateManyWithoutScheduledTransactionInput
  account: FinancialAccountUpdateOneInput
  amount: Float
}

input FinancialScheduledTransactionUpdateManyDataInput {
  endDate: DateTime
  isActive: Boolean
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  amount: Float
}

input FinancialScheduledTransactionUpdateManyMutationInput {
  endDate: DateTime
  isActive: Boolean
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  amount: Float
}

input FinancialScheduledTransactionUpdateManyWithoutPersonInput {
  create: [FinancialScheduledTransactionCreateWithoutPersonInput!]
  delete: [FinancialScheduledTransactionWhereUniqueInput!]
  connect: [FinancialScheduledTransactionWhereUniqueInput!]
  disconnect: [FinancialScheduledTransactionWhereUniqueInput!]
  update: [FinancialScheduledTransactionUpdateWithWhereUniqueWithoutPersonInput!]
  upsert: [FinancialScheduledTransactionUpsertWithWhereUniqueWithoutPersonInput!]
  deleteMany: [FinancialScheduledTransactionScalarWhereInput!]
  updateMany: [FinancialScheduledTransactionUpdateManyWithWhereNestedInput!]
}

input FinancialScheduledTransactionUpdateManyWithWhereNestedInput {
  where: FinancialScheduledTransactionScalarWhereInput!
  data: FinancialScheduledTransactionUpdateManyDataInput!
}

input FinancialScheduledTransactionUpdateOneWithoutTransactionsInput {
  create: FinancialScheduledTransactionCreateWithoutTransactionsInput
  update: FinancialScheduledTransactionUpdateWithoutTransactionsDataInput
  upsert: FinancialScheduledTransactionUpsertWithoutTransactionsInput
  delete: Boolean
  disconnect: Boolean
  connect: FinancialScheduledTransactionWhereUniqueInput
}

input FinancialScheduledTransactionUpdateWithoutPersonDataInput {
  endDate: DateTime
  payment: FinancialPaymentDetailUpdateOneInput
  isActive: Boolean
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  transactions: FinancialTransactionUpdateManyWithoutScheduledTransactionInput
  account: FinancialAccountUpdateOneInput
  amount: Float
}

input FinancialScheduledTransactionUpdateWithoutTransactionsDataInput {
  person: PersonUpdateOneWithoutScheduledTransactionsInput
  endDate: DateTime
  payment: FinancialPaymentDetailUpdateOneInput
  isActive: Boolean
  startDate: DateTime
  frequency: TRANSACTION_FREQUENCY
  account: FinancialAccountUpdateOneInput
  amount: Float
}

input FinancialScheduledTransactionUpdateWithWhereUniqueWithoutPersonInput {
  where: FinancialScheduledTransactionWhereUniqueInput!
  data: FinancialScheduledTransactionUpdateWithoutPersonDataInput!
}

input FinancialScheduledTransactionUpsertWithoutTransactionsInput {
  update: FinancialScheduledTransactionUpdateWithoutTransactionsDataInput!
  create: FinancialScheduledTransactionCreateWithoutTransactionsInput!
}

input FinancialScheduledTransactionUpsertWithWhereUniqueWithoutPersonInput {
  where: FinancialScheduledTransactionWhereUniqueInput!
  update: FinancialScheduledTransactionUpdateWithoutPersonDataInput!
  create: FinancialScheduledTransactionCreateWithoutPersonInput!
}

input FinancialScheduledTransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  person: PersonWhereInput
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  payment: FinancialPaymentDetailWhereInput
  isActive: Boolean
  isActive_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  frequency: TRANSACTION_FREQUENCY
  frequency_not: TRANSACTION_FREQUENCY
  frequency_in: [TRANSACTION_FREQUENCY!]
  frequency_not_in: [TRANSACTION_FREQUENCY!]
  transactions_every: FinancialTransactionWhereInput
  transactions_some: FinancialTransactionWhereInput
  transactions_none: FinancialTransactionWhereInput
  account: FinancialAccountWhereInput
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [FinancialScheduledTransactionWhereInput!]
  OR: [FinancialScheduledTransactionWhereInput!]
  NOT: [FinancialScheduledTransactionWhereInput!]
}

input FinancialScheduledTransactionWhereUniqueInput {
  id: ID
}

type FinancialTransaction {
  id: ID!
  payment: FinancialPaymentDetail
  person: Person
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransaction
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  amount: Float!
  account: FinancialAccount
  organization: Group!
}

type FinancialTransactionConnection {
  pageInfo: PageInfo!
  edges: [FinancialTransactionEdge]!
  aggregate: AggregateFinancialTransaction!
}

input FinancialTransactionCreateInput {
  payment: FinancialPaymentDetailCreateOneInput
  person: PersonCreateOneWithoutTransactionsInput
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransactionCreateOneWithoutTransactionsInput
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  amount: Float!
  account: FinancialAccountCreateOneInput
  organization: GroupCreateOneInput!
}

input FinancialTransactionCreateManyWithoutPersonInput {
  create: [FinancialTransactionCreateWithoutPersonInput!]
  connect: [FinancialTransactionWhereUniqueInput!]
}

input FinancialTransactionCreateManyWithoutScheduledTransactionInput {
  create: [FinancialTransactionCreateWithoutScheduledTransactionInput!]
  connect: [FinancialTransactionWhereUniqueInput!]
}

input FinancialTransactionCreateWithoutPersonInput {
  payment: FinancialPaymentDetailCreateOneInput
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransactionCreateOneWithoutTransactionsInput
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  amount: Float!
  account: FinancialAccountCreateOneInput
  organization: GroupCreateOneInput!
}

input FinancialTransactionCreateWithoutScheduledTransactionInput {
  payment: FinancialPaymentDetailCreateOneInput
  person: PersonCreateOneWithoutTransactionsInput
  processedDate: DateTime
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  amount: Float!
  account: FinancialAccountCreateOneInput
  organization: GroupCreateOneInput!
}

type FinancialTransactionEdge {
  node: FinancialTransaction!
  cursor: String!
}

enum FinancialTransactionOrderByInput {
  id_ASC
  id_DESC
  processedDate_ASC
  processedDate_DESC
  status_ASC
  status_DESC
  transactionDate_ASC
  transactionDate_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FinancialTransactionPreviousValues {
  id: ID!
  processedDate: DateTime
  status: TRANSACTION_STATUS!
  transactionDate: DateTime
  amount: Float!
}

input FinancialTransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  processedDate: DateTime
  processedDate_not: DateTime
  processedDate_in: [DateTime!]
  processedDate_not_in: [DateTime!]
  processedDate_lt: DateTime
  processedDate_lte: DateTime
  processedDate_gt: DateTime
  processedDate_gte: DateTime
  status: TRANSACTION_STATUS
  status_not: TRANSACTION_STATUS
  status_in: [TRANSACTION_STATUS!]
  status_not_in: [TRANSACTION_STATUS!]
  transactionDate: DateTime
  transactionDate_not: DateTime
  transactionDate_in: [DateTime!]
  transactionDate_not_in: [DateTime!]
  transactionDate_lt: DateTime
  transactionDate_lte: DateTime
  transactionDate_gt: DateTime
  transactionDate_gte: DateTime
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [FinancialTransactionScalarWhereInput!]
  OR: [FinancialTransactionScalarWhereInput!]
  NOT: [FinancialTransactionScalarWhereInput!]
}

type FinancialTransactionSubscriptionPayload {
  mutation: MutationType!
  node: FinancialTransaction
  updatedFields: [String!]
  previousValues: FinancialTransactionPreviousValues
}

input FinancialTransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FinancialTransactionWhereInput
  AND: [FinancialTransactionSubscriptionWhereInput!]
  OR: [FinancialTransactionSubscriptionWhereInput!]
  NOT: [FinancialTransactionSubscriptionWhereInput!]
}

input FinancialTransactionUpdateInput {
  payment: FinancialPaymentDetailUpdateOneInput
  person: PersonUpdateOneWithoutTransactionsInput
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransactionUpdateOneWithoutTransactionsInput
  status: TRANSACTION_STATUS
  transactionDate: DateTime
  amount: Float
  account: FinancialAccountUpdateOneInput
  organization: GroupUpdateOneRequiredInput
}

input FinancialTransactionUpdateManyDataInput {
  processedDate: DateTime
  status: TRANSACTION_STATUS
  transactionDate: DateTime
  amount: Float
}

input FinancialTransactionUpdateManyMutationInput {
  processedDate: DateTime
  status: TRANSACTION_STATUS
  transactionDate: DateTime
  amount: Float
}

input FinancialTransactionUpdateManyWithoutPersonInput {
  create: [FinancialTransactionCreateWithoutPersonInput!]
  delete: [FinancialTransactionWhereUniqueInput!]
  connect: [FinancialTransactionWhereUniqueInput!]
  disconnect: [FinancialTransactionWhereUniqueInput!]
  update: [FinancialTransactionUpdateWithWhereUniqueWithoutPersonInput!]
  upsert: [FinancialTransactionUpsertWithWhereUniqueWithoutPersonInput!]
  deleteMany: [FinancialTransactionScalarWhereInput!]
  updateMany: [FinancialTransactionUpdateManyWithWhereNestedInput!]
}

input FinancialTransactionUpdateManyWithoutScheduledTransactionInput {
  create: [FinancialTransactionCreateWithoutScheduledTransactionInput!]
  delete: [FinancialTransactionWhereUniqueInput!]
  connect: [FinancialTransactionWhereUniqueInput!]
  disconnect: [FinancialTransactionWhereUniqueInput!]
  update: [FinancialTransactionUpdateWithWhereUniqueWithoutScheduledTransactionInput!]
  upsert: [FinancialTransactionUpsertWithWhereUniqueWithoutScheduledTransactionInput!]
  deleteMany: [FinancialTransactionScalarWhereInput!]
  updateMany: [FinancialTransactionUpdateManyWithWhereNestedInput!]
}

input FinancialTransactionUpdateManyWithWhereNestedInput {
  where: FinancialTransactionScalarWhereInput!
  data: FinancialTransactionUpdateManyDataInput!
}

input FinancialTransactionUpdateWithoutPersonDataInput {
  payment: FinancialPaymentDetailUpdateOneInput
  processedDate: DateTime
  scheduledTransaction: FinancialScheduledTransactionUpdateOneWithoutTransactionsInput
  status: TRANSACTION_STATUS
  transactionDate: DateTime
  amount: Float
  account: FinancialAccountUpdateOneInput
  organization: GroupUpdateOneRequiredInput
}

input FinancialTransactionUpdateWithoutScheduledTransactionDataInput {
  payment: FinancialPaymentDetailUpdateOneInput
  person: PersonUpdateOneWithoutTransactionsInput
  processedDate: DateTime
  status: TRANSACTION_STATUS
  transactionDate: DateTime
  amount: Float
  account: FinancialAccountUpdateOneInput
  organization: GroupUpdateOneRequiredInput
}

input FinancialTransactionUpdateWithWhereUniqueWithoutPersonInput {
  where: FinancialTransactionWhereUniqueInput!
  data: FinancialTransactionUpdateWithoutPersonDataInput!
}

input FinancialTransactionUpdateWithWhereUniqueWithoutScheduledTransactionInput {
  where: FinancialTransactionWhereUniqueInput!
  data: FinancialTransactionUpdateWithoutScheduledTransactionDataInput!
}

input FinancialTransactionUpsertWithWhereUniqueWithoutPersonInput {
  where: FinancialTransactionWhereUniqueInput!
  update: FinancialTransactionUpdateWithoutPersonDataInput!
  create: FinancialTransactionCreateWithoutPersonInput!
}

input FinancialTransactionUpsertWithWhereUniqueWithoutScheduledTransactionInput {
  where: FinancialTransactionWhereUniqueInput!
  update: FinancialTransactionUpdateWithoutScheduledTransactionDataInput!
  create: FinancialTransactionCreateWithoutScheduledTransactionInput!
}

input FinancialTransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  payment: FinancialPaymentDetailWhereInput
  person: PersonWhereInput
  processedDate: DateTime
  processedDate_not: DateTime
  processedDate_in: [DateTime!]
  processedDate_not_in: [DateTime!]
  processedDate_lt: DateTime
  processedDate_lte: DateTime
  processedDate_gt: DateTime
  processedDate_gte: DateTime
  scheduledTransaction: FinancialScheduledTransactionWhereInput
  status: TRANSACTION_STATUS
  status_not: TRANSACTION_STATUS
  status_in: [TRANSACTION_STATUS!]
  status_not_in: [TRANSACTION_STATUS!]
  transactionDate: DateTime
  transactionDate_not: DateTime
  transactionDate_in: [DateTime!]
  transactionDate_not_in: [DateTime!]
  transactionDate_lt: DateTime
  transactionDate_lte: DateTime
  transactionDate_gt: DateTime
  transactionDate_gte: DateTime
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  account: FinancialAccountWhereInput
  organization: GroupWhereInput
  AND: [FinancialTransactionWhereInput!]
  OR: [FinancialTransactionWhereInput!]
  NOT: [FinancialTransactionWhereInput!]
}

input FinancialTransactionWhereUniqueInput {
  id: ID
}

type Group {
  id: ID!
  key: String
  description: String
  type: GroupType!
  invites(where: GroupInviteWhereInput, orderBy: GroupInviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupInvite!]
  isActive: Boolean!
  members(where: GroupMemberWhereInput, orderBy: GroupMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupMember!]
  name: String!
  organization: Group
}

enum GROUP_INVITE_STATUS {
  PENDING
  JOINED
}

enum GROUP_ROLE_TYPE {
  ADMIN
  OWNER
  MEMBER
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  key: String
  description: String
  type: GroupTypeCreateOneWithoutGroupsInput!
  invites: GroupInviteCreateManyWithoutGroupInput
  isActive: Boolean!
  members: GroupMemberCreateManyWithoutGroupInput
  name: String!
  organization: GroupCreateOneInput
}

input GroupCreateManyWithoutTypeInput {
  create: [GroupCreateWithoutTypeInput!]
  connect: [GroupWhereUniqueInput!]
}

input GroupCreateOneInput {
  create: GroupCreateInput
  connect: GroupWhereUniqueInput
}

input GroupCreateOneWithoutInvitesInput {
  create: GroupCreateWithoutInvitesInput
  connect: GroupWhereUniqueInput
}

input GroupCreateOneWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  connect: GroupWhereUniqueInput
}

input GroupCreateWithoutInvitesInput {
  key: String
  description: String
  type: GroupTypeCreateOneWithoutGroupsInput!
  isActive: Boolean!
  members: GroupMemberCreateManyWithoutGroupInput
  name: String!
  organization: GroupCreateOneInput
}

input GroupCreateWithoutMembersInput {
  key: String
  description: String
  type: GroupTypeCreateOneWithoutGroupsInput!
  invites: GroupInviteCreateManyWithoutGroupInput
  isActive: Boolean!
  name: String!
  organization: GroupCreateOneInput
}

input GroupCreateWithoutTypeInput {
  key: String
  description: String
  invites: GroupInviteCreateManyWithoutGroupInput
  isActive: Boolean!
  members: GroupMemberCreateManyWithoutGroupInput
  name: String!
  organization: GroupCreateOneInput
}

type GroupEdge {
  node: Group!
  cursor: String!
}

type GroupInvite {
  id: ID!
  email: String!
  group: Group!
  groupRole: GroupRole
  status: GROUP_INVITE_STATUS!
}

type GroupInviteConnection {
  pageInfo: PageInfo!
  edges: [GroupInviteEdge]!
  aggregate: AggregateGroupInvite!
}

input GroupInviteCreateInput {
  email: String!
  group: GroupCreateOneWithoutInvitesInput!
  groupRole: GroupRoleCreateOneInput
  status: GROUP_INVITE_STATUS!
}

input GroupInviteCreateManyWithoutGroupInput {
  create: [GroupInviteCreateWithoutGroupInput!]
  connect: [GroupInviteWhereUniqueInput!]
}

input GroupInviteCreateWithoutGroupInput {
  email: String!
  groupRole: GroupRoleCreateOneInput
  status: GROUP_INVITE_STATUS!
}

type GroupInviteEdge {
  node: GroupInvite!
  cursor: String!
}

enum GroupInviteOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GroupInvitePreviousValues {
  id: ID!
  email: String!
  status: GROUP_INVITE_STATUS!
}

input GroupInviteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  status: GROUP_INVITE_STATUS
  status_not: GROUP_INVITE_STATUS
  status_in: [GROUP_INVITE_STATUS!]
  status_not_in: [GROUP_INVITE_STATUS!]
  AND: [GroupInviteScalarWhereInput!]
  OR: [GroupInviteScalarWhereInput!]
  NOT: [GroupInviteScalarWhereInput!]
}

type GroupInviteSubscriptionPayload {
  mutation: MutationType!
  node: GroupInvite
  updatedFields: [String!]
  previousValues: GroupInvitePreviousValues
}

input GroupInviteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupInviteWhereInput
  AND: [GroupInviteSubscriptionWhereInput!]
  OR: [GroupInviteSubscriptionWhereInput!]
  NOT: [GroupInviteSubscriptionWhereInput!]
}

input GroupInviteUpdateInput {
  email: String
  group: GroupUpdateOneRequiredWithoutInvitesInput
  groupRole: GroupRoleUpdateOneInput
  status: GROUP_INVITE_STATUS
}

input GroupInviteUpdateManyDataInput {
  email: String
  status: GROUP_INVITE_STATUS
}

input GroupInviteUpdateManyMutationInput {
  email: String
  status: GROUP_INVITE_STATUS
}

input GroupInviteUpdateManyWithoutGroupInput {
  create: [GroupInviteCreateWithoutGroupInput!]
  delete: [GroupInviteWhereUniqueInput!]
  connect: [GroupInviteWhereUniqueInput!]
  disconnect: [GroupInviteWhereUniqueInput!]
  update: [GroupInviteUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [GroupInviteUpsertWithWhereUniqueWithoutGroupInput!]
  deleteMany: [GroupInviteScalarWhereInput!]
  updateMany: [GroupInviteUpdateManyWithWhereNestedInput!]
}

input GroupInviteUpdateManyWithWhereNestedInput {
  where: GroupInviteScalarWhereInput!
  data: GroupInviteUpdateManyDataInput!
}

input GroupInviteUpdateWithoutGroupDataInput {
  email: String
  groupRole: GroupRoleUpdateOneInput
  status: GROUP_INVITE_STATUS
}

input GroupInviteUpdateWithWhereUniqueWithoutGroupInput {
  where: GroupInviteWhereUniqueInput!
  data: GroupInviteUpdateWithoutGroupDataInput!
}

input GroupInviteUpsertWithWhereUniqueWithoutGroupInput {
  where: GroupInviteWhereUniqueInput!
  update: GroupInviteUpdateWithoutGroupDataInput!
  create: GroupInviteCreateWithoutGroupInput!
}

input GroupInviteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  group: GroupWhereInput
  groupRole: GroupRoleWhereInput
  status: GROUP_INVITE_STATUS
  status_not: GROUP_INVITE_STATUS
  status_in: [GROUP_INVITE_STATUS!]
  status_not_in: [GROUP_INVITE_STATUS!]
  AND: [GroupInviteWhereInput!]
  OR: [GroupInviteWhereInput!]
  NOT: [GroupInviteWhereInput!]
}

input GroupInviteWhereUniqueInput {
  id: ID
}

type GroupMember {
  id: ID!
  group: Group
  role: GroupRole
  person: Person
}

type GroupMemberConnection {
  pageInfo: PageInfo!
  edges: [GroupMemberEdge]!
  aggregate: AggregateGroupMember!
}

input GroupMemberCreateInput {
  group: GroupCreateOneWithoutMembersInput
  role: GroupRoleCreateOneInput
  person: PersonCreateOneInput
}

input GroupMemberCreateManyWithoutGroupInput {
  create: [GroupMemberCreateWithoutGroupInput!]
  connect: [GroupMemberWhereUniqueInput!]
}

input GroupMemberCreateWithoutGroupInput {
  role: GroupRoleCreateOneInput
  person: PersonCreateOneInput
}

type GroupMemberEdge {
  node: GroupMember!
  cursor: String!
}

enum GroupMemberOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GroupMemberPreviousValues {
  id: ID!
}

input GroupMemberScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GroupMemberScalarWhereInput!]
  OR: [GroupMemberScalarWhereInput!]
  NOT: [GroupMemberScalarWhereInput!]
}

type GroupMemberSubscriptionPayload {
  mutation: MutationType!
  node: GroupMember
  updatedFields: [String!]
  previousValues: GroupMemberPreviousValues
}

input GroupMemberSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupMemberWhereInput
  AND: [GroupMemberSubscriptionWhereInput!]
  OR: [GroupMemberSubscriptionWhereInput!]
  NOT: [GroupMemberSubscriptionWhereInput!]
}

input GroupMemberUpdateInput {
  group: GroupUpdateOneWithoutMembersInput
  role: GroupRoleUpdateOneInput
  person: PersonUpdateOneInput
}

input GroupMemberUpdateManyWithoutGroupInput {
  create: [GroupMemberCreateWithoutGroupInput!]
  delete: [GroupMemberWhereUniqueInput!]
  connect: [GroupMemberWhereUniqueInput!]
  disconnect: [GroupMemberWhereUniqueInput!]
  update: [GroupMemberUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [GroupMemberUpsertWithWhereUniqueWithoutGroupInput!]
  deleteMany: [GroupMemberScalarWhereInput!]
}

input GroupMemberUpdateWithoutGroupDataInput {
  role: GroupRoleUpdateOneInput
  person: PersonUpdateOneInput
}

input GroupMemberUpdateWithWhereUniqueWithoutGroupInput {
  where: GroupMemberWhereUniqueInput!
  data: GroupMemberUpdateWithoutGroupDataInput!
}

input GroupMemberUpsertWithWhereUniqueWithoutGroupInput {
  where: GroupMemberWhereUniqueInput!
  update: GroupMemberUpdateWithoutGroupDataInput!
  create: GroupMemberCreateWithoutGroupInput!
}

input GroupMemberWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  group: GroupWhereInput
  role: GroupRoleWhereInput
  person: PersonWhereInput
  AND: [GroupMemberWhereInput!]
  OR: [GroupMemberWhereInput!]
  NOT: [GroupMemberWhereInput!]
}

input GroupMemberWhereUniqueInput {
  id: ID
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
  description_ASC
  description_DESC
  isActive_ASC
  isActive_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GroupPreviousValues {
  id: ID!
  key: String
  description: String
  isActive: Boolean!
  name: String!
}

type GroupRole {
  id: ID!
  canEdit: Boolean!
  canView: Boolean!
  description: String!
  groupType: GroupType
  isLeader: Boolean
  name: String!
  type: GROUP_ROLE_TYPE
}

type GroupRoleConnection {
  pageInfo: PageInfo!
  edges: [GroupRoleEdge]!
  aggregate: AggregateGroupRole!
}

input GroupRoleCreateInput {
  canEdit: Boolean!
  canView: Boolean!
  description: String!
  groupType: GroupTypeCreateOneWithoutRolesInput
  isLeader: Boolean
  name: String!
  type: GROUP_ROLE_TYPE
}

input GroupRoleCreateManyWithoutGroupTypeInput {
  create: [GroupRoleCreateWithoutGroupTypeInput!]
  connect: [GroupRoleWhereUniqueInput!]
}

input GroupRoleCreateOneInput {
  create: GroupRoleCreateInput
  connect: GroupRoleWhereUniqueInput
}

input GroupRoleCreateWithoutGroupTypeInput {
  canEdit: Boolean!
  canView: Boolean!
  description: String!
  isLeader: Boolean
  name: String!
  type: GROUP_ROLE_TYPE
}

type GroupRoleEdge {
  node: GroupRole!
  cursor: String!
}

enum GroupRoleOrderByInput {
  id_ASC
  id_DESC
  canEdit_ASC
  canEdit_DESC
  canView_ASC
  canView_DESC
  description_ASC
  description_DESC
  isLeader_ASC
  isLeader_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GroupRolePreviousValues {
  id: ID!
  canEdit: Boolean!
  canView: Boolean!
  description: String!
  isLeader: Boolean
  name: String!
  type: GROUP_ROLE_TYPE
}

input GroupRoleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  canEdit: Boolean
  canEdit_not: Boolean
  canView: Boolean
  canView_not: Boolean
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isLeader: Boolean
  isLeader_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: GROUP_ROLE_TYPE
  type_not: GROUP_ROLE_TYPE
  type_in: [GROUP_ROLE_TYPE!]
  type_not_in: [GROUP_ROLE_TYPE!]
  AND: [GroupRoleScalarWhereInput!]
  OR: [GroupRoleScalarWhereInput!]
  NOT: [GroupRoleScalarWhereInput!]
}

type GroupRoleSubscriptionPayload {
  mutation: MutationType!
  node: GroupRole
  updatedFields: [String!]
  previousValues: GroupRolePreviousValues
}

input GroupRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupRoleWhereInput
  AND: [GroupRoleSubscriptionWhereInput!]
  OR: [GroupRoleSubscriptionWhereInput!]
  NOT: [GroupRoleSubscriptionWhereInput!]
}

input GroupRoleUpdateDataInput {
  canEdit: Boolean
  canView: Boolean
  description: String
  groupType: GroupTypeUpdateOneWithoutRolesInput
  isLeader: Boolean
  name: String
  type: GROUP_ROLE_TYPE
}

input GroupRoleUpdateInput {
  canEdit: Boolean
  canView: Boolean
  description: String
  groupType: GroupTypeUpdateOneWithoutRolesInput
  isLeader: Boolean
  name: String
  type: GROUP_ROLE_TYPE
}

input GroupRoleUpdateManyDataInput {
  canEdit: Boolean
  canView: Boolean
  description: String
  isLeader: Boolean
  name: String
  type: GROUP_ROLE_TYPE
}

input GroupRoleUpdateManyMutationInput {
  canEdit: Boolean
  canView: Boolean
  description: String
  isLeader: Boolean
  name: String
  type: GROUP_ROLE_TYPE
}

input GroupRoleUpdateManyWithoutGroupTypeInput {
  create: [GroupRoleCreateWithoutGroupTypeInput!]
  delete: [GroupRoleWhereUniqueInput!]
  connect: [GroupRoleWhereUniqueInput!]
  disconnect: [GroupRoleWhereUniqueInput!]
  update: [GroupRoleUpdateWithWhereUniqueWithoutGroupTypeInput!]
  upsert: [GroupRoleUpsertWithWhereUniqueWithoutGroupTypeInput!]
  deleteMany: [GroupRoleScalarWhereInput!]
  updateMany: [GroupRoleUpdateManyWithWhereNestedInput!]
}

input GroupRoleUpdateManyWithWhereNestedInput {
  where: GroupRoleScalarWhereInput!
  data: GroupRoleUpdateManyDataInput!
}

input GroupRoleUpdateOneInput {
  create: GroupRoleCreateInput
  update: GroupRoleUpdateDataInput
  upsert: GroupRoleUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupRoleWhereUniqueInput
}

input GroupRoleUpdateWithoutGroupTypeDataInput {
  canEdit: Boolean
  canView: Boolean
  description: String
  isLeader: Boolean
  name: String
  type: GROUP_ROLE_TYPE
}

input GroupRoleUpdateWithWhereUniqueWithoutGroupTypeInput {
  where: GroupRoleWhereUniqueInput!
  data: GroupRoleUpdateWithoutGroupTypeDataInput!
}

input GroupRoleUpsertNestedInput {
  update: GroupRoleUpdateDataInput!
  create: GroupRoleCreateInput!
}

input GroupRoleUpsertWithWhereUniqueWithoutGroupTypeInput {
  where: GroupRoleWhereUniqueInput!
  update: GroupRoleUpdateWithoutGroupTypeDataInput!
  create: GroupRoleCreateWithoutGroupTypeInput!
}

input GroupRoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  canEdit: Boolean
  canEdit_not: Boolean
  canView: Boolean
  canView_not: Boolean
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  groupType: GroupTypeWhereInput
  isLeader: Boolean
  isLeader_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: GROUP_ROLE_TYPE
  type_not: GROUP_ROLE_TYPE
  type_in: [GROUP_ROLE_TYPE!]
  type_not_in: [GROUP_ROLE_TYPE!]
  AND: [GroupRoleWhereInput!]
  OR: [GroupRoleWhereInput!]
  NOT: [GroupRoleWhereInput!]
}

input GroupRoleWhereUniqueInput {
  id: ID
  name: String
}

input GroupScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GroupScalarWhereInput!]
  OR: [GroupScalarWhereInput!]
  NOT: [GroupScalarWhereInput!]
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

type GroupType {
  id: ID!
  description: String
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group!]
  name: String!
  roles(where: GroupRoleWhereInput, orderBy: GroupRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupRole!]
}

type GroupTypeConnection {
  pageInfo: PageInfo!
  edges: [GroupTypeEdge]!
  aggregate: AggregateGroupType!
}

input GroupTypeCreateInput {
  description: String
  groups: GroupCreateManyWithoutTypeInput
  name: String!
  roles: GroupRoleCreateManyWithoutGroupTypeInput
}

input GroupTypeCreateOneWithoutGroupsInput {
  create: GroupTypeCreateWithoutGroupsInput
  connect: GroupTypeWhereUniqueInput
}

input GroupTypeCreateOneWithoutRolesInput {
  create: GroupTypeCreateWithoutRolesInput
  connect: GroupTypeWhereUniqueInput
}

input GroupTypeCreateWithoutGroupsInput {
  description: String
  name: String!
  roles: GroupRoleCreateManyWithoutGroupTypeInput
}

input GroupTypeCreateWithoutRolesInput {
  description: String
  groups: GroupCreateManyWithoutTypeInput
  name: String!
}

type GroupTypeEdge {
  node: GroupType!
  cursor: String!
}

enum GroupTypeOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GroupTypePreviousValues {
  id: ID!
  description: String
  name: String!
}

type GroupTypeSubscriptionPayload {
  mutation: MutationType!
  node: GroupType
  updatedFields: [String!]
  previousValues: GroupTypePreviousValues
}

input GroupTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupTypeWhereInput
  AND: [GroupTypeSubscriptionWhereInput!]
  OR: [GroupTypeSubscriptionWhereInput!]
  NOT: [GroupTypeSubscriptionWhereInput!]
}

input GroupTypeUpdateInput {
  description: String
  groups: GroupUpdateManyWithoutTypeInput
  name: String
  roles: GroupRoleUpdateManyWithoutGroupTypeInput
}

input GroupTypeUpdateManyMutationInput {
  description: String
  name: String
}

input GroupTypeUpdateOneRequiredWithoutGroupsInput {
  create: GroupTypeCreateWithoutGroupsInput
  update: GroupTypeUpdateWithoutGroupsDataInput
  upsert: GroupTypeUpsertWithoutGroupsInput
  connect: GroupTypeWhereUniqueInput
}

input GroupTypeUpdateOneWithoutRolesInput {
  create: GroupTypeCreateWithoutRolesInput
  update: GroupTypeUpdateWithoutRolesDataInput
  upsert: GroupTypeUpsertWithoutRolesInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupTypeWhereUniqueInput
}

input GroupTypeUpdateWithoutGroupsDataInput {
  description: String
  name: String
  roles: GroupRoleUpdateManyWithoutGroupTypeInput
}

input GroupTypeUpdateWithoutRolesDataInput {
  description: String
  groups: GroupUpdateManyWithoutTypeInput
  name: String
}

input GroupTypeUpsertWithoutGroupsInput {
  update: GroupTypeUpdateWithoutGroupsDataInput!
  create: GroupTypeCreateWithoutGroupsInput!
}

input GroupTypeUpsertWithoutRolesInput {
  update: GroupTypeUpdateWithoutRolesDataInput!
  create: GroupTypeCreateWithoutRolesInput!
}

input GroupTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  groups_every: GroupWhereInput
  groups_some: GroupWhereInput
  groups_none: GroupWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  roles_every: GroupRoleWhereInput
  roles_some: GroupRoleWhereInput
  roles_none: GroupRoleWhereInput
  AND: [GroupTypeWhereInput!]
  OR: [GroupTypeWhereInput!]
  NOT: [GroupTypeWhereInput!]
}

input GroupTypeWhereUniqueInput {
  id: ID
  name: String
}

input GroupUpdateDataInput {
  key: String
  description: String
  type: GroupTypeUpdateOneRequiredWithoutGroupsInput
  invites: GroupInviteUpdateManyWithoutGroupInput
  isActive: Boolean
  members: GroupMemberUpdateManyWithoutGroupInput
  name: String
  organization: GroupUpdateOneInput
}

input GroupUpdateInput {
  key: String
  description: String
  type: GroupTypeUpdateOneRequiredWithoutGroupsInput
  invites: GroupInviteUpdateManyWithoutGroupInput
  isActive: Boolean
  members: GroupMemberUpdateManyWithoutGroupInput
  name: String
  organization: GroupUpdateOneInput
}

input GroupUpdateManyDataInput {
  key: String
  description: String
  isActive: Boolean
  name: String
}

input GroupUpdateManyMutationInput {
  key: String
  description: String
  isActive: Boolean
  name: String
}

input GroupUpdateManyWithoutTypeInput {
  create: [GroupCreateWithoutTypeInput!]
  delete: [GroupWhereUniqueInput!]
  connect: [GroupWhereUniqueInput!]
  disconnect: [GroupWhereUniqueInput!]
  update: [GroupUpdateWithWhereUniqueWithoutTypeInput!]
  upsert: [GroupUpsertWithWhereUniqueWithoutTypeInput!]
  deleteMany: [GroupScalarWhereInput!]
  updateMany: [GroupUpdateManyWithWhereNestedInput!]
}

input GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput!
  data: GroupUpdateManyDataInput!
}

input GroupUpdateOneInput {
  create: GroupCreateInput
  update: GroupUpdateDataInput
  upsert: GroupUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupWhereUniqueInput
}

input GroupUpdateOneRequiredInput {
  create: GroupCreateInput
  update: GroupUpdateDataInput
  upsert: GroupUpsertNestedInput
  connect: GroupWhereUniqueInput
}

input GroupUpdateOneRequiredWithoutInvitesInput {
  create: GroupCreateWithoutInvitesInput
  update: GroupUpdateWithoutInvitesDataInput
  upsert: GroupUpsertWithoutInvitesInput
  connect: GroupWhereUniqueInput
}

input GroupUpdateOneWithoutMembersInput {
  create: GroupCreateWithoutMembersInput
  update: GroupUpdateWithoutMembersDataInput
  upsert: GroupUpsertWithoutMembersInput
  delete: Boolean
  disconnect: Boolean
  connect: GroupWhereUniqueInput
}

input GroupUpdateWithoutInvitesDataInput {
  key: String
  description: String
  type: GroupTypeUpdateOneRequiredWithoutGroupsInput
  isActive: Boolean
  members: GroupMemberUpdateManyWithoutGroupInput
  name: String
  organization: GroupUpdateOneInput
}

input GroupUpdateWithoutMembersDataInput {
  key: String
  description: String
  type: GroupTypeUpdateOneRequiredWithoutGroupsInput
  invites: GroupInviteUpdateManyWithoutGroupInput
  isActive: Boolean
  name: String
  organization: GroupUpdateOneInput
}

input GroupUpdateWithoutTypeDataInput {
  key: String
  description: String
  invites: GroupInviteUpdateManyWithoutGroupInput
  isActive: Boolean
  members: GroupMemberUpdateManyWithoutGroupInput
  name: String
  organization: GroupUpdateOneInput
}

input GroupUpdateWithWhereUniqueWithoutTypeInput {
  where: GroupWhereUniqueInput!
  data: GroupUpdateWithoutTypeDataInput!
}

input GroupUpsertNestedInput {
  update: GroupUpdateDataInput!
  create: GroupCreateInput!
}

input GroupUpsertWithoutInvitesInput {
  update: GroupUpdateWithoutInvitesDataInput!
  create: GroupCreateWithoutInvitesInput!
}

input GroupUpsertWithoutMembersInput {
  update: GroupUpdateWithoutMembersDataInput!
  create: GroupCreateWithoutMembersInput!
}

input GroupUpsertWithWhereUniqueWithoutTypeInput {
  where: GroupWhereUniqueInput!
  update: GroupUpdateWithoutTypeDataInput!
  create: GroupCreateWithoutTypeInput!
}

input GroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: GroupTypeWhereInput
  invites_every: GroupInviteWhereInput
  invites_some: GroupInviteWhereInput
  invites_none: GroupInviteWhereInput
  isActive: Boolean
  isActive_not: Boolean
  members_every: GroupMemberWhereInput
  members_some: GroupMemberWhereInput
  members_none: GroupMemberWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  organization: GroupWhereInput
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: ID
  key: String
}

type Location {
  id: ID!
  city: String
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
}

enum LOCATION_TYPE {
  HOME
  WORK
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  city: String
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  city_ASC
  city_DESC
  locationType_ASC
  locationType_DESC
  postalCode_ASC
  postalCode_DESC
  state_ASC
  state_DESC
  street1_ASC
  street1_DESC
  street2_ASC
  street2_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LocationPreviousValues {
  id: ID!
  city: String
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  city: String
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
}

input LocationUpdateInput {
  city: String
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
}

input LocationUpdateManyMutationInput {
  city: String
  locationType: LOCATION_TYPE
  postalCode: String
  state: String
  street1: String
  street2: String
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  locationType: LOCATION_TYPE
  locationType_not: LOCATION_TYPE
  locationType_in: [LOCATION_TYPE!]
  locationType_not_in: [LOCATION_TYPE!]
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  street1: String
  street1_not: String
  street1_in: [String!]
  street1_not_in: [String!]
  street1_lt: String
  street1_lte: String
  street1_gt: String
  street1_gte: String
  street1_contains: String
  street1_not_contains: String
  street1_starts_with: String
  street1_not_starts_with: String
  street1_ends_with: String
  street1_not_ends_with: String
  street2: String
  street2_not: String
  street2_in: [String!]
  street2_not_in: [String!]
  street2_lt: String
  street2_lte: String
  street2_gt: String
  street2_gte: String
  street2_contains: String
  street2_not_contains: String
  street2_starts_with: String
  street2_not_starts_with: String
  street2_ends_with: String
  street2_not_ends_with: String
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createPerson(data: PersonCreateInput!): Person!
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateManyPersons(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): BatchPayload!
  upsertPerson(where: PersonWhereUniqueInput!, create: PersonCreateInput!, update: PersonUpdateInput!): Person!
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteManyPersons(where: PersonWhereInput): BatchPayload!
  createPhoneNumber(data: PhoneNumberCreateInput!): PhoneNumber!
  updatePhoneNumber(data: PhoneNumberUpdateInput!, where: PhoneNumberWhereUniqueInput!): PhoneNumber
  updateManyPhoneNumbers(data: PhoneNumberUpdateManyMutationInput!, where: PhoneNumberWhereInput): BatchPayload!
  upsertPhoneNumber(where: PhoneNumberWhereUniqueInput!, create: PhoneNumberCreateInput!, update: PhoneNumberUpdateInput!): PhoneNumber!
  deletePhoneNumber(where: PhoneNumberWhereUniqueInput!): PhoneNumber
  deleteManyPhoneNumbers(where: PhoneNumberWhereInput): BatchPayload!
  createFinancialAccount(data: FinancialAccountCreateInput!): FinancialAccount!
  updateFinancialAccount(data: FinancialAccountUpdateInput!, where: FinancialAccountWhereUniqueInput!): FinancialAccount
  updateManyFinancialAccounts(data: FinancialAccountUpdateManyMutationInput!, where: FinancialAccountWhereInput): BatchPayload!
  upsertFinancialAccount(where: FinancialAccountWhereUniqueInput!, create: FinancialAccountCreateInput!, update: FinancialAccountUpdateInput!): FinancialAccount!
  deleteFinancialAccount(where: FinancialAccountWhereUniqueInput!): FinancialAccount
  deleteManyFinancialAccounts(where: FinancialAccountWhereInput): BatchPayload!
  createFinancialPaymentDetail(data: FinancialPaymentDetailCreateInput!): FinancialPaymentDetail!
  updateFinancialPaymentDetail(data: FinancialPaymentDetailUpdateInput!, where: FinancialPaymentDetailWhereUniqueInput!): FinancialPaymentDetail
  updateManyFinancialPaymentDetails(data: FinancialPaymentDetailUpdateManyMutationInput!, where: FinancialPaymentDetailWhereInput): BatchPayload!
  upsertFinancialPaymentDetail(where: FinancialPaymentDetailWhereUniqueInput!, create: FinancialPaymentDetailCreateInput!, update: FinancialPaymentDetailUpdateInput!): FinancialPaymentDetail!
  deleteFinancialPaymentDetail(where: FinancialPaymentDetailWhereUniqueInput!): FinancialPaymentDetail
  deleteManyFinancialPaymentDetails(where: FinancialPaymentDetailWhereInput): BatchPayload!
  createFinancialScheduledTransaction(data: FinancialScheduledTransactionCreateInput!): FinancialScheduledTransaction!
  updateFinancialScheduledTransaction(data: FinancialScheduledTransactionUpdateInput!, where: FinancialScheduledTransactionWhereUniqueInput!): FinancialScheduledTransaction
  updateManyFinancialScheduledTransactions(data: FinancialScheduledTransactionUpdateManyMutationInput!, where: FinancialScheduledTransactionWhereInput): BatchPayload!
  upsertFinancialScheduledTransaction(where: FinancialScheduledTransactionWhereUniqueInput!, create: FinancialScheduledTransactionCreateInput!, update: FinancialScheduledTransactionUpdateInput!): FinancialScheduledTransaction!
  deleteFinancialScheduledTransaction(where: FinancialScheduledTransactionWhereUniqueInput!): FinancialScheduledTransaction
  deleteManyFinancialScheduledTransactions(where: FinancialScheduledTransactionWhereInput): BatchPayload!
  createFinancialTransaction(data: FinancialTransactionCreateInput!): FinancialTransaction!
  updateFinancialTransaction(data: FinancialTransactionUpdateInput!, where: FinancialTransactionWhereUniqueInput!): FinancialTransaction
  updateManyFinancialTransactions(data: FinancialTransactionUpdateManyMutationInput!, where: FinancialTransactionWhereInput): BatchPayload!
  upsertFinancialTransaction(where: FinancialTransactionWhereUniqueInput!, create: FinancialTransactionCreateInput!, update: FinancialTransactionUpdateInput!): FinancialTransaction!
  deleteFinancialTransaction(where: FinancialTransactionWhereUniqueInput!): FinancialTransaction
  deleteManyFinancialTransactions(where: FinancialTransactionWhereInput): BatchPayload!
  createGroupInvite(data: GroupInviteCreateInput!): GroupInvite!
  updateGroupInvite(data: GroupInviteUpdateInput!, where: GroupInviteWhereUniqueInput!): GroupInvite
  updateManyGroupInvites(data: GroupInviteUpdateManyMutationInput!, where: GroupInviteWhereInput): BatchPayload!
  upsertGroupInvite(where: GroupInviteWhereUniqueInput!, create: GroupInviteCreateInput!, update: GroupInviteUpdateInput!): GroupInvite!
  deleteGroupInvite(where: GroupInviteWhereUniqueInput!): GroupInvite
  deleteManyGroupInvites(where: GroupInviteWhereInput): BatchPayload!
  createGroupMember(data: GroupMemberCreateInput!): GroupMember!
  updateGroupMember(data: GroupMemberUpdateInput!, where: GroupMemberWhereUniqueInput!): GroupMember
  upsertGroupMember(where: GroupMemberWhereUniqueInput!, create: GroupMemberCreateInput!, update: GroupMemberUpdateInput!): GroupMember!
  deleteGroupMember(where: GroupMemberWhereUniqueInput!): GroupMember
  deleteManyGroupMembers(where: GroupMemberWhereInput): BatchPayload!
  createGroupRole(data: GroupRoleCreateInput!): GroupRole!
  updateGroupRole(data: GroupRoleUpdateInput!, where: GroupRoleWhereUniqueInput!): GroupRole
  updateManyGroupRoles(data: GroupRoleUpdateManyMutationInput!, where: GroupRoleWhereInput): BatchPayload!
  upsertGroupRole(where: GroupRoleWhereUniqueInput!, create: GroupRoleCreateInput!, update: GroupRoleUpdateInput!): GroupRole!
  deleteGroupRole(where: GroupRoleWhereUniqueInput!): GroupRole
  deleteManyGroupRoles(where: GroupRoleWhereInput): BatchPayload!
  createGroupType(data: GroupTypeCreateInput!): GroupType!
  updateGroupType(data: GroupTypeUpdateInput!, where: GroupTypeWhereUniqueInput!): GroupType
  updateManyGroupTypes(data: GroupTypeUpdateManyMutationInput!, where: GroupTypeWhereInput): BatchPayload!
  upsertGroupType(where: GroupTypeWhereUniqueInput!, create: GroupTypeCreateInput!, update: GroupTypeUpdateInput!): GroupType!
  deleteGroupType(where: GroupTypeWhereUniqueInput!): GroupType
  deleteManyGroupTypes(where: GroupTypeWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createCampus(data: CampusCreateInput!): Campus!
  updateCampus(data: CampusUpdateInput!, where: CampusWhereUniqueInput!): Campus
  updateManyCampuses(data: CampusUpdateManyMutationInput!, where: CampusWhereInput): BatchPayload!
  upsertCampus(where: CampusWhereUniqueInput!, create: CampusCreateInput!, update: CampusUpdateInput!): Campus!
  deleteCampus(where: CampusWhereUniqueInput!): Campus
  deleteManyCampuses(where: CampusWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Person {
  id: ID!
  email: String
  firstName: String
  lastName: String
  phoneNumbers(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber!]
  scheduledTransactions(where: FinancialScheduledTransactionWhereInput, orderBy: FinancialScheduledTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialScheduledTransaction!]
  transactions(where: FinancialTransactionWhereInput, orderBy: FinancialTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialTransaction!]
  user: User
}

type PersonConnection {
  pageInfo: PageInfo!
  edges: [PersonEdge]!
  aggregate: AggregatePerson!
}

input PersonCreateInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberCreateManyInput
  scheduledTransactions: FinancialScheduledTransactionCreateManyWithoutPersonInput
  transactions: FinancialTransactionCreateManyWithoutPersonInput
  user: UserCreateOneWithoutPersonInput
}

input PersonCreateOneInput {
  create: PersonCreateInput
  connect: PersonWhereUniqueInput
}

input PersonCreateOneWithoutScheduledTransactionsInput {
  create: PersonCreateWithoutScheduledTransactionsInput
  connect: PersonWhereUniqueInput
}

input PersonCreateOneWithoutTransactionsInput {
  create: PersonCreateWithoutTransactionsInput
  connect: PersonWhereUniqueInput
}

input PersonCreateOneWithoutUserInput {
  create: PersonCreateWithoutUserInput
  connect: PersonWhereUniqueInput
}

input PersonCreateWithoutScheduledTransactionsInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberCreateManyInput
  transactions: FinancialTransactionCreateManyWithoutPersonInput
  user: UserCreateOneWithoutPersonInput
}

input PersonCreateWithoutTransactionsInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberCreateManyInput
  scheduledTransactions: FinancialScheduledTransactionCreateManyWithoutPersonInput
  user: UserCreateOneWithoutPersonInput
}

input PersonCreateWithoutUserInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberCreateManyInput
  scheduledTransactions: FinancialScheduledTransactionCreateManyWithoutPersonInput
  transactions: FinancialTransactionCreateManyWithoutPersonInput
}

type PersonEdge {
  node: Person!
  cursor: String!
}

enum PersonOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PersonPreviousValues {
  id: ID!
  email: String
  firstName: String
  lastName: String
}

type PersonSubscriptionPayload {
  mutation: MutationType!
  node: Person
  updatedFields: [String!]
  previousValues: PersonPreviousValues
}

input PersonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PersonWhereInput
  AND: [PersonSubscriptionWhereInput!]
  OR: [PersonSubscriptionWhereInput!]
  NOT: [PersonSubscriptionWhereInput!]
}

input PersonUpdateDataInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberUpdateManyInput
  scheduledTransactions: FinancialScheduledTransactionUpdateManyWithoutPersonInput
  transactions: FinancialTransactionUpdateManyWithoutPersonInput
  user: UserUpdateOneWithoutPersonInput
}

input PersonUpdateInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberUpdateManyInput
  scheduledTransactions: FinancialScheduledTransactionUpdateManyWithoutPersonInput
  transactions: FinancialTransactionUpdateManyWithoutPersonInput
  user: UserUpdateOneWithoutPersonInput
}

input PersonUpdateManyMutationInput {
  email: String
  firstName: String
  lastName: String
}

input PersonUpdateOneInput {
  create: PersonCreateInput
  update: PersonUpdateDataInput
  upsert: PersonUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PersonWhereUniqueInput
}

input PersonUpdateOneRequiredWithoutUserInput {
  create: PersonCreateWithoutUserInput
  update: PersonUpdateWithoutUserDataInput
  upsert: PersonUpsertWithoutUserInput
  connect: PersonWhereUniqueInput
}

input PersonUpdateOneWithoutScheduledTransactionsInput {
  create: PersonCreateWithoutScheduledTransactionsInput
  update: PersonUpdateWithoutScheduledTransactionsDataInput
  upsert: PersonUpsertWithoutScheduledTransactionsInput
  delete: Boolean
  disconnect: Boolean
  connect: PersonWhereUniqueInput
}

input PersonUpdateOneWithoutTransactionsInput {
  create: PersonCreateWithoutTransactionsInput
  update: PersonUpdateWithoutTransactionsDataInput
  upsert: PersonUpsertWithoutTransactionsInput
  delete: Boolean
  disconnect: Boolean
  connect: PersonWhereUniqueInput
}

input PersonUpdateWithoutScheduledTransactionsDataInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberUpdateManyInput
  transactions: FinancialTransactionUpdateManyWithoutPersonInput
  user: UserUpdateOneWithoutPersonInput
}

input PersonUpdateWithoutTransactionsDataInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberUpdateManyInput
  scheduledTransactions: FinancialScheduledTransactionUpdateManyWithoutPersonInput
  user: UserUpdateOneWithoutPersonInput
}

input PersonUpdateWithoutUserDataInput {
  email: String
  firstName: String
  lastName: String
  phoneNumbers: PhoneNumberUpdateManyInput
  scheduledTransactions: FinancialScheduledTransactionUpdateManyWithoutPersonInput
  transactions: FinancialTransactionUpdateManyWithoutPersonInput
}

input PersonUpsertNestedInput {
  update: PersonUpdateDataInput!
  create: PersonCreateInput!
}

input PersonUpsertWithoutScheduledTransactionsInput {
  update: PersonUpdateWithoutScheduledTransactionsDataInput!
  create: PersonCreateWithoutScheduledTransactionsInput!
}

input PersonUpsertWithoutTransactionsInput {
  update: PersonUpdateWithoutTransactionsDataInput!
  create: PersonCreateWithoutTransactionsInput!
}

input PersonUpsertWithoutUserInput {
  update: PersonUpdateWithoutUserDataInput!
  create: PersonCreateWithoutUserInput!
}

input PersonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phoneNumbers_every: PhoneNumberWhereInput
  phoneNumbers_some: PhoneNumberWhereInput
  phoneNumbers_none: PhoneNumberWhereInput
  scheduledTransactions_every: FinancialScheduledTransactionWhereInput
  scheduledTransactions_some: FinancialScheduledTransactionWhereInput
  scheduledTransactions_none: FinancialScheduledTransactionWhereInput
  transactions_every: FinancialTransactionWhereInput
  transactions_some: FinancialTransactionWhereInput
  transactions_none: FinancialTransactionWhereInput
  user: UserWhereInput
  AND: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
}

input PersonWhereUniqueInput {
  id: ID
}

type PhoneNumber {
  id: ID!
  number: String!
}

type PhoneNumberConnection {
  pageInfo: PageInfo!
  edges: [PhoneNumberEdge]!
  aggregate: AggregatePhoneNumber!
}

input PhoneNumberCreateInput {
  number: String!
}

input PhoneNumberCreateManyInput {
  create: [PhoneNumberCreateInput!]
  connect: [PhoneNumberWhereUniqueInput!]
}

type PhoneNumberEdge {
  node: PhoneNumber!
  cursor: String!
}

enum PhoneNumberOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhoneNumberPreviousValues {
  id: ID!
  number: String!
}

input PhoneNumberScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  AND: [PhoneNumberScalarWhereInput!]
  OR: [PhoneNumberScalarWhereInput!]
  NOT: [PhoneNumberScalarWhereInput!]
}

type PhoneNumberSubscriptionPayload {
  mutation: MutationType!
  node: PhoneNumber
  updatedFields: [String!]
  previousValues: PhoneNumberPreviousValues
}

input PhoneNumberSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhoneNumberWhereInput
  AND: [PhoneNumberSubscriptionWhereInput!]
  OR: [PhoneNumberSubscriptionWhereInput!]
  NOT: [PhoneNumberSubscriptionWhereInput!]
}

input PhoneNumberUpdateDataInput {
  number: String
}

input PhoneNumberUpdateInput {
  number: String
}

input PhoneNumberUpdateManyDataInput {
  number: String
}

input PhoneNumberUpdateManyInput {
  create: [PhoneNumberCreateInput!]
  update: [PhoneNumberUpdateWithWhereUniqueNestedInput!]
  upsert: [PhoneNumberUpsertWithWhereUniqueNestedInput!]
  delete: [PhoneNumberWhereUniqueInput!]
  connect: [PhoneNumberWhereUniqueInput!]
  disconnect: [PhoneNumberWhereUniqueInput!]
  deleteMany: [PhoneNumberScalarWhereInput!]
  updateMany: [PhoneNumberUpdateManyWithWhereNestedInput!]
}

input PhoneNumberUpdateManyMutationInput {
  number: String
}

input PhoneNumberUpdateManyWithWhereNestedInput {
  where: PhoneNumberScalarWhereInput!
  data: PhoneNumberUpdateManyDataInput!
}

input PhoneNumberUpdateWithWhereUniqueNestedInput {
  where: PhoneNumberWhereUniqueInput!
  data: PhoneNumberUpdateDataInput!
}

input PhoneNumberUpsertWithWhereUniqueNestedInput {
  where: PhoneNumberWhereUniqueInput!
  update: PhoneNumberUpdateDataInput!
  create: PhoneNumberCreateInput!
}

input PhoneNumberWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  AND: [PhoneNumberWhereInput!]
  OR: [PhoneNumberWhereInput!]
  NOT: [PhoneNumberWhereInput!]
}

input PhoneNumberWhereUniqueInput {
  id: ID
}

type Query {
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  person(where: PersonWhereUniqueInput!): Person
  persons(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person]!
  personsConnection(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonConnection!
  phoneNumber(where: PhoneNumberWhereUniqueInput!): PhoneNumber
  phoneNumbers(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhoneNumber]!
  phoneNumbersConnection(where: PhoneNumberWhereInput, orderBy: PhoneNumberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhoneNumberConnection!
  financialAccount(where: FinancialAccountWhereUniqueInput!): FinancialAccount
  financialAccounts(where: FinancialAccountWhereInput, orderBy: FinancialAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialAccount]!
  financialAccountsConnection(where: FinancialAccountWhereInput, orderBy: FinancialAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FinancialAccountConnection!
  financialPaymentDetail(where: FinancialPaymentDetailWhereUniqueInput!): FinancialPaymentDetail
  financialPaymentDetails(where: FinancialPaymentDetailWhereInput, orderBy: FinancialPaymentDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialPaymentDetail]!
  financialPaymentDetailsConnection(where: FinancialPaymentDetailWhereInput, orderBy: FinancialPaymentDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FinancialPaymentDetailConnection!
  financialScheduledTransaction(where: FinancialScheduledTransactionWhereUniqueInput!): FinancialScheduledTransaction
  financialScheduledTransactions(where: FinancialScheduledTransactionWhereInput, orderBy: FinancialScheduledTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialScheduledTransaction]!
  financialScheduledTransactionsConnection(where: FinancialScheduledTransactionWhereInput, orderBy: FinancialScheduledTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FinancialScheduledTransactionConnection!
  financialTransaction(where: FinancialTransactionWhereUniqueInput!): FinancialTransaction
  financialTransactions(where: FinancialTransactionWhereInput, orderBy: FinancialTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialTransaction]!
  financialTransactionsConnection(where: FinancialTransactionWhereInput, orderBy: FinancialTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FinancialTransactionConnection!
  groupInvite(where: GroupInviteWhereUniqueInput!): GroupInvite
  groupInvites(where: GroupInviteWhereInput, orderBy: GroupInviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupInvite]!
  groupInvitesConnection(where: GroupInviteWhereInput, orderBy: GroupInviteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupInviteConnection!
  groupMember(where: GroupMemberWhereUniqueInput!): GroupMember
  groupMembers(where: GroupMemberWhereInput, orderBy: GroupMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupMember]!
  groupMembersConnection(where: GroupMemberWhereInput, orderBy: GroupMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupMemberConnection!
  groupRole(where: GroupRoleWhereUniqueInput!): GroupRole
  groupRoles(where: GroupRoleWhereInput, orderBy: GroupRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupRole]!
  groupRolesConnection(where: GroupRoleWhereInput, orderBy: GroupRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupRoleConnection!
  groupType(where: GroupTypeWhereUniqueInput!): GroupType
  groupTypes(where: GroupTypeWhereInput, orderBy: GroupTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GroupType]!
  groupTypesConnection(where: GroupTypeWhereInput, orderBy: GroupTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupTypeConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  campus(where: CampusWhereUniqueInput!): Campus
  campuses(where: CampusWhereInput, orderBy: CampusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Campus]!
  campusesConnection(where: CampusWhereInput, orderBy: CampusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CampusConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  node(id: ID!): Node
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  person(where: PersonSubscriptionWhereInput): PersonSubscriptionPayload
  phoneNumber(where: PhoneNumberSubscriptionWhereInput): PhoneNumberSubscriptionPayload
  financialAccount(where: FinancialAccountSubscriptionWhereInput): FinancialAccountSubscriptionPayload
  financialPaymentDetail(where: FinancialPaymentDetailSubscriptionWhereInput): FinancialPaymentDetailSubscriptionPayload
  financialScheduledTransaction(where: FinancialScheduledTransactionSubscriptionWhereInput): FinancialScheduledTransactionSubscriptionPayload
  financialTransaction(where: FinancialTransactionSubscriptionWhereInput): FinancialTransactionSubscriptionPayload
  groupInvite(where: GroupInviteSubscriptionWhereInput): GroupInviteSubscriptionPayload
  groupMember(where: GroupMemberSubscriptionWhereInput): GroupMemberSubscriptionPayload
  groupRole(where: GroupRoleSubscriptionWhereInput): GroupRoleSubscriptionPayload
  groupType(where: GroupTypeSubscriptionWhereInput): GroupTypeSubscriptionPayload
  group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
  campus(where: CampusSubscriptionWhereInput): CampusSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
}

enum TRANSACTION_FREQUENCY {
  DAILY
  MONTHLY
  BIWEEKLY
  CUSTOM
}

enum TRANSACTION_STATUS {
  PENDING
  SUCCESS
  FAILED
}

type User {
  id: ID!
  person: Person!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  person: PersonCreateOneWithoutUserInput!
}

input UserCreateOneWithoutPersonInput {
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  person: PersonUpdateOneRequiredWithoutUserInput
}

input UserUpdateOneWithoutPersonInput {
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  person: PersonWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
