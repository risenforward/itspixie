type AggregateBillingInfo {
  count: Int!
}

type AggregateBillingInfoWithoutConnection {
  count: Int!
}

type AggregateOptionalDetails {
  count: Int!
}

type AggregateOptionalDetailsWithoutConnection {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregatePostWithoutConnection {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BillingInfo {
  id: ID!
  account: String!
  user: User!
}

type BillingInfoConnection {
  pageInfo: PageInfo!
  edges: [BillingInfoEdge]!
  aggregate: AggregateBillingInfo!
}

input BillingInfoCreateInput {
  account: String!
  user: UserCreateOneWithoutBillingInfoInput!
}

input BillingInfoCreateOneWithoutUserInput {
  create: BillingInfoCreateWithoutUserInput
  connect: BillingInfoWhereUniqueInput
}

input BillingInfoCreateWithoutUserInput {
  account: String!
}

type BillingInfoEdge {
  node: BillingInfo!
  cursor: String!
}

enum BillingInfoOrderByInput {
  id_ASC
  id_DESC
  account_ASC
  account_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BillingInfoPreviousValues {
  id: ID!
  account: String!
}

type BillingInfoSubscriptionPayload {
  mutation: MutationType!
  node: BillingInfo
  updatedFields: [String!]
  previousValues: BillingInfoPreviousValues
}

input BillingInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BillingInfoWhereInput
  AND: [BillingInfoSubscriptionWhereInput!]
  OR: [BillingInfoSubscriptionWhereInput!]
  NOT: [BillingInfoSubscriptionWhereInput!]
}

input BillingInfoUpdateInput {
  account: String
  user: UserUpdateOneRequiredWithoutBillingInfoInput
}

input BillingInfoUpdateManyMutationInput {
  account: String
}

input BillingInfoUpdateOneRequiredWithoutUserInput {
  create: BillingInfoCreateWithoutUserInput
  update: BillingInfoUpdateWithoutUserDataInput
  upsert: BillingInfoUpsertWithoutUserInput
  connect: BillingInfoWhereUniqueInput
}

input BillingInfoUpdateWithoutUserDataInput {
  account: String
}

input BillingInfoUpsertWithoutUserInput {
  update: BillingInfoUpdateWithoutUserDataInput!
  create: BillingInfoCreateWithoutUserInput!
}

input BillingInfoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  account: String
  account_not: String
  account_in: [String!]
  account_not_in: [String!]
  account_lt: String
  account_lte: String
  account_gt: String
  account_gte: String
  account_contains: String
  account_not_contains: String
  account_starts_with: String
  account_not_starts_with: String
  account_ends_with: String
  account_not_ends_with: String
  user: UserWhereInput
  AND: [BillingInfoWhereInput!]
  OR: [BillingInfoWhereInput!]
  NOT: [BillingInfoWhereInput!]
}

input BillingInfoWhereUniqueInput {
  id: ID
}

type BillingInfoWithoutConnection {
  account: String!
}

type BillingInfoWithoutConnectionConnection {
  pageInfo: PageInfo!
  edges: [BillingInfoWithoutConnectionEdge]!
  aggregate: AggregateBillingInfoWithoutConnection!
}

input BillingInfoWithoutConnectionCreateInput {
  account: String!
}

input BillingInfoWithoutConnectionCreateOneInput {
  create: BillingInfoWithoutConnectionCreateInput
}

type BillingInfoWithoutConnectionEdge {
  node: BillingInfoWithoutConnection!
  cursor: String!
}

enum BillingInfoWithoutConnectionOrderByInput {
  account_ASC
  account_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BillingInfoWithoutConnectionPreviousValues {
  account: String!
}

type BillingInfoWithoutConnectionSubscriptionPayload {
  mutation: MutationType!
  node: BillingInfoWithoutConnection
  updatedFields: [String!]
  previousValues: BillingInfoWithoutConnectionPreviousValues
}

input BillingInfoWithoutConnectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BillingInfoWithoutConnectionWhereInput
  AND: [BillingInfoWithoutConnectionSubscriptionWhereInput!]
  OR: [BillingInfoWithoutConnectionSubscriptionWhereInput!]
  NOT: [BillingInfoWithoutConnectionSubscriptionWhereInput!]
}

input BillingInfoWithoutConnectionUpdateDataInput {
  account: String
}

input BillingInfoWithoutConnectionUpdateManyMutationInput {
  account: String
}

input BillingInfoWithoutConnectionUpdateOneRequiredInput {
  create: BillingInfoWithoutConnectionCreateInput
  update: BillingInfoWithoutConnectionUpdateDataInput
  upsert: BillingInfoWithoutConnectionUpsertNestedInput
}

input BillingInfoWithoutConnectionUpsertNestedInput {
  update: BillingInfoWithoutConnectionUpdateDataInput!
  create: BillingInfoWithoutConnectionCreateInput!
}

input BillingInfoWithoutConnectionWhereInput {
  account: String
  account_not: String
  account_in: [String!]
  account_not_in: [String!]
  account_lt: String
  account_lte: String
  account_gt: String
  account_gte: String
  account_contains: String
  account_not_contains: String
  account_starts_with: String
  account_not_starts_with: String
  account_ends_with: String
  account_not_ends_with: String
  AND: [BillingInfoWithoutConnectionWhereInput!]
  OR: [BillingInfoWithoutConnectionWhereInput!]
  NOT: [BillingInfoWithoutConnectionWhereInput!]
}

scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createPostWithoutConnection(data: PostWithoutConnectionCreateInput!): PostWithoutConnection!
  updatePostWithoutConnection(data: PostWithoutConnectionUpdateInput!, where: PostWithoutConnectionWhereUniqueInput!): PostWithoutConnection
  updateManyPostWithoutConnections(data: PostWithoutConnectionUpdateManyMutationInput!, where: PostWithoutConnectionWhereInput): BatchPayload!
  upsertPostWithoutConnection(where: PostWithoutConnectionWhereUniqueInput!, create: PostWithoutConnectionCreateInput!, update: PostWithoutConnectionUpdateInput!): PostWithoutConnection!
  deletePostWithoutConnection(where: PostWithoutConnectionWhereUniqueInput!): PostWithoutConnection
  deleteManyPostWithoutConnections(where: PostWithoutConnectionWhereInput): BatchPayload!
  createBillingInfo(data: BillingInfoCreateInput!): BillingInfo!
  updateBillingInfo(data: BillingInfoUpdateInput!, where: BillingInfoWhereUniqueInput!): BillingInfo
  updateManyBillingInfoes(data: BillingInfoUpdateManyMutationInput!, where: BillingInfoWhereInput): BatchPayload!
  upsertBillingInfo(where: BillingInfoWhereUniqueInput!, create: BillingInfoCreateInput!, update: BillingInfoUpdateInput!): BillingInfo!
  deleteBillingInfo(where: BillingInfoWhereUniqueInput!): BillingInfo
  deleteManyBillingInfoes(where: BillingInfoWhereInput): BatchPayload!
  createBillingInfoWithoutConnection(data: BillingInfoWithoutConnectionCreateInput!): BillingInfoWithoutConnection!
  updateManyBillingInfoWithoutConnections(data: BillingInfoWithoutConnectionUpdateManyMutationInput!, where: BillingInfoWithoutConnectionWhereInput): BatchPayload!
  deleteManyBillingInfoWithoutConnections(where: BillingInfoWithoutConnectionWhereInput): BatchPayload!
  createOptionalDetails(data: OptionalDetailsCreateInput!): OptionalDetails!
  updateManyOptionalDetailses(data: OptionalDetailsUpdateManyMutationInput!, where: OptionalDetailsWhereInput): BatchPayload!
  deleteManyOptionalDetailses(where: OptionalDetailsWhereInput): BatchPayload!
  createOptionalDetailsWithoutConnection(data: OptionalDetailsWithoutConnectionCreateInput!): OptionalDetailsWithoutConnection!
  updateManyOptionalDetailsWithoutConnections(data: OptionalDetailsWithoutConnectionUpdateManyMutationInput!, where: OptionalDetailsWithoutConnectionWhereInput): BatchPayload!
  deleteManyOptionalDetailsWithoutConnections(where: OptionalDetailsWithoutConnectionWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type OptionalDetails {
  text: String!
  user: User!
}

type OptionalDetailsConnection {
  pageInfo: PageInfo!
  edges: [OptionalDetailsEdge]!
  aggregate: AggregateOptionalDetails!
}

input OptionalDetailsCreateInput {
  text: String!
  user: UserCreateOneWithoutOptionalDetailsInput!
}

input OptionalDetailsCreateOneWithoutUserInput {
  create: OptionalDetailsCreateWithoutUserInput
}

input OptionalDetailsCreateWithoutUserInput {
  text: String!
}

type OptionalDetailsEdge {
  node: OptionalDetails!
  cursor: String!
}

enum OptionalDetailsOrderByInput {
  text_ASC
  text_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OptionalDetailsPreviousValues {
  text: String!
}

type OptionalDetailsSubscriptionPayload {
  mutation: MutationType!
  node: OptionalDetails
  updatedFields: [String!]
  previousValues: OptionalDetailsPreviousValues
}

input OptionalDetailsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OptionalDetailsWhereInput
  AND: [OptionalDetailsSubscriptionWhereInput!]
  OR: [OptionalDetailsSubscriptionWhereInput!]
  NOT: [OptionalDetailsSubscriptionWhereInput!]
}

input OptionalDetailsUpdateManyMutationInput {
  text: String
}

input OptionalDetailsUpdateOneWithoutUserInput {
  create: OptionalDetailsCreateWithoutUserInput
  update: OptionalDetailsUpdateWithoutUserDataInput
  upsert: OptionalDetailsUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
}

input OptionalDetailsUpdateWithoutUserDataInput {
  text: String
}

input OptionalDetailsUpsertWithoutUserInput {
  update: OptionalDetailsUpdateWithoutUserDataInput!
  create: OptionalDetailsCreateWithoutUserInput!
}

input OptionalDetailsWhereInput {
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  user: UserWhereInput
  AND: [OptionalDetailsWhereInput!]
  OR: [OptionalDetailsWhereInput!]
  NOT: [OptionalDetailsWhereInput!]
}

type OptionalDetailsWithoutConnection {
  text: String!
}

type OptionalDetailsWithoutConnectionConnection {
  pageInfo: PageInfo!
  edges: [OptionalDetailsWithoutConnectionEdge]!
  aggregate: AggregateOptionalDetailsWithoutConnection!
}

input OptionalDetailsWithoutConnectionCreateInput {
  text: String!
}

input OptionalDetailsWithoutConnectionCreateOneInput {
  create: OptionalDetailsWithoutConnectionCreateInput
}

type OptionalDetailsWithoutConnectionEdge {
  node: OptionalDetailsWithoutConnection!
  cursor: String!
}

enum OptionalDetailsWithoutConnectionOrderByInput {
  text_ASC
  text_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OptionalDetailsWithoutConnectionPreviousValues {
  text: String!
}

type OptionalDetailsWithoutConnectionSubscriptionPayload {
  mutation: MutationType!
  node: OptionalDetailsWithoutConnection
  updatedFields: [String!]
  previousValues: OptionalDetailsWithoutConnectionPreviousValues
}

input OptionalDetailsWithoutConnectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OptionalDetailsWithoutConnectionWhereInput
  AND: [OptionalDetailsWithoutConnectionSubscriptionWhereInput!]
  OR: [OptionalDetailsWithoutConnectionSubscriptionWhereInput!]
  NOT: [OptionalDetailsWithoutConnectionSubscriptionWhereInput!]
}

input OptionalDetailsWithoutConnectionUpdateDataInput {
  text: String
}

input OptionalDetailsWithoutConnectionUpdateManyMutationInput {
  text: String
}

input OptionalDetailsWithoutConnectionUpdateOneInput {
  create: OptionalDetailsWithoutConnectionCreateInput
  update: OptionalDetailsWithoutConnectionUpdateDataInput
  upsert: OptionalDetailsWithoutConnectionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input OptionalDetailsWithoutConnectionUpsertNestedInput {
  update: OptionalDetailsWithoutConnectionUpdateDataInput!
  create: OptionalDetailsWithoutConnectionCreateInput!
}

input OptionalDetailsWithoutConnectionWhereInput {
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [OptionalDetailsWithoutConnectionWhereInput!]
  OR: [OptionalDetailsWithoutConnectionWhereInput!]
  NOT: [OptionalDetailsWithoutConnectionWhereInput!]
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: ID!
  text: String!
  count: Int!
  user: User!
  likes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  text: String!
  count: Int!
  user: UserCreateOneWithoutPostsInput!
  likes: UserCreateManyWithoutLikesInput
}

input PostCreateManyWithoutLikesInput {
  create: [PostCreateWithoutLikesInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateManyWithoutUserInput {
  create: [PostCreateWithoutUserInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateWithoutLikesInput {
  text: String!
  count: Int!
  user: UserCreateOneWithoutPostsInput!
}

input PostCreateWithoutUserInput {
  text: String!
  count: Int!
  likes: UserCreateManyWithoutLikesInput
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  count_ASC
  count_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostPreviousValues {
  id: ID!
  text: String!
  count: Int!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  text: String
  count: Int
  user: UserUpdateOneRequiredWithoutPostsInput
  likes: UserUpdateManyWithoutLikesInput
}

input PostUpdateManyDataInput {
  text: String
  count: Int
}

input PostUpdateManyMutationInput {
  text: String
  count: Int
}

input PostUpdateManyWithoutLikesInput {
  create: [PostCreateWithoutLikesInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutLikesInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutLikesInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithoutUserInput {
  create: [PostCreateWithoutUserInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateWithoutLikesDataInput {
  text: String
  count: Int
  user: UserUpdateOneRequiredWithoutPostsInput
}

input PostUpdateWithoutUserDataInput {
  text: String
  count: Int
  likes: UserUpdateManyWithoutLikesInput
}

input PostUpdateWithWhereUniqueWithoutLikesInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutLikesDataInput!
}

input PostUpdateWithWhereUniqueWithoutUserInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutUserDataInput!
}

input PostUpsertWithWhereUniqueWithoutLikesInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutLikesDataInput!
  create: PostCreateWithoutLikesInput!
}

input PostUpsertWithWhereUniqueWithoutUserInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutUserDataInput!
  create: PostCreateWithoutUserInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  user: UserWhereInput
  likes_every: UserWhereInput
  likes_some: UserWhereInput
  likes_none: UserWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type PostWithoutConnection {
  id: ID!
  text: String!
  count: Int!
}

type PostWithoutConnectionConnection {
  pageInfo: PageInfo!
  edges: [PostWithoutConnectionEdge]!
  aggregate: AggregatePostWithoutConnection!
}

input PostWithoutConnectionCreateInput {
  text: String!
  count: Int!
}

input PostWithoutConnectionCreateManyInput {
  create: [PostWithoutConnectionCreateInput!]
  connect: [PostWithoutConnectionWhereUniqueInput!]
}

type PostWithoutConnectionEdge {
  node: PostWithoutConnection!
  cursor: String!
}

enum PostWithoutConnectionOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  count_ASC
  count_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostWithoutConnectionPreviousValues {
  id: ID!
  text: String!
  count: Int!
}

input PostWithoutConnectionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [PostWithoutConnectionScalarWhereInput!]
  OR: [PostWithoutConnectionScalarWhereInput!]
  NOT: [PostWithoutConnectionScalarWhereInput!]
}

type PostWithoutConnectionSubscriptionPayload {
  mutation: MutationType!
  node: PostWithoutConnection
  updatedFields: [String!]
  previousValues: PostWithoutConnectionPreviousValues
}

input PostWithoutConnectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWithoutConnectionWhereInput
  AND: [PostWithoutConnectionSubscriptionWhereInput!]
  OR: [PostWithoutConnectionSubscriptionWhereInput!]
  NOT: [PostWithoutConnectionSubscriptionWhereInput!]
}

input PostWithoutConnectionUpdateDataInput {
  text: String
  count: Int
}

input PostWithoutConnectionUpdateInput {
  text: String
  count: Int
}

input PostWithoutConnectionUpdateManyDataInput {
  text: String
  count: Int
}

input PostWithoutConnectionUpdateManyInput {
  create: [PostWithoutConnectionCreateInput!]
  update: [PostWithoutConnectionUpdateWithWhereUniqueNestedInput!]
  upsert: [PostWithoutConnectionUpsertWithWhereUniqueNestedInput!]
  delete: [PostWithoutConnectionWhereUniqueInput!]
  connect: [PostWithoutConnectionWhereUniqueInput!]
  disconnect: [PostWithoutConnectionWhereUniqueInput!]
  deleteMany: [PostWithoutConnectionScalarWhereInput!]
  updateMany: [PostWithoutConnectionUpdateManyWithWhereNestedInput!]
}

input PostWithoutConnectionUpdateManyMutationInput {
  text: String
  count: Int
}

input PostWithoutConnectionUpdateManyWithWhereNestedInput {
  where: PostWithoutConnectionScalarWhereInput!
  data: PostWithoutConnectionUpdateManyDataInput!
}

input PostWithoutConnectionUpdateWithWhereUniqueNestedInput {
  where: PostWithoutConnectionWhereUniqueInput!
  data: PostWithoutConnectionUpdateDataInput!
}

input PostWithoutConnectionUpsertWithWhereUniqueNestedInput {
  where: PostWithoutConnectionWhereUniqueInput!
  update: PostWithoutConnectionUpdateDataInput!
  create: PostWithoutConnectionCreateInput!
}

input PostWithoutConnectionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  AND: [PostWithoutConnectionWhereInput!]
  OR: [PostWithoutConnectionWhereInput!]
  NOT: [PostWithoutConnectionWhereInput!]
}

input PostWithoutConnectionWhereUniqueInput {
  id: ID
}

type Query {
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  postWithoutConnection(where: PostWithoutConnectionWhereUniqueInput!): PostWithoutConnection
  postWithoutConnections(where: PostWithoutConnectionWhereInput, orderBy: PostWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostWithoutConnection]!
  postWithoutConnectionsConnection(where: PostWithoutConnectionWhereInput, orderBy: PostWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostWithoutConnectionConnection!
  billingInfo(where: BillingInfoWhereUniqueInput!): BillingInfo
  billingInfoes(where: BillingInfoWhereInput, orderBy: BillingInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BillingInfo]!
  billingInfoesConnection(where: BillingInfoWhereInput, orderBy: BillingInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BillingInfoConnection!
  billingInfoWithoutConnections(where: BillingInfoWithoutConnectionWhereInput, orderBy: BillingInfoWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BillingInfoWithoutConnection]!
  billingInfoWithoutConnectionsConnection(where: BillingInfoWithoutConnectionWhereInput, orderBy: BillingInfoWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BillingInfoWithoutConnectionConnection!
  optionalDetailses(where: OptionalDetailsWhereInput, orderBy: OptionalDetailsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OptionalDetails]!
  optionalDetailsesConnection(where: OptionalDetailsWhereInput, orderBy: OptionalDetailsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OptionalDetailsConnection!
  optionalDetailsWithoutConnections(where: OptionalDetailsWithoutConnectionWhereInput, orderBy: OptionalDetailsWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OptionalDetailsWithoutConnection]!
  optionalDetailsWithoutConnectionsConnection(where: OptionalDetailsWithoutConnectionWhereInput, orderBy: OptionalDetailsWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OptionalDetailsWithoutConnectionConnection!
  node(id: ID!): Node
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  postWithoutConnection(where: PostWithoutConnectionSubscriptionWhereInput): PostWithoutConnectionSubscriptionPayload
  billingInfo(where: BillingInfoSubscriptionWhereInput): BillingInfoSubscriptionPayload
  billingInfoWithoutConnection(where: BillingInfoWithoutConnectionSubscriptionWhereInput): BillingInfoWithoutConnectionSubscriptionPayload
  optionalDetails(where: OptionalDetailsSubscriptionWhereInput): OptionalDetailsSubscriptionPayload
  optionalDetailsWithoutConnection(where: OptionalDetailsWithoutConnectionSubscriptionWhereInput): OptionalDetailsWithoutConnectionSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  postsWithoutConnection(where: PostWithoutConnectionWhereInput, orderBy: PostWithoutConnectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PostWithoutConnection!]
  billingInfo: BillingInfo!
  billingInfoWithoutConnection: BillingInfoWithoutConnection!
  likes(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  optionalDetails: OptionalDetails
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnection
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  name: String!
  posts: PostCreateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionCreateManyInput
  billingInfo: BillingInfoCreateOneWithoutUserInput!
  billingInfoWithoutConnection: BillingInfoWithoutConnectionCreateOneInput!
  likes: PostCreateManyWithoutLikesInput
  optionalDetails: OptionalDetailsCreateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionCreateOneInput
}

input UserCreateManyWithoutLikesInput {
  create: [UserCreateWithoutLikesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutBillingInfoInput {
  create: UserCreateWithoutBillingInfoInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOptionalDetailsInput {
  create: UserCreateWithoutOptionalDetailsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBillingInfoInput {
  name: String!
  posts: PostCreateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionCreateManyInput
  billingInfoWithoutConnection: BillingInfoWithoutConnectionCreateOneInput!
  likes: PostCreateManyWithoutLikesInput
  optionalDetails: OptionalDetailsCreateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionCreateOneInput
}

input UserCreateWithoutLikesInput {
  name: String!
  posts: PostCreateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionCreateManyInput
  billingInfo: BillingInfoCreateOneWithoutUserInput!
  billingInfoWithoutConnection: BillingInfoWithoutConnectionCreateOneInput!
  optionalDetails: OptionalDetailsCreateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionCreateOneInput
}

input UserCreateWithoutOptionalDetailsInput {
  name: String!
  posts: PostCreateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionCreateManyInput
  billingInfo: BillingInfoCreateOneWithoutUserInput!
  billingInfoWithoutConnection: BillingInfoWithoutConnectionCreateOneInput!
  likes: PostCreateManyWithoutLikesInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionCreateOneInput
}

input UserCreateWithoutPostsInput {
  name: String!
  postsWithoutConnection: PostWithoutConnectionCreateManyInput
  billingInfo: BillingInfoCreateOneWithoutUserInput!
  billingInfoWithoutConnection: BillingInfoWithoutConnectionCreateOneInput!
  likes: PostCreateManyWithoutLikesInput
  optionalDetails: OptionalDetailsCreateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionCreateOneInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  posts: PostUpdateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionUpdateManyInput
  billingInfo: BillingInfoUpdateOneRequiredWithoutUserInput
  billingInfoWithoutConnection: BillingInfoWithoutConnectionUpdateOneRequiredInput
  likes: PostUpdateManyWithoutLikesInput
  optionalDetails: OptionalDetailsUpdateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionUpdateOneInput
}

input UserUpdateManyDataInput {
  name: String
}

input UserUpdateManyMutationInput {
  name: String
}

input UserUpdateManyWithoutLikesInput {
  create: [UserCreateWithoutLikesInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikesInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredWithoutBillingInfoInput {
  create: UserCreateWithoutBillingInfoInput
  update: UserUpdateWithoutBillingInfoDataInput
  upsert: UserUpsertWithoutBillingInfoInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBillingInfoDataInput {
  name: String
  posts: PostUpdateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionUpdateManyInput
  billingInfoWithoutConnection: BillingInfoWithoutConnectionUpdateOneRequiredInput
  likes: PostUpdateManyWithoutLikesInput
  optionalDetails: OptionalDetailsUpdateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionUpdateOneInput
}

input UserUpdateWithoutLikesDataInput {
  name: String
  posts: PostUpdateManyWithoutUserInput
  postsWithoutConnection: PostWithoutConnectionUpdateManyInput
  billingInfo: BillingInfoUpdateOneRequiredWithoutUserInput
  billingInfoWithoutConnection: BillingInfoWithoutConnectionUpdateOneRequiredInput
  optionalDetails: OptionalDetailsUpdateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionUpdateOneInput
}

input UserUpdateWithoutPostsDataInput {
  name: String
  postsWithoutConnection: PostWithoutConnectionUpdateManyInput
  billingInfo: BillingInfoUpdateOneRequiredWithoutUserInput
  billingInfoWithoutConnection: BillingInfoWithoutConnectionUpdateOneRequiredInput
  likes: PostUpdateManyWithoutLikesInput
  optionalDetails: OptionalDetailsUpdateOneWithoutUserInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionUpdateOneInput
}

input UserUpdateWithWhereUniqueWithoutLikesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikesDataInput!
}

input UserUpsertWithoutBillingInfoInput {
  update: UserUpdateWithoutBillingInfoDataInput!
  create: UserCreateWithoutBillingInfoInput!
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserUpsertWithWhereUniqueWithoutLikesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikesDataInput!
  create: UserCreateWithoutLikesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  postsWithoutConnection_every: PostWithoutConnectionWhereInput
  postsWithoutConnection_some: PostWithoutConnectionWhereInput
  postsWithoutConnection_none: PostWithoutConnectionWhereInput
  billingInfo: BillingInfoWhereInput
  billingInfoWithoutConnection: BillingInfoWithoutConnectionWhereInput
  likes_every: PostWhereInput
  likes_some: PostWhereInput
  likes_none: PostWhereInput
  optionalDetails: OptionalDetailsWhereInput
  optionalDetailsWithoutConnection: OptionalDetailsWithoutConnectionWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
