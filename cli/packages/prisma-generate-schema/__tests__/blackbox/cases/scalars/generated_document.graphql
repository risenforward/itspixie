type AggregateLotsOfRequiredScalars {
  count: Int!
}

type AggregateLotsOfRequiredScalarsWithID {
  count: Int!
}

type AggregateLotsOfScalarLists {
  count: Int!
}

type AggregateLotsOfScalarListsWithID {
  count: Int!
}

type AggregateLotsOfScalars {
  count: Int!
}

type AggregateLotsOfScalarsWithID {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

scalar Long

type LotsOfRequiredScalars {
  int: Int!
  string: String!
  float: Float!
  dateTime: DateTime!
  json: Json!
  boolean: Boolean!
}

type LotsOfRequiredScalarsConnection {
  pageInfo: PageInfo!
  edges: [LotsOfRequiredScalarsEdge]!
  aggregate: AggregateLotsOfRequiredScalars!
}

input LotsOfRequiredScalarsCreateInput {
  int: Int!
  string: String!
  float: Float!
  dateTime: DateTime!
  json: Json!
  boolean: Boolean!
}

type LotsOfRequiredScalarsEdge {
  node: LotsOfRequiredScalars!
  cursor: String!
}

enum LotsOfRequiredScalarsOrderByInput {
  int_ASC
  int_DESC
  string_ASC
  string_DESC
  float_ASC
  float_DESC
  dateTime_ASC
  dateTime_DESC
  json_ASC
  json_DESC
  boolean_ASC
  boolean_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LotsOfRequiredScalarsPreviousValues {
  int: Int!
  string: String!
  float: Float!
  dateTime: DateTime!
  json: Json!
  boolean: Boolean!
}

type LotsOfRequiredScalarsSubscriptionPayload {
  mutation: MutationType!
  node: LotsOfRequiredScalars
  updatedFields: [String!]
  previousValues: LotsOfRequiredScalarsPreviousValues
}

input LotsOfRequiredScalarsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LotsOfRequiredScalarsWhereInput
  AND: [LotsOfRequiredScalarsSubscriptionWhereInput!]
  OR: [LotsOfRequiredScalarsSubscriptionWhereInput!]
  NOT: [LotsOfRequiredScalarsSubscriptionWhereInput!]
}

input LotsOfRequiredScalarsUpdateManyMutationInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

input LotsOfRequiredScalarsWhereInput {
  int: Int
  int_not: Int
  int_in: [Int!]
  int_not_in: [Int!]
  int_lt: Int
  int_lte: Int
  int_gt: Int
  int_gte: Int
  string: String
  string_not: String
  string_in: [String!]
  string_not_in: [String!]
  string_lt: String
  string_lte: String
  string_gt: String
  string_gte: String
  string_contains: String
  string_not_contains: String
  string_starts_with: String
  string_not_starts_with: String
  string_ends_with: String
  string_not_ends_with: String
  float: Float
  float_not: Float
  float_in: [Float!]
  float_not_in: [Float!]
  float_lt: Float
  float_lte: Float
  float_gt: Float
  float_gte: Float
  dateTime: DateTime
  dateTime_not: DateTime
  dateTime_in: [DateTime!]
  dateTime_not_in: [DateTime!]
  dateTime_lt: DateTime
  dateTime_lte: DateTime
  dateTime_gt: DateTime
  dateTime_gte: DateTime
  boolean: Boolean
  boolean_not: Boolean
  AND: [LotsOfRequiredScalarsWhereInput!]
  OR: [LotsOfRequiredScalarsWhereInput!]
  NOT: [LotsOfRequiredScalarsWhereInput!]
}

type LotsOfRequiredScalarsWithID {
  id: ID!
  int: Int!
  string: String!
  float: Float!
  dateTime: DateTime!
  json: Json!
  boolean: Boolean!
}

type LotsOfRequiredScalarsWithIDConnection {
  pageInfo: PageInfo!
  edges: [LotsOfRequiredScalarsWithIDEdge]!
  aggregate: AggregateLotsOfRequiredScalarsWithID!
}

input LotsOfRequiredScalarsWithIDCreateInput {
  int: Int!
  string: String!
  float: Float!
  dateTime: DateTime!
  json: Json!
  boolean: Boolean!
}

type LotsOfRequiredScalarsWithIDEdge {
  node: LotsOfRequiredScalarsWithID!
  cursor: String!
}

enum LotsOfRequiredScalarsWithIDOrderByInput {
  id_ASC
  id_DESC
  int_ASC
  int_DESC
  string_ASC
  string_DESC
  float_ASC
  float_DESC
  dateTime_ASC
  dateTime_DESC
  json_ASC
  json_DESC
  boolean_ASC
  boolean_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LotsOfRequiredScalarsWithIDPreviousValues {
  id: ID!
  int: Int!
  string: String!
  float: Float!
  dateTime: DateTime!
  json: Json!
  boolean: Boolean!
}

type LotsOfRequiredScalarsWithIDSubscriptionPayload {
  mutation: MutationType!
  node: LotsOfRequiredScalarsWithID
  updatedFields: [String!]
  previousValues: LotsOfRequiredScalarsWithIDPreviousValues
}

input LotsOfRequiredScalarsWithIDSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LotsOfRequiredScalarsWithIDWhereInput
  AND: [LotsOfRequiredScalarsWithIDSubscriptionWhereInput!]
  OR: [LotsOfRequiredScalarsWithIDSubscriptionWhereInput!]
  NOT: [LotsOfRequiredScalarsWithIDSubscriptionWhereInput!]
}

input LotsOfRequiredScalarsWithIDUpdateInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

input LotsOfRequiredScalarsWithIDUpdateManyMutationInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

input LotsOfRequiredScalarsWithIDWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  int: Int
  int_not: Int
  int_in: [Int!]
  int_not_in: [Int!]
  int_lt: Int
  int_lte: Int
  int_gt: Int
  int_gte: Int
  string: String
  string_not: String
  string_in: [String!]
  string_not_in: [String!]
  string_lt: String
  string_lte: String
  string_gt: String
  string_gte: String
  string_contains: String
  string_not_contains: String
  string_starts_with: String
  string_not_starts_with: String
  string_ends_with: String
  string_not_ends_with: String
  float: Float
  float_not: Float
  float_in: [Float!]
  float_not_in: [Float!]
  float_lt: Float
  float_lte: Float
  float_gt: Float
  float_gte: Float
  dateTime: DateTime
  dateTime_not: DateTime
  dateTime_in: [DateTime!]
  dateTime_not_in: [DateTime!]
  dateTime_lt: DateTime
  dateTime_lte: DateTime
  dateTime_gt: DateTime
  dateTime_gte: DateTime
  boolean: Boolean
  boolean_not: Boolean
  AND: [LotsOfRequiredScalarsWithIDWhereInput!]
  OR: [LotsOfRequiredScalarsWithIDWhereInput!]
  NOT: [LotsOfRequiredScalarsWithIDWhereInput!]
}

input LotsOfRequiredScalarsWithIDWhereUniqueInput {
  id: ID
}

type LotsOfScalarLists {
  int: [Int!]!
  string: [String!]!
  float: [Float!]!
  dateTime: [DateTime!]!
  json: [Json!]!
  boolean: [Boolean!]!
}

type LotsOfScalarListsConnection {
  pageInfo: PageInfo!
  edges: [LotsOfScalarListsEdge]!
  aggregate: AggregateLotsOfScalarLists!
}

input LotsOfScalarListsCreatebooleanInput {
  set: [Boolean!]
}

input LotsOfScalarListsCreatedateTimeInput {
  set: [DateTime!]
}

input LotsOfScalarListsCreatefloatInput {
  set: [Float!]
}

input LotsOfScalarListsCreateInput {
  int: LotsOfScalarListsCreateintInput
  string: LotsOfScalarListsCreatestringInput
  float: LotsOfScalarListsCreatefloatInput
  dateTime: LotsOfScalarListsCreatedateTimeInput
  json: LotsOfScalarListsCreatejsonInput
  boolean: LotsOfScalarListsCreatebooleanInput
}

input LotsOfScalarListsCreateintInput {
  set: [Int!]
}

input LotsOfScalarListsCreatejsonInput {
  set: [Json!]
}

input LotsOfScalarListsCreatestringInput {
  set: [String!]
}

type LotsOfScalarListsEdge {
  node: LotsOfScalarLists!
  cursor: String!
}

enum LotsOfScalarListsOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LotsOfScalarListsPreviousValues {
  int: [Int!]!
  string: [String!]!
  float: [Float!]!
  dateTime: [DateTime!]!
  json: [Json!]!
  boolean: [Boolean!]!
}

type LotsOfScalarListsSubscriptionPayload {
  mutation: MutationType!
  node: LotsOfScalarLists
  updatedFields: [String!]
  previousValues: LotsOfScalarListsPreviousValues
}

input LotsOfScalarListsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LotsOfScalarListsWhereInput
  AND: [LotsOfScalarListsSubscriptionWhereInput!]
  OR: [LotsOfScalarListsSubscriptionWhereInput!]
  NOT: [LotsOfScalarListsSubscriptionWhereInput!]
}

input LotsOfScalarListsUpdatebooleanInput {
  set: [Boolean!]
}

input LotsOfScalarListsUpdatedateTimeInput {
  set: [DateTime!]
}

input LotsOfScalarListsUpdatefloatInput {
  set: [Float!]
}

input LotsOfScalarListsUpdateintInput {
  set: [Int!]
}

input LotsOfScalarListsUpdatejsonInput {
  set: [Json!]
}

input LotsOfScalarListsUpdateManyMutationInput {
  int: LotsOfScalarListsUpdateintInput
  string: LotsOfScalarListsUpdatestringInput
  float: LotsOfScalarListsUpdatefloatInput
  dateTime: LotsOfScalarListsUpdatedateTimeInput
  json: LotsOfScalarListsUpdatejsonInput
  boolean: LotsOfScalarListsUpdatebooleanInput
}

input LotsOfScalarListsUpdatestringInput {
  set: [String!]
}

input LotsOfScalarListsWhereInput {
  AND: [LotsOfScalarListsWhereInput!]
  OR: [LotsOfScalarListsWhereInput!]
  NOT: [LotsOfScalarListsWhereInput!]
}

type LotsOfScalarListsWithID {
  id: ID!
  int: [Int!]!
  string: [String!]!
  float: [Float!]!
  dateTime: [DateTime!]!
  json: [Json!]!
  boolean: [Boolean!]!
}

type LotsOfScalarListsWithIDConnection {
  pageInfo: PageInfo!
  edges: [LotsOfScalarListsWithIDEdge]!
  aggregate: AggregateLotsOfScalarListsWithID!
}

input LotsOfScalarListsWithIDCreatebooleanInput {
  set: [Boolean!]
}

input LotsOfScalarListsWithIDCreatedateTimeInput {
  set: [DateTime!]
}

input LotsOfScalarListsWithIDCreatefloatInput {
  set: [Float!]
}

input LotsOfScalarListsWithIDCreateInput {
  int: LotsOfScalarListsWithIDCreateintInput
  string: LotsOfScalarListsWithIDCreatestringInput
  float: LotsOfScalarListsWithIDCreatefloatInput
  dateTime: LotsOfScalarListsWithIDCreatedateTimeInput
  json: LotsOfScalarListsWithIDCreatejsonInput
  boolean: LotsOfScalarListsWithIDCreatebooleanInput
}

input LotsOfScalarListsWithIDCreateintInput {
  set: [Int!]
}

input LotsOfScalarListsWithIDCreatejsonInput {
  set: [Json!]
}

input LotsOfScalarListsWithIDCreatestringInput {
  set: [String!]
}

type LotsOfScalarListsWithIDEdge {
  node: LotsOfScalarListsWithID!
  cursor: String!
}

enum LotsOfScalarListsWithIDOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LotsOfScalarListsWithIDPreviousValues {
  id: ID!
  int: [Int!]!
  string: [String!]!
  float: [Float!]!
  dateTime: [DateTime!]!
  json: [Json!]!
  boolean: [Boolean!]!
}

type LotsOfScalarListsWithIDSubscriptionPayload {
  mutation: MutationType!
  node: LotsOfScalarListsWithID
  updatedFields: [String!]
  previousValues: LotsOfScalarListsWithIDPreviousValues
}

input LotsOfScalarListsWithIDSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LotsOfScalarListsWithIDWhereInput
  AND: [LotsOfScalarListsWithIDSubscriptionWhereInput!]
  OR: [LotsOfScalarListsWithIDSubscriptionWhereInput!]
  NOT: [LotsOfScalarListsWithIDSubscriptionWhereInput!]
}

input LotsOfScalarListsWithIDUpdatebooleanInput {
  set: [Boolean!]
}

input LotsOfScalarListsWithIDUpdatedateTimeInput {
  set: [DateTime!]
}

input LotsOfScalarListsWithIDUpdatefloatInput {
  set: [Float!]
}

input LotsOfScalarListsWithIDUpdateInput {
  int: LotsOfScalarListsWithIDUpdateintInput
  string: LotsOfScalarListsWithIDUpdatestringInput
  float: LotsOfScalarListsWithIDUpdatefloatInput
  dateTime: LotsOfScalarListsWithIDUpdatedateTimeInput
  json: LotsOfScalarListsWithIDUpdatejsonInput
  boolean: LotsOfScalarListsWithIDUpdatebooleanInput
}

input LotsOfScalarListsWithIDUpdateintInput {
  set: [Int!]
}

input LotsOfScalarListsWithIDUpdatejsonInput {
  set: [Json!]
}

input LotsOfScalarListsWithIDUpdateManyMutationInput {
  int: LotsOfScalarListsWithIDUpdateintInput
  string: LotsOfScalarListsWithIDUpdatestringInput
  float: LotsOfScalarListsWithIDUpdatefloatInput
  dateTime: LotsOfScalarListsWithIDUpdatedateTimeInput
  json: LotsOfScalarListsWithIDUpdatejsonInput
  boolean: LotsOfScalarListsWithIDUpdatebooleanInput
}

input LotsOfScalarListsWithIDUpdatestringInput {
  set: [String!]
}

input LotsOfScalarListsWithIDWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [LotsOfScalarListsWithIDWhereInput!]
  OR: [LotsOfScalarListsWithIDWhereInput!]
  NOT: [LotsOfScalarListsWithIDWhereInput!]
}

input LotsOfScalarListsWithIDWhereUniqueInput {
  id: ID
}

type LotsOfScalars {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

type LotsOfScalarsConnection {
  pageInfo: PageInfo!
  edges: [LotsOfScalarsEdge]!
  aggregate: AggregateLotsOfScalars!
}

input LotsOfScalarsCreateInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

type LotsOfScalarsEdge {
  node: LotsOfScalars!
  cursor: String!
}

enum LotsOfScalarsOrderByInput {
  int_ASC
  int_DESC
  string_ASC
  string_DESC
  float_ASC
  float_DESC
  dateTime_ASC
  dateTime_DESC
  json_ASC
  json_DESC
  boolean_ASC
  boolean_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LotsOfScalarsPreviousValues {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

type LotsOfScalarsSubscriptionPayload {
  mutation: MutationType!
  node: LotsOfScalars
  updatedFields: [String!]
  previousValues: LotsOfScalarsPreviousValues
}

input LotsOfScalarsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LotsOfScalarsWhereInput
  AND: [LotsOfScalarsSubscriptionWhereInput!]
  OR: [LotsOfScalarsSubscriptionWhereInput!]
  NOT: [LotsOfScalarsSubscriptionWhereInput!]
}

input LotsOfScalarsUpdateManyMutationInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

input LotsOfScalarsWhereInput {
  int: Int
  int_not: Int
  int_in: [Int!]
  int_not_in: [Int!]
  int_lt: Int
  int_lte: Int
  int_gt: Int
  int_gte: Int
  string: String
  string_not: String
  string_in: [String!]
  string_not_in: [String!]
  string_lt: String
  string_lte: String
  string_gt: String
  string_gte: String
  string_contains: String
  string_not_contains: String
  string_starts_with: String
  string_not_starts_with: String
  string_ends_with: String
  string_not_ends_with: String
  float: Float
  float_not: Float
  float_in: [Float!]
  float_not_in: [Float!]
  float_lt: Float
  float_lte: Float
  float_gt: Float
  float_gte: Float
  dateTime: DateTime
  dateTime_not: DateTime
  dateTime_in: [DateTime!]
  dateTime_not_in: [DateTime!]
  dateTime_lt: DateTime
  dateTime_lte: DateTime
  dateTime_gt: DateTime
  dateTime_gte: DateTime
  boolean: Boolean
  boolean_not: Boolean
  AND: [LotsOfScalarsWhereInput!]
  OR: [LotsOfScalarsWhereInput!]
  NOT: [LotsOfScalarsWhereInput!]
}

type LotsOfScalarsWithID {
  id: ID!
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

type LotsOfScalarsWithIDConnection {
  pageInfo: PageInfo!
  edges: [LotsOfScalarsWithIDEdge]!
  aggregate: AggregateLotsOfScalarsWithID!
}

input LotsOfScalarsWithIDCreateInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

type LotsOfScalarsWithIDEdge {
  node: LotsOfScalarsWithID!
  cursor: String!
}

enum LotsOfScalarsWithIDOrderByInput {
  id_ASC
  id_DESC
  int_ASC
  int_DESC
  string_ASC
  string_DESC
  float_ASC
  float_DESC
  dateTime_ASC
  dateTime_DESC
  json_ASC
  json_DESC
  boolean_ASC
  boolean_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LotsOfScalarsWithIDPreviousValues {
  id: ID!
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

type LotsOfScalarsWithIDSubscriptionPayload {
  mutation: MutationType!
  node: LotsOfScalarsWithID
  updatedFields: [String!]
  previousValues: LotsOfScalarsWithIDPreviousValues
}

input LotsOfScalarsWithIDSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LotsOfScalarsWithIDWhereInput
  AND: [LotsOfScalarsWithIDSubscriptionWhereInput!]
  OR: [LotsOfScalarsWithIDSubscriptionWhereInput!]
  NOT: [LotsOfScalarsWithIDSubscriptionWhereInput!]
}

input LotsOfScalarsWithIDUpdateInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

input LotsOfScalarsWithIDUpdateManyMutationInput {
  int: Int
  string: String
  float: Float
  dateTime: DateTime
  json: Json
  boolean: Boolean
}

input LotsOfScalarsWithIDWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  int: Int
  int_not: Int
  int_in: [Int!]
  int_not_in: [Int!]
  int_lt: Int
  int_lte: Int
  int_gt: Int
  int_gte: Int
  string: String
  string_not: String
  string_in: [String!]
  string_not_in: [String!]
  string_lt: String
  string_lte: String
  string_gt: String
  string_gte: String
  string_contains: String
  string_not_contains: String
  string_starts_with: String
  string_not_starts_with: String
  string_ends_with: String
  string_not_ends_with: String
  float: Float
  float_not: Float
  float_in: [Float!]
  float_not_in: [Float!]
  float_lt: Float
  float_lte: Float
  float_gt: Float
  float_gte: Float
  dateTime: DateTime
  dateTime_not: DateTime
  dateTime_in: [DateTime!]
  dateTime_not_in: [DateTime!]
  dateTime_lt: DateTime
  dateTime_lte: DateTime
  dateTime_gt: DateTime
  dateTime_gte: DateTime
  boolean: Boolean
  boolean_not: Boolean
  AND: [LotsOfScalarsWithIDWhereInput!]
  OR: [LotsOfScalarsWithIDWhereInput!]
  NOT: [LotsOfScalarsWithIDWhereInput!]
}

input LotsOfScalarsWithIDWhereUniqueInput {
  id: ID
}

type Mutation {
  createLotsOfScalars(data: LotsOfScalarsCreateInput!): LotsOfScalars!
  updateManyLotsOfScalarses(data: LotsOfScalarsUpdateManyMutationInput!, where: LotsOfScalarsWhereInput): BatchPayload!
  deleteManyLotsOfScalarses(where: LotsOfScalarsWhereInput): BatchPayload!
  createLotsOfRequiredScalars(data: LotsOfRequiredScalarsCreateInput!): LotsOfRequiredScalars!
  updateManyLotsOfRequiredScalarses(data: LotsOfRequiredScalarsUpdateManyMutationInput!, where: LotsOfRequiredScalarsWhereInput): BatchPayload!
  deleteManyLotsOfRequiredScalarses(where: LotsOfRequiredScalarsWhereInput): BatchPayload!
  createLotsOfScalarLists(data: LotsOfScalarListsCreateInput!): LotsOfScalarLists!
  updateManyLotsOfScalarListses(data: LotsOfScalarListsUpdateManyMutationInput!, where: LotsOfScalarListsWhereInput): BatchPayload!
  deleteManyLotsOfScalarListses(where: LotsOfScalarListsWhereInput): BatchPayload!
  createLotsOfScalarsWithID(data: LotsOfScalarsWithIDCreateInput!): LotsOfScalarsWithID!
  updateLotsOfScalarsWithID(data: LotsOfScalarsWithIDUpdateInput!, where: LotsOfScalarsWithIDWhereUniqueInput!): LotsOfScalarsWithID
  updateManyLotsOfScalarsWithIDs(data: LotsOfScalarsWithIDUpdateManyMutationInput!, where: LotsOfScalarsWithIDWhereInput): BatchPayload!
  upsertLotsOfScalarsWithID(where: LotsOfScalarsWithIDWhereUniqueInput!, create: LotsOfScalarsWithIDCreateInput!, update: LotsOfScalarsWithIDUpdateInput!): LotsOfScalarsWithID!
  deleteLotsOfScalarsWithID(where: LotsOfScalarsWithIDWhereUniqueInput!): LotsOfScalarsWithID
  deleteManyLotsOfScalarsWithIDs(where: LotsOfScalarsWithIDWhereInput): BatchPayload!
  createLotsOfRequiredScalarsWithID(data: LotsOfRequiredScalarsWithIDCreateInput!): LotsOfRequiredScalarsWithID!
  updateLotsOfRequiredScalarsWithID(data: LotsOfRequiredScalarsWithIDUpdateInput!, where: LotsOfRequiredScalarsWithIDWhereUniqueInput!): LotsOfRequiredScalarsWithID
  updateManyLotsOfRequiredScalarsWithIDs(data: LotsOfRequiredScalarsWithIDUpdateManyMutationInput!, where: LotsOfRequiredScalarsWithIDWhereInput): BatchPayload!
  upsertLotsOfRequiredScalarsWithID(where: LotsOfRequiredScalarsWithIDWhereUniqueInput!, create: LotsOfRequiredScalarsWithIDCreateInput!, update: LotsOfRequiredScalarsWithIDUpdateInput!): LotsOfRequiredScalarsWithID!
  deleteLotsOfRequiredScalarsWithID(where: LotsOfRequiredScalarsWithIDWhereUniqueInput!): LotsOfRequiredScalarsWithID
  deleteManyLotsOfRequiredScalarsWithIDs(where: LotsOfRequiredScalarsWithIDWhereInput): BatchPayload!
  createLotsOfScalarListsWithID(data: LotsOfScalarListsWithIDCreateInput!): LotsOfScalarListsWithID!
  updateLotsOfScalarListsWithID(data: LotsOfScalarListsWithIDUpdateInput!, where: LotsOfScalarListsWithIDWhereUniqueInput!): LotsOfScalarListsWithID
  updateManyLotsOfScalarListsWithIDs(data: LotsOfScalarListsWithIDUpdateManyMutationInput!, where: LotsOfScalarListsWithIDWhereInput): BatchPayload!
  upsertLotsOfScalarListsWithID(where: LotsOfScalarListsWithIDWhereUniqueInput!, create: LotsOfScalarListsWithIDCreateInput!, update: LotsOfScalarListsWithIDUpdateInput!): LotsOfScalarListsWithID!
  deleteLotsOfScalarListsWithID(where: LotsOfScalarListsWithIDWhereUniqueInput!): LotsOfScalarListsWithID
  deleteManyLotsOfScalarListsWithIDs(where: LotsOfScalarListsWithIDWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  lotsOfScalarses(where: LotsOfScalarsWhereInput, orderBy: LotsOfScalarsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LotsOfScalars]!
  lotsOfScalarsesConnection(where: LotsOfScalarsWhereInput, orderBy: LotsOfScalarsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LotsOfScalarsConnection!
  lotsOfRequiredScalarses(where: LotsOfRequiredScalarsWhereInput, orderBy: LotsOfRequiredScalarsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LotsOfRequiredScalars]!
  lotsOfRequiredScalarsesConnection(where: LotsOfRequiredScalarsWhereInput, orderBy: LotsOfRequiredScalarsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LotsOfRequiredScalarsConnection!
  lotsOfScalarListses(where: LotsOfScalarListsWhereInput, orderBy: LotsOfScalarListsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LotsOfScalarLists]!
  lotsOfScalarListsesConnection(where: LotsOfScalarListsWhereInput, orderBy: LotsOfScalarListsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LotsOfScalarListsConnection!
  lotsOfScalarsWithID(where: LotsOfScalarsWithIDWhereUniqueInput!): LotsOfScalarsWithID
  lotsOfScalarsWithIDs(where: LotsOfScalarsWithIDWhereInput, orderBy: LotsOfScalarsWithIDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LotsOfScalarsWithID]!
  lotsOfScalarsWithIDsConnection(where: LotsOfScalarsWithIDWhereInput, orderBy: LotsOfScalarsWithIDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LotsOfScalarsWithIDConnection!
  lotsOfRequiredScalarsWithID(where: LotsOfRequiredScalarsWithIDWhereUniqueInput!): LotsOfRequiredScalarsWithID
  lotsOfRequiredScalarsWithIDs(where: LotsOfRequiredScalarsWithIDWhereInput, orderBy: LotsOfRequiredScalarsWithIDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LotsOfRequiredScalarsWithID]!
  lotsOfRequiredScalarsWithIDsConnection(where: LotsOfRequiredScalarsWithIDWhereInput, orderBy: LotsOfRequiredScalarsWithIDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LotsOfRequiredScalarsWithIDConnection!
  lotsOfScalarListsWithID(where: LotsOfScalarListsWithIDWhereUniqueInput!): LotsOfScalarListsWithID
  lotsOfScalarListsWithIDs(where: LotsOfScalarListsWithIDWhereInput, orderBy: LotsOfScalarListsWithIDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LotsOfScalarListsWithID]!
  lotsOfScalarListsWithIDsConnection(where: LotsOfScalarListsWithIDWhereInput, orderBy: LotsOfScalarListsWithIDOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LotsOfScalarListsWithIDConnection!
  node(id: ID!): Node
}

type Subscription {
  lotsOfScalars(where: LotsOfScalarsSubscriptionWhereInput): LotsOfScalarsSubscriptionPayload
  lotsOfRequiredScalars(where: LotsOfRequiredScalarsSubscriptionWhereInput): LotsOfRequiredScalarsSubscriptionPayload
  lotsOfScalarLists(where: LotsOfScalarListsSubscriptionWhereInput): LotsOfScalarListsSubscriptionPayload
  lotsOfScalarsWithID(where: LotsOfScalarsWithIDSubscriptionWhereInput): LotsOfScalarsWithIDSubscriptionPayload
  lotsOfRequiredScalarsWithID(where: LotsOfRequiredScalarsWithIDSubscriptionWhereInput): LotsOfRequiredScalarsWithIDSubscriptionPayload
  lotsOfScalarListsWithID(where: LotsOfScalarListsWithIDSubscriptionWhereInput): LotsOfScalarListsWithIDSubscriptionPayload
}
