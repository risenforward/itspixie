type AggregateAWithA {
  count: Int!
}

type AggregateAWithB {
  count: Int!
}

type AggregateAWithC {
  count: Int!
}

type AggregateAWithIdWithA {
  count: Int!
}

type AggregateAWithIdWithB {
  count: Int!
}

type AggregateAWithIdWithC {
  count: Int!
}

type AggregateAWithoutIdWithA {
  count: Int!
}

type AggregateAWithoutIdWithB {
  count: Int!
}

type AggregateAWithoutIdWithC {
  count: Int!
}

type AggregateBWithA {
  count: Int!
}

type AggregateBWithB {
  count: Int!
}

type AggregateBWithC {
  count: Int!
}

type AggregateBWithIdWithA {
  count: Int!
}

type AggregateBWithIdWithB {
  count: Int!
}

type AggregateBWithIdWithC {
  count: Int!
}

type AggregateBWithoutIdWithA {
  count: Int!
}

type AggregateBWithoutIdWithB {
  count: Int!
}

type AggregateBWithoutIdWithC {
  count: Int!
}

type AggregateCWithA {
  count: Int!
}

type AggregateCWithB {
  count: Int!
}

type AggregateCWithC {
  count: Int!
}

type AggregateCWithIdWithA {
  count: Int!
}

type AggregateCWithIdWithB {
  count: Int!
}

type AggregateCWithIdWithC {
  count: Int!
}

type AggregateCWithoutIdWithA {
  count: Int!
}

type AggregateCWithoutIdWithB {
  count: Int!
}

type AggregateCWithoutIdWithC {
  count: Int!
}

type AWithA {
  x: AWithIdWithA!
  y: AWithoutIdWithA!
}

type AWithAConnection {
  pageInfo: PageInfo!
  edges: [AWithAEdge]!
  aggregate: AggregateAWithA!
}

input AWithACreateInput {
  x: AWithIdWithACreateOneWithoutXInput!
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateOneWithoutXInput {
  create: AWithACreateWithoutXInput
}

input AWithACreateOneWithoutYInput {
  create: AWithACreateWithoutYInput
}

input AWithACreateWithoutXInput {
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateWithoutYInput {
  x: AWithIdWithACreateOneWithoutXInput!
}

type AWithAEdge {
  node: AWithA!
  cursor: String!
}

enum AWithAOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithA
  updatedFields: [String!]
}

input AWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithAWhereInput
  AND: [AWithASubscriptionWhereInput!]
  OR: [AWithASubscriptionWhereInput!]
  NOT: [AWithASubscriptionWhereInput!]
}

input AWithAUpdateOneRequiredWithoutXInput {
  create: AWithACreateWithoutXInput
  update: AWithAUpdateWithoutXDataInput
  upsert: AWithAUpsertWithoutXInput
}

input AWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithAUpsertWithoutXInput {
  update: AWithAUpdateWithoutXDataInput!
  create: AWithACreateWithoutXInput!
}

input AWithAWhereInput {
  x: AWithIdWithAWhereInput
  y: AWithoutIdWithAWhereInput
  AND: [AWithAWhereInput!]
  OR: [AWithAWhereInput!]
  NOT: [AWithAWhereInput!]
}

type AWithB {
  x: BWithIdWithA!
  y: BWithoutIdWithA!
}

type AWithBConnection {
  pageInfo: PageInfo!
  edges: [AWithBEdge]!
  aggregate: AggregateAWithB!
}

input AWithBCreateInput {
  x: BWithIdWithACreateOneWithoutXInput!
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
}

input AWithBCreateOneWithoutYInput {
  create: AWithBCreateWithoutYInput
}

input AWithBCreateWithoutXInput {
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateWithoutYInput {
  x: BWithIdWithACreateOneWithoutXInput!
}

type AWithBEdge {
  node: AWithB!
  cursor: String!
}

enum AWithBOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithB
  updatedFields: [String!]
}

input AWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithBWhereInput
  AND: [AWithBSubscriptionWhereInput!]
  OR: [AWithBSubscriptionWhereInput!]
  NOT: [AWithBSubscriptionWhereInput!]
}

input AWithBUpdateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
  update: AWithBUpdateWithoutXDataInput
  upsert: AWithBUpsertWithoutXInput
  delete: Boolean
  disconnect: Boolean
}

input AWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithBUpsertWithoutXInput {
  update: AWithBUpdateWithoutXDataInput!
  create: AWithBCreateWithoutXInput!
}

input AWithBWhereInput {
  x: BWithIdWithAWhereInput
  y: BWithoutIdWithAWhereInput
  AND: [AWithBWhereInput!]
  OR: [AWithBWhereInput!]
  NOT: [AWithBWhereInput!]
}

type AWithC {
  x: CWithIdWithA!
  y: CWithoutIdWithA!
}

type AWithCConnection {
  pageInfo: PageInfo!
  edges: [AWithCEdge]!
  aggregate: AggregateAWithC!
}

input AWithCCreateInput {
  x: CWithIdWithACreateOneWithoutXInput!
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
}

input AWithCCreateManyWithoutYInput {
  create: [AWithCCreateWithoutYInput!]
}

input AWithCCreateWithoutXInput {
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateWithoutYInput {
  x: CWithIdWithACreateOneWithoutXInput!
}

type AWithCEdge {
  node: AWithC!
  cursor: String!
}

enum AWithCOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithC
  updatedFields: [String!]
}

input AWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithCWhereInput
  AND: [AWithCSubscriptionWhereInput!]
  OR: [AWithCSubscriptionWhereInput!]
  NOT: [AWithCSubscriptionWhereInput!]
}

input AWithCUpdateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
}

input AWithCWhereInput {
  x: CWithIdWithAWhereInput
  y: CWithoutIdWithAWhereInput
  AND: [AWithCWhereInput!]
  OR: [AWithCWhereInput!]
  NOT: [AWithCWhereInput!]
}

type AWithIdWithA {
  id: ID!
  field: String!
  x: AWithA!
}

type AWithIdWithAConnection {
  pageInfo: PageInfo!
  edges: [AWithIdWithAEdge]!
  aggregate: AggregateAWithIdWithA!
}

input AWithIdWithACreateInput {
  field: String!
  x: AWithACreateOneWithoutXInput!
}

input AWithIdWithACreateOneWithoutXInput {
  create: AWithIdWithACreateWithoutXInput
  connect: AWithIdWithAWhereUniqueInput
}

input AWithIdWithACreateWithoutXInput {
  field: String!
}

type AWithIdWithAEdge {
  node: AWithIdWithA!
  cursor: String!
}

enum AWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithA
  updatedFields: [String!]
  previousValues: AWithIdWithAPreviousValues
}

input AWithIdWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithIdWithAWhereInput
  AND: [AWithIdWithASubscriptionWhereInput!]
  OR: [AWithIdWithASubscriptionWhereInput!]
  NOT: [AWithIdWithASubscriptionWhereInput!]
}

input AWithIdWithAUpdateInput {
  field: String
  x: AWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithAUpdateManyMutationInput {
  field: String
}

input AWithIdWithAWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: AWithAWhereInput
  AND: [AWithIdWithAWhereInput!]
  OR: [AWithIdWithAWhereInput!]
  NOT: [AWithIdWithAWhereInput!]
}

input AWithIdWithAWhereUniqueInput {
  id: ID
}

type AWithIdWithB {
  id: ID!
  field: String!
  x: BWithA!
}

type AWithIdWithBConnection {
  pageInfo: PageInfo!
  edges: [AWithIdWithBEdge]!
  aggregate: AggregateAWithIdWithB!
}

input AWithIdWithBCreateInput {
  field: String!
  x: BWithACreateOneWithoutXInput!
}

input AWithIdWithBCreateOneWithoutXInput {
  create: AWithIdWithBCreateWithoutXInput
  connect: AWithIdWithBWhereUniqueInput
}

input AWithIdWithBCreateWithoutXInput {
  field: String!
}

type AWithIdWithBEdge {
  node: AWithIdWithB!
  cursor: String!
}

enum AWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithB
  updatedFields: [String!]
  previousValues: AWithIdWithBPreviousValues
}

input AWithIdWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithIdWithBWhereInput
  AND: [AWithIdWithBSubscriptionWhereInput!]
  OR: [AWithIdWithBSubscriptionWhereInput!]
  NOT: [AWithIdWithBSubscriptionWhereInput!]
}

input AWithIdWithBUpdateInput {
  field: String
  x: BWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithBUpdateManyMutationInput {
  field: String
}

input AWithIdWithBWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: BWithAWhereInput
  AND: [AWithIdWithBWhereInput!]
  OR: [AWithIdWithBWhereInput!]
  NOT: [AWithIdWithBWhereInput!]
}

input AWithIdWithBWhereUniqueInput {
  id: ID
}

type AWithIdWithC {
  id: ID!
  field: String!
  x: CWithA!
}

type AWithIdWithCConnection {
  pageInfo: PageInfo!
  edges: [AWithIdWithCEdge]!
  aggregate: AggregateAWithIdWithC!
}

input AWithIdWithCCreateInput {
  field: String!
  x: CWithACreateOneWithoutXInput!
}

input AWithIdWithCCreateManyWithoutXInput {
  create: [AWithIdWithCCreateWithoutXInput!]
  connect: [AWithIdWithCWhereUniqueInput!]
}

input AWithIdWithCCreateWithoutXInput {
  field: String!
}

type AWithIdWithCEdge {
  node: AWithIdWithC!
  cursor: String!
}

enum AWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithC
  updatedFields: [String!]
  previousValues: AWithIdWithCPreviousValues
}

input AWithIdWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithIdWithCWhereInput
  AND: [AWithIdWithCSubscriptionWhereInput!]
  OR: [AWithIdWithCSubscriptionWhereInput!]
  NOT: [AWithIdWithCSubscriptionWhereInput!]
}

input AWithIdWithCUpdateInput {
  field: String
  x: CWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithCUpdateManyMutationInput {
  field: String
}

input AWithIdWithCWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: CWithAWhereInput
  AND: [AWithIdWithCWhereInput!]
  OR: [AWithIdWithCWhereInput!]
  NOT: [AWithIdWithCWhereInput!]
}

input AWithIdWithCWhereUniqueInput {
  id: ID
}

type AWithoutIdWithA {
  field: String!
  x: AWithA!
}

type AWithoutIdWithAConnection {
  pageInfo: PageInfo!
  edges: [AWithoutIdWithAEdge]!
  aggregate: AggregateAWithoutIdWithA!
}

input AWithoutIdWithACreateInput {
  field: String!
  x: AWithACreateOneWithoutYInput!
}

input AWithoutIdWithACreateOneWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
}

input AWithoutIdWithACreateWithoutXInput {
  field: String!
}

type AWithoutIdWithAEdge {
  node: AWithoutIdWithA!
  cursor: String!
}

enum AWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithoutIdWithAPreviousValues {
  field: String!
}

type AWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithA
  updatedFields: [String!]
  previousValues: AWithoutIdWithAPreviousValues
}

input AWithoutIdWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithAWhereInput
  AND: [AWithoutIdWithASubscriptionWhereInput!]
  OR: [AWithoutIdWithASubscriptionWhereInput!]
  NOT: [AWithoutIdWithASubscriptionWhereInput!]
}

input AWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
  update: AWithoutIdWithAUpdateWithoutXDataInput
  upsert: AWithoutIdWithAUpsertWithoutXInput
}

input AWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithAUpsertWithoutXInput {
  update: AWithoutIdWithAUpdateWithoutXDataInput!
  create: AWithoutIdWithACreateWithoutXInput!
}

input AWithoutIdWithAWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: AWithAWhereInput
  AND: [AWithoutIdWithAWhereInput!]
  OR: [AWithoutIdWithAWhereInput!]
  NOT: [AWithoutIdWithAWhereInput!]
}

type AWithoutIdWithB {
  field: String!
  x: BWithA!
}

type AWithoutIdWithBConnection {
  pageInfo: PageInfo!
  edges: [AWithoutIdWithBEdge]!
  aggregate: AggregateAWithoutIdWithB!
}

input AWithoutIdWithBCreateInput {
  field: String!
  x: BWithACreateOneWithoutYInput!
}

input AWithoutIdWithBCreateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
}

input AWithoutIdWithBCreateWithoutXInput {
  field: String!
}

type AWithoutIdWithBEdge {
  node: AWithoutIdWithB!
  cursor: String!
}

enum AWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithoutIdWithBPreviousValues {
  field: String!
}

type AWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithB
  updatedFields: [String!]
  previousValues: AWithoutIdWithBPreviousValues
}

input AWithoutIdWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithBWhereInput
  AND: [AWithoutIdWithBSubscriptionWhereInput!]
  OR: [AWithoutIdWithBSubscriptionWhereInput!]
  NOT: [AWithoutIdWithBSubscriptionWhereInput!]
}

input AWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithBUpdateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
  update: AWithoutIdWithBUpdateWithoutXDataInput
  upsert: AWithoutIdWithBUpsertWithoutXInput
  delete: Boolean
  disconnect: Boolean
}

input AWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithBUpsertWithoutXInput {
  update: AWithoutIdWithBUpdateWithoutXDataInput!
  create: AWithoutIdWithBCreateWithoutXInput!
}

input AWithoutIdWithBWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: BWithAWhereInput
  AND: [AWithoutIdWithBWhereInput!]
  OR: [AWithoutIdWithBWhereInput!]
  NOT: [AWithoutIdWithBWhereInput!]
}

type AWithoutIdWithC {
  field: String!
  x: CWithA!
}

type AWithoutIdWithCConnection {
  pageInfo: PageInfo!
  edges: [AWithoutIdWithCEdge]!
  aggregate: AggregateAWithoutIdWithC!
}

input AWithoutIdWithCCreateInput {
  field: String!
  x: CWithACreateOneWithoutYInput!
}

input AWithoutIdWithCCreateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
}

input AWithoutIdWithCCreateWithoutXInput {
  field: String!
}

type AWithoutIdWithCEdge {
  node: AWithoutIdWithC!
  cursor: String!
}

enum AWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AWithoutIdWithCPreviousValues {
  field: String!
}

input AWithoutIdWithCScalarWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  AND: [AWithoutIdWithCScalarWhereInput!]
  OR: [AWithoutIdWithCScalarWhereInput!]
  NOT: [AWithoutIdWithCScalarWhereInput!]
}

type AWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithC
  updatedFields: [String!]
  previousValues: AWithoutIdWithCPreviousValues
}

input AWithoutIdWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithCWhereInput
  AND: [AWithoutIdWithCSubscriptionWhereInput!]
  OR: [AWithoutIdWithCSubscriptionWhereInput!]
  NOT: [AWithoutIdWithCSubscriptionWhereInput!]
}

input AWithoutIdWithCUpdateManyDataInput {
  field: String
}

input AWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithCUpdateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
  deleteMany: [AWithoutIdWithCScalarWhereInput!]
  updateMany: [AWithoutIdWithCUpdateManyWithWhereNestedInput!]
}

input AWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: AWithoutIdWithCScalarWhereInput!
  data: AWithoutIdWithCUpdateManyDataInput!
}

input AWithoutIdWithCWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: CWithAWhereInput
  AND: [AWithoutIdWithCWhereInput!]
  OR: [AWithoutIdWithCWhereInput!]
  NOT: [AWithoutIdWithCWhereInput!]
}

type BatchPayload {
  count: Long!
}

type BWithA {
  x: AWithIdWithB
  y: AWithoutIdWithB
}

type BWithAConnection {
  pageInfo: PageInfo!
  edges: [BWithAEdge]!
  aggregate: AggregateBWithA!
}

input BWithACreateInput {
  x: AWithIdWithBCreateOneWithoutXInput
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateOneWithoutXInput {
  create: BWithACreateWithoutXInput
}

input BWithACreateOneWithoutYInput {
  create: BWithACreateWithoutYInput
}

input BWithACreateWithoutXInput {
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateWithoutYInput {
  x: AWithIdWithBCreateOneWithoutXInput
}

type BWithAEdge {
  node: BWithA!
  cursor: String!
}

enum BWithAOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithA
  updatedFields: [String!]
}

input BWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithAWhereInput
  AND: [BWithASubscriptionWhereInput!]
  OR: [BWithASubscriptionWhereInput!]
  NOT: [BWithASubscriptionWhereInput!]
}

input BWithAUpdateOneRequiredWithoutXInput {
  create: BWithACreateWithoutXInput
  update: BWithAUpdateWithoutXDataInput
  upsert: BWithAUpsertWithoutXInput
}

input BWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithBUpdateOneWithoutXInput
}

input BWithAUpsertWithoutXInput {
  update: BWithAUpdateWithoutXDataInput!
  create: BWithACreateWithoutXInput!
}

input BWithAWhereInput {
  x: AWithIdWithBWhereInput
  y: AWithoutIdWithBWhereInput
  AND: [BWithAWhereInput!]
  OR: [BWithAWhereInput!]
  NOT: [BWithAWhereInput!]
}

type BWithB {
  x: BWithIdWithB
  y: BWithoutIdWithB
}

type BWithBConnection {
  pageInfo: PageInfo!
  edges: [BWithBEdge]!
  aggregate: AggregateBWithB!
}

input BWithBCreateInput {
  x: BWithIdWithBCreateOneWithoutXInput
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
}

input BWithBCreateOneWithoutYInput {
  create: BWithBCreateWithoutYInput
}

input BWithBCreateWithoutXInput {
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateWithoutYInput {
  x: BWithIdWithBCreateOneWithoutXInput
}

type BWithBEdge {
  node: BWithB!
  cursor: String!
}

enum BWithBOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithB
  updatedFields: [String!]
}

input BWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithBWhereInput
  AND: [BWithBSubscriptionWhereInput!]
  OR: [BWithBSubscriptionWhereInput!]
  NOT: [BWithBSubscriptionWhereInput!]
}

input BWithBUpdateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
  update: BWithBUpdateWithoutXDataInput
  upsert: BWithBUpsertWithoutXInput
  delete: Boolean
  disconnect: Boolean
}

input BWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithBUpdateOneWithoutXInput
}

input BWithBUpsertWithoutXInput {
  update: BWithBUpdateWithoutXDataInput!
  create: BWithBCreateWithoutXInput!
}

input BWithBWhereInput {
  x: BWithIdWithBWhereInput
  y: BWithoutIdWithBWhereInput
  AND: [BWithBWhereInput!]
  OR: [BWithBWhereInput!]
  NOT: [BWithBWhereInput!]
}

type BWithC {
  x: CWithIdWithB
  y: CWithoutIdWithB
}

type BWithCConnection {
  pageInfo: PageInfo!
  edges: [BWithCEdge]!
  aggregate: AggregateBWithC!
}

input BWithCCreateInput {
  x: CWithIdWithBCreateOneWithoutXInput
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
}

input BWithCCreateManyWithoutYInput {
  create: [BWithCCreateWithoutYInput!]
}

input BWithCCreateWithoutXInput {
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateWithoutYInput {
  x: CWithIdWithBCreateOneWithoutXInput
}

type BWithCEdge {
  node: BWithC!
  cursor: String!
}

enum BWithCOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithC
  updatedFields: [String!]
}

input BWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithCWhereInput
  AND: [BWithCSubscriptionWhereInput!]
  OR: [BWithCSubscriptionWhereInput!]
  NOT: [BWithCSubscriptionWhereInput!]
}

input BWithCUpdateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
}

input BWithCWhereInput {
  x: CWithIdWithBWhereInput
  y: CWithoutIdWithBWhereInput
  AND: [BWithCWhereInput!]
  OR: [BWithCWhereInput!]
  NOT: [BWithCWhereInput!]
}

type BWithIdWithA {
  id: ID!
  field: String!
  x: AWithB
}

type BWithIdWithAConnection {
  pageInfo: PageInfo!
  edges: [BWithIdWithAEdge]!
  aggregate: AggregateBWithIdWithA!
}

input BWithIdWithACreateInput {
  field: String!
  x: AWithBCreateOneWithoutXInput
}

input BWithIdWithACreateOneWithoutXInput {
  create: BWithIdWithACreateWithoutXInput
  connect: BWithIdWithAWhereUniqueInput
}

input BWithIdWithACreateWithoutXInput {
  field: String!
}

type BWithIdWithAEdge {
  node: BWithIdWithA!
  cursor: String!
}

enum BWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithA
  updatedFields: [String!]
  previousValues: BWithIdWithAPreviousValues
}

input BWithIdWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithIdWithAWhereInput
  AND: [BWithIdWithASubscriptionWhereInput!]
  OR: [BWithIdWithASubscriptionWhereInput!]
  NOT: [BWithIdWithASubscriptionWhereInput!]
}

input BWithIdWithAUpdateInput {
  field: String
  x: AWithBUpdateOneWithoutXInput
}

input BWithIdWithAUpdateManyMutationInput {
  field: String
}

input BWithIdWithAWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: AWithBWhereInput
  AND: [BWithIdWithAWhereInput!]
  OR: [BWithIdWithAWhereInput!]
  NOT: [BWithIdWithAWhereInput!]
}

input BWithIdWithAWhereUniqueInput {
  id: ID
}

type BWithIdWithB {
  id: ID!
  field: String!
  x: BWithB
}

type BWithIdWithBConnection {
  pageInfo: PageInfo!
  edges: [BWithIdWithBEdge]!
  aggregate: AggregateBWithIdWithB!
}

input BWithIdWithBCreateInput {
  field: String!
  x: BWithBCreateOneWithoutXInput
}

input BWithIdWithBCreateOneWithoutXInput {
  create: BWithIdWithBCreateWithoutXInput
  connect: BWithIdWithBWhereUniqueInput
}

input BWithIdWithBCreateWithoutXInput {
  field: String!
}

type BWithIdWithBEdge {
  node: BWithIdWithB!
  cursor: String!
}

enum BWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithB
  updatedFields: [String!]
  previousValues: BWithIdWithBPreviousValues
}

input BWithIdWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithIdWithBWhereInput
  AND: [BWithIdWithBSubscriptionWhereInput!]
  OR: [BWithIdWithBSubscriptionWhereInput!]
  NOT: [BWithIdWithBSubscriptionWhereInput!]
}

input BWithIdWithBUpdateInput {
  field: String
  x: BWithBUpdateOneWithoutXInput
}

input BWithIdWithBUpdateManyMutationInput {
  field: String
}

input BWithIdWithBWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: BWithBWhereInput
  AND: [BWithIdWithBWhereInput!]
  OR: [BWithIdWithBWhereInput!]
  NOT: [BWithIdWithBWhereInput!]
}

input BWithIdWithBWhereUniqueInput {
  id: ID
}

type BWithIdWithC {
  id: ID!
  field: String!
  x: CWithB
}

type BWithIdWithCConnection {
  pageInfo: PageInfo!
  edges: [BWithIdWithCEdge]!
  aggregate: AggregateBWithIdWithC!
}

input BWithIdWithCCreateInput {
  field: String!
  x: CWithBCreateOneWithoutXInput
}

input BWithIdWithCCreateManyWithoutXInput {
  create: [BWithIdWithCCreateWithoutXInput!]
  connect: [BWithIdWithCWhereUniqueInput!]
}

input BWithIdWithCCreateWithoutXInput {
  field: String!
}

type BWithIdWithCEdge {
  node: BWithIdWithC!
  cursor: String!
}

enum BWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithC
  updatedFields: [String!]
  previousValues: BWithIdWithCPreviousValues
}

input BWithIdWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithIdWithCWhereInput
  AND: [BWithIdWithCSubscriptionWhereInput!]
  OR: [BWithIdWithCSubscriptionWhereInput!]
  NOT: [BWithIdWithCSubscriptionWhereInput!]
}

input BWithIdWithCUpdateInput {
  field: String
  x: CWithBUpdateOneWithoutXInput
}

input BWithIdWithCUpdateManyMutationInput {
  field: String
}

input BWithIdWithCWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: CWithBWhereInput
  AND: [BWithIdWithCWhereInput!]
  OR: [BWithIdWithCWhereInput!]
  NOT: [BWithIdWithCWhereInput!]
}

input BWithIdWithCWhereUniqueInput {
  id: ID
}

type BWithoutIdWithA {
  field: String!
  x: AWithB
}

type BWithoutIdWithAConnection {
  pageInfo: PageInfo!
  edges: [BWithoutIdWithAEdge]!
  aggregate: AggregateBWithoutIdWithA!
}

input BWithoutIdWithACreateInput {
  field: String!
  x: AWithBCreateOneWithoutYInput
}

input BWithoutIdWithACreateOneWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
}

input BWithoutIdWithACreateWithoutXInput {
  field: String!
}

type BWithoutIdWithAEdge {
  node: BWithoutIdWithA!
  cursor: String!
}

enum BWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithoutIdWithAPreviousValues {
  field: String!
}

type BWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithA
  updatedFields: [String!]
  previousValues: BWithoutIdWithAPreviousValues
}

input BWithoutIdWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithAWhereInput
  AND: [BWithoutIdWithASubscriptionWhereInput!]
  OR: [BWithoutIdWithASubscriptionWhereInput!]
  NOT: [BWithoutIdWithASubscriptionWhereInput!]
}

input BWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
  update: BWithoutIdWithAUpdateWithoutXDataInput
  upsert: BWithoutIdWithAUpsertWithoutXInput
}

input BWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithAUpsertWithoutXInput {
  update: BWithoutIdWithAUpdateWithoutXDataInput!
  create: BWithoutIdWithACreateWithoutXInput!
}

input BWithoutIdWithAWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: AWithBWhereInput
  AND: [BWithoutIdWithAWhereInput!]
  OR: [BWithoutIdWithAWhereInput!]
  NOT: [BWithoutIdWithAWhereInput!]
}

type BWithoutIdWithB {
  field: String!
  x: BWithB
}

type BWithoutIdWithBConnection {
  pageInfo: PageInfo!
  edges: [BWithoutIdWithBEdge]!
  aggregate: AggregateBWithoutIdWithB!
}

input BWithoutIdWithBCreateInput {
  field: String!
  x: BWithBCreateOneWithoutYInput
}

input BWithoutIdWithBCreateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
}

input BWithoutIdWithBCreateWithoutXInput {
  field: String!
}

type BWithoutIdWithBEdge {
  node: BWithoutIdWithB!
  cursor: String!
}

enum BWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithoutIdWithBPreviousValues {
  field: String!
}

type BWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithB
  updatedFields: [String!]
  previousValues: BWithoutIdWithBPreviousValues
}

input BWithoutIdWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithBWhereInput
  AND: [BWithoutIdWithBSubscriptionWhereInput!]
  OR: [BWithoutIdWithBSubscriptionWhereInput!]
  NOT: [BWithoutIdWithBSubscriptionWhereInput!]
}

input BWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithBUpdateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
  update: BWithoutIdWithBUpdateWithoutXDataInput
  upsert: BWithoutIdWithBUpsertWithoutXInput
  delete: Boolean
  disconnect: Boolean
}

input BWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithBUpsertWithoutXInput {
  update: BWithoutIdWithBUpdateWithoutXDataInput!
  create: BWithoutIdWithBCreateWithoutXInput!
}

input BWithoutIdWithBWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: BWithBWhereInput
  AND: [BWithoutIdWithBWhereInput!]
  OR: [BWithoutIdWithBWhereInput!]
  NOT: [BWithoutIdWithBWhereInput!]
}

type BWithoutIdWithC {
  field: String!
  x: CWithB
}

type BWithoutIdWithCConnection {
  pageInfo: PageInfo!
  edges: [BWithoutIdWithCEdge]!
  aggregate: AggregateBWithoutIdWithC!
}

input BWithoutIdWithCCreateInput {
  field: String!
  x: CWithBCreateOneWithoutYInput
}

input BWithoutIdWithCCreateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
}

input BWithoutIdWithCCreateWithoutXInput {
  field: String!
}

type BWithoutIdWithCEdge {
  node: BWithoutIdWithC!
  cursor: String!
}

enum BWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BWithoutIdWithCPreviousValues {
  field: String!
}

input BWithoutIdWithCScalarWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  AND: [BWithoutIdWithCScalarWhereInput!]
  OR: [BWithoutIdWithCScalarWhereInput!]
  NOT: [BWithoutIdWithCScalarWhereInput!]
}

type BWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithC
  updatedFields: [String!]
  previousValues: BWithoutIdWithCPreviousValues
}

input BWithoutIdWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithCWhereInput
  AND: [BWithoutIdWithCSubscriptionWhereInput!]
  OR: [BWithoutIdWithCSubscriptionWhereInput!]
  NOT: [BWithoutIdWithCSubscriptionWhereInput!]
}

input BWithoutIdWithCUpdateManyDataInput {
  field: String
}

input BWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithCUpdateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
  deleteMany: [BWithoutIdWithCScalarWhereInput!]
  updateMany: [BWithoutIdWithCUpdateManyWithWhereNestedInput!]
}

input BWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: BWithoutIdWithCScalarWhereInput!
  data: BWithoutIdWithCUpdateManyDataInput!
}

input BWithoutIdWithCWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x: CWithBWhereInput
  AND: [BWithoutIdWithCWhereInput!]
  OR: [BWithoutIdWithCWhereInput!]
  NOT: [BWithoutIdWithCWhereInput!]
}

type CWithA {
  x(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC!]
  y(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC!]
}

type CWithAConnection {
  pageInfo: PageInfo!
  edges: [CWithAEdge]!
  aggregate: AggregateCWithA!
}

input CWithACreateInput {
  x: AWithIdWithCCreateManyWithoutXInput
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateOneWithoutXInput {
  create: CWithACreateWithoutXInput
}

input CWithACreateOneWithoutYInput {
  create: CWithACreateWithoutYInput
}

input CWithACreateWithoutXInput {
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateWithoutYInput {
  x: AWithIdWithCCreateManyWithoutXInput
}

type CWithAEdge {
  node: CWithA!
  cursor: String!
}

enum CWithAOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithA
  updatedFields: [String!]
}

input CWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithAWhereInput
  AND: [CWithASubscriptionWhereInput!]
  OR: [CWithASubscriptionWhereInput!]
  NOT: [CWithASubscriptionWhereInput!]
}

input CWithAUpdateOneRequiredWithoutXInput {
  create: CWithACreateWithoutXInput
  update: CWithAUpdateWithoutXDataInput
  upsert: CWithAUpsertWithoutXInput
}

input CWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithCUpdateManyWithoutXInput
}

input CWithAUpsertWithoutXInput {
  update: CWithAUpdateWithoutXDataInput!
  create: CWithACreateWithoutXInput!
}

input CWithAWhereInput {
  x_every: AWithIdWithCWhereInput
  x_some: AWithIdWithCWhereInput
  x_none: AWithIdWithCWhereInput
  y_every: AWithoutIdWithCWhereInput
  y_some: AWithoutIdWithCWhereInput
  y_none: AWithoutIdWithCWhereInput
  AND: [CWithAWhereInput!]
  OR: [CWithAWhereInput!]
  NOT: [CWithAWhereInput!]
}

type CWithB {
  x(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC!]
  y(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC!]
}

type CWithBConnection {
  pageInfo: PageInfo!
  edges: [CWithBEdge]!
  aggregate: AggregateCWithB!
}

input CWithBCreateInput {
  x: BWithIdWithCCreateManyWithoutXInput
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
}

input CWithBCreateOneWithoutYInput {
  create: CWithBCreateWithoutYInput
}

input CWithBCreateWithoutXInput {
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateWithoutYInput {
  x: BWithIdWithCCreateManyWithoutXInput
}

type CWithBEdge {
  node: CWithB!
  cursor: String!
}

enum CWithBOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithB
  updatedFields: [String!]
}

input CWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithBWhereInput
  AND: [CWithBSubscriptionWhereInput!]
  OR: [CWithBSubscriptionWhereInput!]
  NOT: [CWithBSubscriptionWhereInput!]
}

input CWithBUpdateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
  update: CWithBUpdateWithoutXDataInput
  upsert: CWithBUpsertWithoutXInput
  delete: Boolean
  disconnect: Boolean
}

input CWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithCUpdateManyWithoutXInput
}

input CWithBUpsertWithoutXInput {
  update: CWithBUpdateWithoutXDataInput!
  create: CWithBCreateWithoutXInput!
}

input CWithBWhereInput {
  x_every: BWithIdWithCWhereInput
  x_some: BWithIdWithCWhereInput
  x_none: BWithIdWithCWhereInput
  y_every: BWithoutIdWithCWhereInput
  y_some: BWithoutIdWithCWhereInput
  y_none: BWithoutIdWithCWhereInput
  AND: [CWithBWhereInput!]
  OR: [CWithBWhereInput!]
  NOT: [CWithBWhereInput!]
}

type CWithC {
  x(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC!]
  y(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC!]
}

type CWithCConnection {
  pageInfo: PageInfo!
  edges: [CWithCEdge]!
  aggregate: AggregateCWithC!
}

input CWithCCreateInput {
  x: CWithIdWithCCreateManyWithoutXInput
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
}

input CWithCCreateManyWithoutYInput {
  create: [CWithCCreateWithoutYInput!]
}

input CWithCCreateWithoutXInput {
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateWithoutYInput {
  x: CWithIdWithCCreateManyWithoutXInput
}

type CWithCEdge {
  node: CWithC!
  cursor: String!
}

enum CWithCOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithC
  updatedFields: [String!]
}

input CWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithCWhereInput
  AND: [CWithCSubscriptionWhereInput!]
  OR: [CWithCSubscriptionWhereInput!]
  NOT: [CWithCSubscriptionWhereInput!]
}

input CWithCUpdateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
}

input CWithCWhereInput {
  x_every: CWithIdWithCWhereInput
  x_some: CWithIdWithCWhereInput
  x_none: CWithIdWithCWhereInput
  y_every: CWithoutIdWithCWhereInput
  y_some: CWithoutIdWithCWhereInput
  y_none: CWithoutIdWithCWhereInput
  AND: [CWithCWhereInput!]
  OR: [CWithCWhereInput!]
  NOT: [CWithCWhereInput!]
}

type CWithIdWithA {
  id: ID!
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

type CWithIdWithAConnection {
  pageInfo: PageInfo!
  edges: [CWithIdWithAEdge]!
  aggregate: AggregateCWithIdWithA!
}

input CWithIdWithACreateInput {
  field: String!
  x: AWithCCreateManyWithoutXInput
}

input CWithIdWithACreateOneWithoutXInput {
  create: CWithIdWithACreateWithoutXInput
  connect: CWithIdWithAWhereUniqueInput
}

input CWithIdWithACreateWithoutXInput {
  field: String!
}

type CWithIdWithAEdge {
  node: CWithIdWithA!
  cursor: String!
}

enum CWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithA
  updatedFields: [String!]
  previousValues: CWithIdWithAPreviousValues
}

input CWithIdWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithIdWithAWhereInput
  AND: [CWithIdWithASubscriptionWhereInput!]
  OR: [CWithIdWithASubscriptionWhereInput!]
  NOT: [CWithIdWithASubscriptionWhereInput!]
}

input CWithIdWithAUpdateInput {
  field: String
  x: AWithCUpdateManyWithoutXInput
}

input CWithIdWithAUpdateManyMutationInput {
  field: String
}

input CWithIdWithAWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x_every: AWithCWhereInput
  x_some: AWithCWhereInput
  x_none: AWithCWhereInput
  AND: [CWithIdWithAWhereInput!]
  OR: [CWithIdWithAWhereInput!]
  NOT: [CWithIdWithAWhereInput!]
}

input CWithIdWithAWhereUniqueInput {
  id: ID
}

type CWithIdWithB {
  id: ID!
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

type CWithIdWithBConnection {
  pageInfo: PageInfo!
  edges: [CWithIdWithBEdge]!
  aggregate: AggregateCWithIdWithB!
}

input CWithIdWithBCreateInput {
  field: String!
  x: BWithCCreateManyWithoutXInput
}

input CWithIdWithBCreateOneWithoutXInput {
  create: CWithIdWithBCreateWithoutXInput
  connect: CWithIdWithBWhereUniqueInput
}

input CWithIdWithBCreateWithoutXInput {
  field: String!
}

type CWithIdWithBEdge {
  node: CWithIdWithB!
  cursor: String!
}

enum CWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithB
  updatedFields: [String!]
  previousValues: CWithIdWithBPreviousValues
}

input CWithIdWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithIdWithBWhereInput
  AND: [CWithIdWithBSubscriptionWhereInput!]
  OR: [CWithIdWithBSubscriptionWhereInput!]
  NOT: [CWithIdWithBSubscriptionWhereInput!]
}

input CWithIdWithBUpdateInput {
  field: String
  x: BWithCUpdateManyWithoutXInput
}

input CWithIdWithBUpdateManyMutationInput {
  field: String
}

input CWithIdWithBWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x_every: BWithCWhereInput
  x_some: BWithCWhereInput
  x_none: BWithCWhereInput
  AND: [CWithIdWithBWhereInput!]
  OR: [CWithIdWithBWhereInput!]
  NOT: [CWithIdWithBWhereInput!]
}

input CWithIdWithBWhereUniqueInput {
  id: ID
}

type CWithIdWithC {
  id: ID!
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

type CWithIdWithCConnection {
  pageInfo: PageInfo!
  edges: [CWithIdWithCEdge]!
  aggregate: AggregateCWithIdWithC!
}

input CWithIdWithCCreateInput {
  field: String!
  x: CWithCCreateManyWithoutXInput
}

input CWithIdWithCCreateManyWithoutXInput {
  create: [CWithIdWithCCreateWithoutXInput!]
  connect: [CWithIdWithCWhereUniqueInput!]
}

input CWithIdWithCCreateWithoutXInput {
  field: String!
}

type CWithIdWithCEdge {
  node: CWithIdWithC!
  cursor: String!
}

enum CWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithC
  updatedFields: [String!]
  previousValues: CWithIdWithCPreviousValues
}

input CWithIdWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithIdWithCWhereInput
  AND: [CWithIdWithCSubscriptionWhereInput!]
  OR: [CWithIdWithCSubscriptionWhereInput!]
  NOT: [CWithIdWithCSubscriptionWhereInput!]
}

input CWithIdWithCUpdateInput {
  field: String
  x: CWithCUpdateManyWithoutXInput
}

input CWithIdWithCUpdateManyMutationInput {
  field: String
}

input CWithIdWithCWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x_every: CWithCWhereInput
  x_some: CWithCWhereInput
  x_none: CWithCWhereInput
  AND: [CWithIdWithCWhereInput!]
  OR: [CWithIdWithCWhereInput!]
  NOT: [CWithIdWithCWhereInput!]
}

input CWithIdWithCWhereUniqueInput {
  id: ID
}

type CWithoutIdWithA {
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

type CWithoutIdWithAConnection {
  pageInfo: PageInfo!
  edges: [CWithoutIdWithAEdge]!
  aggregate: AggregateCWithoutIdWithA!
}

input CWithoutIdWithACreateInput {
  field: String!
  x: AWithCCreateManyWithoutYInput
}

input CWithoutIdWithACreateOneWithoutXInput {
  create: CWithoutIdWithACreateWithoutXInput
}

input CWithoutIdWithACreateWithoutXInput {
  field: String!
}

type CWithoutIdWithAEdge {
  node: CWithoutIdWithA!
  cursor: String!
}

enum CWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithoutIdWithAPreviousValues {
  field: String!
}

type CWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithA
  updatedFields: [String!]
  previousValues: CWithoutIdWithAPreviousValues
}

input CWithoutIdWithASubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithAWhereInput
  AND: [CWithoutIdWithASubscriptionWhereInput!]
  OR: [CWithoutIdWithASubscriptionWhereInput!]
  NOT: [CWithoutIdWithASubscriptionWhereInput!]
}

input CWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithAWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x_every: AWithCWhereInput
  x_some: AWithCWhereInput
  x_none: AWithCWhereInput
  AND: [CWithoutIdWithAWhereInput!]
  OR: [CWithoutIdWithAWhereInput!]
  NOT: [CWithoutIdWithAWhereInput!]
}

type CWithoutIdWithB {
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

type CWithoutIdWithBConnection {
  pageInfo: PageInfo!
  edges: [CWithoutIdWithBEdge]!
  aggregate: AggregateCWithoutIdWithB!
}

input CWithoutIdWithBCreateInput {
  field: String!
  x: BWithCCreateManyWithoutYInput
}

input CWithoutIdWithBCreateOneWithoutXInput {
  create: CWithoutIdWithBCreateWithoutXInput
}

input CWithoutIdWithBCreateWithoutXInput {
  field: String!
}

type CWithoutIdWithBEdge {
  node: CWithoutIdWithB!
  cursor: String!
}

enum CWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithoutIdWithBPreviousValues {
  field: String!
}

type CWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithB
  updatedFields: [String!]
  previousValues: CWithoutIdWithBPreviousValues
}

input CWithoutIdWithBSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithBWhereInput
  AND: [CWithoutIdWithBSubscriptionWhereInput!]
  OR: [CWithoutIdWithBSubscriptionWhereInput!]
  NOT: [CWithoutIdWithBSubscriptionWhereInput!]
}

input CWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithBWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x_every: BWithCWhereInput
  x_some: BWithCWhereInput
  x_none: BWithCWhereInput
  AND: [CWithoutIdWithBWhereInput!]
  OR: [CWithoutIdWithBWhereInput!]
  NOT: [CWithoutIdWithBWhereInput!]
}

type CWithoutIdWithC {
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

type CWithoutIdWithCConnection {
  pageInfo: PageInfo!
  edges: [CWithoutIdWithCEdge]!
  aggregate: AggregateCWithoutIdWithC!
}

input CWithoutIdWithCCreateInput {
  field: String!
  x: CWithCCreateManyWithoutYInput
}

input CWithoutIdWithCCreateManyWithoutXInput {
  create: [CWithoutIdWithCCreateWithoutXInput!]
}

input CWithoutIdWithCCreateWithoutXInput {
  field: String!
}

type CWithoutIdWithCEdge {
  node: CWithoutIdWithC!
  cursor: String!
}

enum CWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CWithoutIdWithCPreviousValues {
  field: String!
}

type CWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithC
  updatedFields: [String!]
  previousValues: CWithoutIdWithCPreviousValues
}

input CWithoutIdWithCSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithCWhereInput
  AND: [CWithoutIdWithCSubscriptionWhereInput!]
  OR: [CWithoutIdWithCSubscriptionWhereInput!]
  NOT: [CWithoutIdWithCSubscriptionWhereInput!]
}

input CWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithCWhereInput {
  field: String
  field_not: String
  field_in: [String!]
  field_not_in: [String!]
  field_lt: String
  field_lte: String
  field_gt: String
  field_gte: String
  field_contains: String
  field_not_contains: String
  field_starts_with: String
  field_not_starts_with: String
  field_ends_with: String
  field_not_ends_with: String
  x_every: CWithCWhereInput
  x_some: CWithCWhereInput
  x_none: CWithCWhereInput
  AND: [CWithoutIdWithCWhereInput!]
  OR: [CWithoutIdWithCWhereInput!]
  NOT: [CWithoutIdWithCWhereInput!]
}

scalar Long

type Mutation {
  createAWithIdWithA(data: AWithIdWithACreateInput!): AWithIdWithA!
  updateAWithIdWithA(data: AWithIdWithAUpdateInput!, where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  updateManyAWithIdWithAs(data: AWithIdWithAUpdateManyMutationInput!, where: AWithIdWithAWhereInput): BatchPayload!
  upsertAWithIdWithA(where: AWithIdWithAWhereUniqueInput!, create: AWithIdWithACreateInput!, update: AWithIdWithAUpdateInput!): AWithIdWithA!
  deleteAWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  deleteManyAWithIdWithAs(where: AWithIdWithAWhereInput): BatchPayload!
  createAWithoutIdWithA(data: AWithoutIdWithACreateInput!): AWithoutIdWithA!
  updateManyAWithoutIdWithAs(data: AWithoutIdWithAUpdateManyMutationInput!, where: AWithoutIdWithAWhereInput): BatchPayload!
  deleteManyAWithoutIdWithAs(where: AWithoutIdWithAWhereInput): BatchPayload!
  createBWithIdWithA(data: BWithIdWithACreateInput!): BWithIdWithA!
  updateBWithIdWithA(data: BWithIdWithAUpdateInput!, where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  updateManyBWithIdWithAs(data: BWithIdWithAUpdateManyMutationInput!, where: BWithIdWithAWhereInput): BatchPayload!
  upsertBWithIdWithA(where: BWithIdWithAWhereUniqueInput!, create: BWithIdWithACreateInput!, update: BWithIdWithAUpdateInput!): BWithIdWithA!
  deleteBWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  deleteManyBWithIdWithAs(where: BWithIdWithAWhereInput): BatchPayload!
  createBWithoutIdWithA(data: BWithoutIdWithACreateInput!): BWithoutIdWithA!
  updateManyBWithoutIdWithAs(data: BWithoutIdWithAUpdateManyMutationInput!, where: BWithoutIdWithAWhereInput): BatchPayload!
  deleteManyBWithoutIdWithAs(where: BWithoutIdWithAWhereInput): BatchPayload!
  createCWithIdWithA(data: CWithIdWithACreateInput!): CWithIdWithA!
  updateCWithIdWithA(data: CWithIdWithAUpdateInput!, where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  updateManyCWithIdWithAs(data: CWithIdWithAUpdateManyMutationInput!, where: CWithIdWithAWhereInput): BatchPayload!
  upsertCWithIdWithA(where: CWithIdWithAWhereUniqueInput!, create: CWithIdWithACreateInput!, update: CWithIdWithAUpdateInput!): CWithIdWithA!
  deleteCWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  deleteManyCWithIdWithAs(where: CWithIdWithAWhereInput): BatchPayload!
  createCWithoutIdWithA(data: CWithoutIdWithACreateInput!): CWithoutIdWithA!
  updateManyCWithoutIdWithAs(data: CWithoutIdWithAUpdateManyMutationInput!, where: CWithoutIdWithAWhereInput): BatchPayload!
  deleteManyCWithoutIdWithAs(where: CWithoutIdWithAWhereInput): BatchPayload!
  createAWithIdWithB(data: AWithIdWithBCreateInput!): AWithIdWithB!
  updateAWithIdWithB(data: AWithIdWithBUpdateInput!, where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  updateManyAWithIdWithBs(data: AWithIdWithBUpdateManyMutationInput!, where: AWithIdWithBWhereInput): BatchPayload!
  upsertAWithIdWithB(where: AWithIdWithBWhereUniqueInput!, create: AWithIdWithBCreateInput!, update: AWithIdWithBUpdateInput!): AWithIdWithB!
  deleteAWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  deleteManyAWithIdWithBs(where: AWithIdWithBWhereInput): BatchPayload!
  createAWithoutIdWithB(data: AWithoutIdWithBCreateInput!): AWithoutIdWithB!
  updateManyAWithoutIdWithBs(data: AWithoutIdWithBUpdateManyMutationInput!, where: AWithoutIdWithBWhereInput): BatchPayload!
  deleteManyAWithoutIdWithBs(where: AWithoutIdWithBWhereInput): BatchPayload!
  createBWithIdWithB(data: BWithIdWithBCreateInput!): BWithIdWithB!
  updateBWithIdWithB(data: BWithIdWithBUpdateInput!, where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  updateManyBWithIdWithBs(data: BWithIdWithBUpdateManyMutationInput!, where: BWithIdWithBWhereInput): BatchPayload!
  upsertBWithIdWithB(where: BWithIdWithBWhereUniqueInput!, create: BWithIdWithBCreateInput!, update: BWithIdWithBUpdateInput!): BWithIdWithB!
  deleteBWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  deleteManyBWithIdWithBs(where: BWithIdWithBWhereInput): BatchPayload!
  createBWithoutIdWithB(data: BWithoutIdWithBCreateInput!): BWithoutIdWithB!
  updateManyBWithoutIdWithBs(data: BWithoutIdWithBUpdateManyMutationInput!, where: BWithoutIdWithBWhereInput): BatchPayload!
  deleteManyBWithoutIdWithBs(where: BWithoutIdWithBWhereInput): BatchPayload!
  createCWithIdWithB(data: CWithIdWithBCreateInput!): CWithIdWithB!
  updateCWithIdWithB(data: CWithIdWithBUpdateInput!, where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  updateManyCWithIdWithBs(data: CWithIdWithBUpdateManyMutationInput!, where: CWithIdWithBWhereInput): BatchPayload!
  upsertCWithIdWithB(where: CWithIdWithBWhereUniqueInput!, create: CWithIdWithBCreateInput!, update: CWithIdWithBUpdateInput!): CWithIdWithB!
  deleteCWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  deleteManyCWithIdWithBs(where: CWithIdWithBWhereInput): BatchPayload!
  createCWithoutIdWithB(data: CWithoutIdWithBCreateInput!): CWithoutIdWithB!
  updateManyCWithoutIdWithBs(data: CWithoutIdWithBUpdateManyMutationInput!, where: CWithoutIdWithBWhereInput): BatchPayload!
  deleteManyCWithoutIdWithBs(where: CWithoutIdWithBWhereInput): BatchPayload!
  createAWithIdWithC(data: AWithIdWithCCreateInput!): AWithIdWithC!
  updateAWithIdWithC(data: AWithIdWithCUpdateInput!, where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  updateManyAWithIdWithCs(data: AWithIdWithCUpdateManyMutationInput!, where: AWithIdWithCWhereInput): BatchPayload!
  upsertAWithIdWithC(where: AWithIdWithCWhereUniqueInput!, create: AWithIdWithCCreateInput!, update: AWithIdWithCUpdateInput!): AWithIdWithC!
  deleteAWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  deleteManyAWithIdWithCs(where: AWithIdWithCWhereInput): BatchPayload!
  createAWithoutIdWithC(data: AWithoutIdWithCCreateInput!): AWithoutIdWithC!
  updateManyAWithoutIdWithCs(data: AWithoutIdWithCUpdateManyMutationInput!, where: AWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithoutIdWithCs(where: AWithoutIdWithCWhereInput): BatchPayload!
  createBWithIdWithC(data: BWithIdWithCCreateInput!): BWithIdWithC!
  updateBWithIdWithC(data: BWithIdWithCUpdateInput!, where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  updateManyBWithIdWithCs(data: BWithIdWithCUpdateManyMutationInput!, where: BWithIdWithCWhereInput): BatchPayload!
  upsertBWithIdWithC(where: BWithIdWithCWhereUniqueInput!, create: BWithIdWithCCreateInput!, update: BWithIdWithCUpdateInput!): BWithIdWithC!
  deleteBWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  deleteManyBWithIdWithCs(where: BWithIdWithCWhereInput): BatchPayload!
  createBWithoutIdWithC(data: BWithoutIdWithCCreateInput!): BWithoutIdWithC!
  updateManyBWithoutIdWithCs(data: BWithoutIdWithCUpdateManyMutationInput!, where: BWithoutIdWithCWhereInput): BatchPayload!
  deleteManyBWithoutIdWithCs(where: BWithoutIdWithCWhereInput): BatchPayload!
  createCWithIdWithC(data: CWithIdWithCCreateInput!): CWithIdWithC!
  updateCWithIdWithC(data: CWithIdWithCUpdateInput!, where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  updateManyCWithIdWithCs(data: CWithIdWithCUpdateManyMutationInput!, where: CWithIdWithCWhereInput): BatchPayload!
  upsertCWithIdWithC(where: CWithIdWithCWhereUniqueInput!, create: CWithIdWithCCreateInput!, update: CWithIdWithCUpdateInput!): CWithIdWithC!
  deleteCWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  deleteManyCWithIdWithCs(where: CWithIdWithCWhereInput): BatchPayload!
  createCWithoutIdWithC(data: CWithoutIdWithCCreateInput!): CWithoutIdWithC!
  updateManyCWithoutIdWithCs(data: CWithoutIdWithCUpdateManyMutationInput!, where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyCWithoutIdWithCs(where: CWithoutIdWithCWhereInput): BatchPayload!
  createAWithA(data: AWithACreateInput!): AWithA!
  deleteManyAWithAs(where: AWithAWhereInput): BatchPayload!
  createAWithB(data: AWithBCreateInput!): AWithB!
  deleteManyAWithBs(where: AWithBWhereInput): BatchPayload!
  createAWithC(data: AWithCCreateInput!): AWithC!
  deleteManyAWithCs(where: AWithCWhereInput): BatchPayload!
  createBWithA(data: BWithACreateInput!): BWithA!
  deleteManyBWithAs(where: BWithAWhereInput): BatchPayload!
  createBWithB(data: BWithBCreateInput!): BWithB!
  deleteManyBWithBs(where: BWithBWhereInput): BatchPayload!
  createBWithC(data: BWithCCreateInput!): BWithC!
  deleteManyBWithCs(where: BWithCWhereInput): BatchPayload!
  createCWithA(data: CWithACreateInput!): CWithA!
  deleteManyCWithAs(where: CWithAWhereInput): BatchPayload!
  createCWithB(data: CWithBCreateInput!): CWithB!
  deleteManyCWithBs(where: CWithBWhereInput): BatchPayload!
  createCWithC(data: CWithCCreateInput!): CWithC!
  deleteManyCWithCs(where: CWithCWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  aWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  aWithIdWithAs(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithA]!
  aWithIdWithAsConnection(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithAConnection!
  aWithoutIdWithAs(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithA]!
  aWithoutIdWithAsConnection(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithAConnection!
  bWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  bWithIdWithAs(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithA]!
  bWithIdWithAsConnection(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithAConnection!
  bWithoutIdWithAs(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithA]!
  bWithoutIdWithAsConnection(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithAConnection!
  cWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  cWithIdWithAs(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithA]!
  cWithIdWithAsConnection(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithAConnection!
  cWithoutIdWithAs(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithA]!
  cWithoutIdWithAsConnection(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithAConnection!
  aWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  aWithIdWithBs(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithB]!
  aWithIdWithBsConnection(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithBConnection!
  aWithoutIdWithBs(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithB]!
  aWithoutIdWithBsConnection(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithBConnection!
  bWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  bWithIdWithBs(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithB]!
  bWithIdWithBsConnection(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithBConnection!
  bWithoutIdWithBs(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithB]!
  bWithoutIdWithBsConnection(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithBConnection!
  cWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  cWithIdWithBs(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithB]!
  cWithIdWithBsConnection(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithBConnection!
  cWithoutIdWithBs(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithB]!
  cWithoutIdWithBsConnection(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithBConnection!
  aWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  aWithIdWithCs(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC]!
  aWithIdWithCsConnection(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithCConnection!
  aWithoutIdWithCs(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC]!
  aWithoutIdWithCsConnection(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithCConnection!
  bWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  bWithIdWithCs(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC]!
  bWithIdWithCsConnection(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithCConnection!
  bWithoutIdWithCs(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC]!
  bWithoutIdWithCsConnection(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithCConnection!
  cWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  cWithIdWithCs(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC]!
  cWithIdWithCsConnection(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithCConnection!
  cWithoutIdWithCs(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC]!
  cWithoutIdWithCsConnection(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithCConnection!
  aWithAs(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithA]!
  aWithAsConnection(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithAConnection!
  aWithBs(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithB]!
  aWithBsConnection(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithBConnection!
  aWithCs(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC]!
  aWithCsConnection(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithCConnection!
  bWithAs(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithA]!
  bWithAsConnection(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithAConnection!
  bWithBs(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithB]!
  bWithBsConnection(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithBConnection!
  bWithCs(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC]!
  bWithCsConnection(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithCConnection!
  cWithAs(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithA]!
  cWithAsConnection(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithAConnection!
  cWithBs(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithB]!
  cWithBsConnection(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithBConnection!
  cWithCs(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC]!
  cWithCsConnection(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithCConnection!
  node(id: ID!): Node
}

type Subscription {
  aWithIdWithA(where: AWithIdWithASubscriptionWhereInput): AWithIdWithASubscriptionPayload
  aWithoutIdWithA(where: AWithoutIdWithASubscriptionWhereInput): AWithoutIdWithASubscriptionPayload
  bWithIdWithA(where: BWithIdWithASubscriptionWhereInput): BWithIdWithASubscriptionPayload
  bWithoutIdWithA(where: BWithoutIdWithASubscriptionWhereInput): BWithoutIdWithASubscriptionPayload
  cWithIdWithA(where: CWithIdWithASubscriptionWhereInput): CWithIdWithASubscriptionPayload
  cWithoutIdWithA(where: CWithoutIdWithASubscriptionWhereInput): CWithoutIdWithASubscriptionPayload
  aWithIdWithB(where: AWithIdWithBSubscriptionWhereInput): AWithIdWithBSubscriptionPayload
  aWithoutIdWithB(where: AWithoutIdWithBSubscriptionWhereInput): AWithoutIdWithBSubscriptionPayload
  bWithIdWithB(where: BWithIdWithBSubscriptionWhereInput): BWithIdWithBSubscriptionPayload
  bWithoutIdWithB(where: BWithoutIdWithBSubscriptionWhereInput): BWithoutIdWithBSubscriptionPayload
  cWithIdWithB(where: CWithIdWithBSubscriptionWhereInput): CWithIdWithBSubscriptionPayload
  cWithoutIdWithB(where: CWithoutIdWithBSubscriptionWhereInput): CWithoutIdWithBSubscriptionPayload
  aWithIdWithC(where: AWithIdWithCSubscriptionWhereInput): AWithIdWithCSubscriptionPayload
  aWithoutIdWithC(where: AWithoutIdWithCSubscriptionWhereInput): AWithoutIdWithCSubscriptionPayload
  bWithIdWithC(where: BWithIdWithCSubscriptionWhereInput): BWithIdWithCSubscriptionPayload
  bWithoutIdWithC(where: BWithoutIdWithCSubscriptionWhereInput): BWithoutIdWithCSubscriptionPayload
  cWithIdWithC(where: CWithIdWithCSubscriptionWhereInput): CWithIdWithCSubscriptionPayload
  cWithoutIdWithC(where: CWithoutIdWithCSubscriptionWhereInput): CWithoutIdWithCSubscriptionPayload
  aWithA(where: AWithASubscriptionWhereInput): AWithASubscriptionPayload
  aWithB(where: AWithBSubscriptionWhereInput): AWithBSubscriptionPayload
  aWithC(where: AWithCSubscriptionWhereInput): AWithCSubscriptionPayload
  bWithA(where: BWithASubscriptionWhereInput): BWithASubscriptionPayload
  bWithB(where: BWithBSubscriptionWhereInput): BWithBSubscriptionPayload
  bWithC(where: BWithCSubscriptionWhereInput): BWithCSubscriptionPayload
  cWithA(where: CWithASubscriptionWhereInput): CWithASubscriptionPayload
  cWithB(where: CWithBSubscriptionWhereInput): CWithBSubscriptionPayload
  cWithC(where: CWithCSubscriptionWhereInput): CWithCSubscriptionPayload
}
