type AggregateAWithA {
  count: Int!
}

type AggregateAWithB {
  count: Int!
}

type AggregateAWithC {
  count: Int!
}

type AggregateAWithIdWithA {
  count: Int!
}

type AggregateAWithIdWithB {
  count: Int!
}

type AggregateAWithIdWithC {
  count: Int!
}

type AggregateAWithoutIdWithA {
  count: Int!
}

type AggregateAWithoutIdWithB {
  count: Int!
}

type AggregateAWithoutIdWithC {
  count: Int!
}

type AggregateBWithA {
  count: Int!
}

type AggregateBWithB {
  count: Int!
}

type AggregateBWithC {
  count: Int!
}

type AggregateBWithIdWithA {
  count: Int!
}

type AggregateBWithIdWithB {
  count: Int!
}

type AggregateBWithIdWithC {
  count: Int!
}

type AggregateBWithoutIdWithA {
  count: Int!
}

type AggregateBWithoutIdWithB {
  count: Int!
}

type AggregateBWithoutIdWithC {
  count: Int!
}

type AggregateCWithA {
  count: Int!
}

type AggregateCWithB {
  count: Int!
}

type AggregateCWithC {
  count: Int!
}

type AggregateCWithIdWithA {
  count: Int!
}

type AggregateCWithIdWithB {
  count: Int!
}

type AggregateCWithIdWithC {
  count: Int!
}

type AggregateCWithoutIdWithA {
  count: Int!
}

type AggregateCWithoutIdWithB {
  count: Int!
}

type AggregateCWithoutIdWithC {
  count: Int!
}

type AWithA {
  x: AWithIdWithA!
  y: AWithoutIdWithA!
}

"""A connection to a list of items."""
type AWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithAEdge]!
  aggregate: AggregateAWithA!
}

input AWithACreateInput {
  x: AWithIdWithACreateOneWithoutXInput!
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateOneWithoutXInput {
  create: AWithACreateWithoutXInput
}

input AWithACreateOneWithoutYInput {
  create: AWithACreateWithoutYInput
}

input AWithACreateWithoutXInput {
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateWithoutYInput {
  x: AWithIdWithACreateOneWithoutXInput!
}

"""An edge in a connection."""
type AWithAEdge {
  """The item at the end of the edge."""
  node: AWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithAOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithA
  updatedFields: [String!]
}

input AWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithAWhereInput
}

input AWithAUpdateOneRequiredWithoutXInput {
  create: AWithACreateWithoutXInput
  update: AWithAUpdateWithoutXDataInput
  upsert: AWithAUpsertWithoutXInput
}

input AWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithAUpsertWithoutXInput {
  update: AWithAUpdateWithoutXDataInput!
  create: AWithACreateWithoutXInput!
}

input AWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithAWhereInput!]
  x: AWithIdWithAWhereInput
  y: AWithoutIdWithAWhereInput
}

type AWithB {
  x: BWithIdWithA!
  y: BWithoutIdWithA!
}

"""A connection to a list of items."""
type AWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithBEdge]!
  aggregate: AggregateAWithB!
}

input AWithBCreateInput {
  x: BWithIdWithACreateOneWithoutXInput!
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
}

input AWithBCreateOneWithoutYInput {
  create: AWithBCreateWithoutYInput
}

input AWithBCreateWithoutXInput {
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateWithoutYInput {
  x: BWithIdWithACreateOneWithoutXInput!
}

"""An edge in a connection."""
type AWithBEdge {
  """The item at the end of the edge."""
  node: AWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithBOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithB
  updatedFields: [String!]
}

input AWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithBWhereInput
}

input AWithBUpdateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: AWithBUpdateWithoutXDataInput
  upsert: AWithBUpsertWithoutXInput
}

input AWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithBUpsertWithoutXInput {
  update: AWithBUpdateWithoutXDataInput!
  create: AWithBCreateWithoutXInput!
}

input AWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithBWhereInput!]
  x: BWithIdWithAWhereInput
  y: BWithoutIdWithAWhereInput
}

type AWithC {
  x: CWithIdWithA!
  y: CWithoutIdWithA!
}

"""A connection to a list of items."""
type AWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithCEdge]!
  aggregate: AggregateAWithC!
}

input AWithCCreateInput {
  x: CWithIdWithACreateOneWithoutXInput!
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
}

input AWithCCreateManyWithoutYInput {
  create: [AWithCCreateWithoutYInput!]
}

input AWithCCreateWithoutXInput {
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateWithoutYInput {
  x: CWithIdWithACreateOneWithoutXInput!
}

"""An edge in a connection."""
type AWithCEdge {
  """The item at the end of the edge."""
  node: AWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithCOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithC
  updatedFields: [String!]
}

input AWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithCWhereInput
}

input AWithCUpdateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
}

input AWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithCWhereInput!]
  x: CWithIdWithAWhereInput
  y: CWithoutIdWithAWhereInput
}

type AWithIdWithA implements Node {
  id: ID!
  field: String!
  x: AWithA!
}

"""A connection to a list of items."""
type AWithIdWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithIdWithAEdge]!
  aggregate: AggregateAWithIdWithA!
}

input AWithIdWithACreateInput {
  field: String!
  x: AWithACreateOneWithoutXInput!
}

input AWithIdWithACreateOneWithoutXInput {
  create: AWithIdWithACreateWithoutXInput
  connect: AWithIdWithAWhereUniqueInput
}

input AWithIdWithACreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type AWithIdWithAEdge {
  """The item at the end of the edge."""
  node: AWithIdWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithA
  updatedFields: [String!]
  previousValues: AWithIdWithAPreviousValues
}

input AWithIdWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithIdWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithIdWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithIdWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithAWhereInput
}

input AWithIdWithAUpdateInput {
  field: String
  x: AWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithAUpdateManyMutationInput {
  field: String
}

input AWithIdWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithIdWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithIdWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithIdWithAWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: AWithAWhereInput
}

input AWithIdWithAWhereUniqueInput {
  id: ID
}

type AWithIdWithB implements Node {
  id: ID!
  field: String!
  x: BWithA!
}

"""A connection to a list of items."""
type AWithIdWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithIdWithBEdge]!
  aggregate: AggregateAWithIdWithB!
}

input AWithIdWithBCreateInput {
  field: String!
  x: BWithACreateOneWithoutXInput!
}

input AWithIdWithBCreateOneWithoutXInput {
  create: AWithIdWithBCreateWithoutXInput
  connect: AWithIdWithBWhereUniqueInput
}

input AWithIdWithBCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type AWithIdWithBEdge {
  """The item at the end of the edge."""
  node: AWithIdWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithB
  updatedFields: [String!]
  previousValues: AWithIdWithBPreviousValues
}

input AWithIdWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithIdWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithIdWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithIdWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithBWhereInput
}

input AWithIdWithBUpdateInput {
  field: String
  x: BWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithBUpdateManyMutationInput {
  field: String
}

input AWithIdWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithIdWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithIdWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithIdWithBWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: BWithAWhereInput
}

input AWithIdWithBWhereUniqueInput {
  id: ID
}

type AWithIdWithC implements Node {
  id: ID!
  field: String!
  x: CWithA!
}

"""A connection to a list of items."""
type AWithIdWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithIdWithCEdge]!
  aggregate: AggregateAWithIdWithC!
}

input AWithIdWithCCreateInput {
  field: String!
  x: CWithACreateOneWithoutXInput!
}

input AWithIdWithCCreateManyWithoutXInput {
  create: [AWithIdWithCCreateWithoutXInput!]
  connect: [AWithIdWithCWhereUniqueInput!]
}

input AWithIdWithCCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type AWithIdWithCEdge {
  """The item at the end of the edge."""
  node: AWithIdWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithC
  updatedFields: [String!]
  previousValues: AWithIdWithCPreviousValues
}

input AWithIdWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithIdWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithIdWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithIdWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithCWhereInput
}

input AWithIdWithCUpdateInput {
  field: String
  x: CWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithCUpdateManyMutationInput {
  field: String
}

input AWithIdWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithIdWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithIdWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithIdWithCWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: CWithAWhereInput
}

input AWithIdWithCWhereUniqueInput {
  id: ID
}

type AWithoutIdWithA {
  field: String!
  x: AWithA!
}

"""A connection to a list of items."""
type AWithoutIdWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithoutIdWithAEdge]!
  aggregate: AggregateAWithoutIdWithA!
}

input AWithoutIdWithACreateInput {
  field: String!
  x: AWithACreateOneWithoutYInput!
}

input AWithoutIdWithACreateOneWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
}

input AWithoutIdWithACreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type AWithoutIdWithAEdge {
  """The item at the end of the edge."""
  node: AWithoutIdWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithoutIdWithAPreviousValues {
  field: String!
}

type AWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithA
  updatedFields: [String!]
  previousValues: AWithoutIdWithAPreviousValues
}

input AWithoutIdWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithAWhereInput
}

input AWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
  update: AWithoutIdWithAUpdateWithoutXDataInput
  upsert: AWithoutIdWithAUpsertWithoutXInput
}

input AWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithAUpsertWithoutXInput {
  update: AWithoutIdWithAUpdateWithoutXDataInput!
  create: AWithoutIdWithACreateWithoutXInput!
}

input AWithoutIdWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithAWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: AWithAWhereInput
}

type AWithoutIdWithB {
  field: String!
  x: BWithA!
}

"""A connection to a list of items."""
type AWithoutIdWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithoutIdWithBEdge]!
  aggregate: AggregateAWithoutIdWithB!
}

input AWithoutIdWithBCreateInput {
  field: String!
  x: BWithACreateOneWithoutYInput!
}

input AWithoutIdWithBCreateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
}

input AWithoutIdWithBCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type AWithoutIdWithBEdge {
  """The item at the end of the edge."""
  node: AWithoutIdWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithoutIdWithBPreviousValues {
  field: String!
}

type AWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithB
  updatedFields: [String!]
  previousValues: AWithoutIdWithBPreviousValues
}

input AWithoutIdWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithBWhereInput
}

input AWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithBUpdateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: AWithoutIdWithBUpdateWithoutXDataInput
  upsert: AWithoutIdWithBUpsertWithoutXInput
}

input AWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithBUpsertWithoutXInput {
  update: AWithoutIdWithBUpdateWithoutXDataInput!
  create: AWithoutIdWithBCreateWithoutXInput!
}

input AWithoutIdWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithBWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: BWithAWhereInput
}

type AWithoutIdWithC {
  field: String!
  x: CWithA!
}

"""A connection to a list of items."""
type AWithoutIdWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AWithoutIdWithCEdge]!
  aggregate: AggregateAWithoutIdWithC!
}

input AWithoutIdWithCCreateInput {
  field: String!
  x: CWithACreateOneWithoutYInput!
}

input AWithoutIdWithCCreateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
}

input AWithoutIdWithCCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type AWithoutIdWithCEdge {
  """The item at the end of the edge."""
  node: AWithoutIdWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithoutIdWithCPreviousValues {
  field: String!
}

input AWithoutIdWithCScalarWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithCScalarWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithCScalarWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithCScalarWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
}

type AWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithC
  updatedFields: [String!]
  previousValues: AWithoutIdWithCPreviousValues
}

input AWithoutIdWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithCWhereInput
}

input AWithoutIdWithCUpdateManyDataInput {
  field: String
}

input AWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithCUpdateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
  updateMany: [AWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [AWithoutIdWithCScalarWhereInput!]
}

input AWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: AWithoutIdWithCScalarWhereInput!
  data: AWithoutIdWithCUpdateManyDataInput!
}

input AWithoutIdWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [AWithoutIdWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [AWithoutIdWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AWithoutIdWithCWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: CWithAWhereInput
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type BWithA {
  x: AWithIdWithB
  y: AWithoutIdWithB
}

"""A connection to a list of items."""
type BWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithAEdge]!
  aggregate: AggregateBWithA!
}

input BWithACreateInput {
  x: AWithIdWithBCreateOneWithoutXInput
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateOneWithoutXInput {
  create: BWithACreateWithoutXInput
}

input BWithACreateOneWithoutYInput {
  create: BWithACreateWithoutYInput
}

input BWithACreateWithoutXInput {
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateWithoutYInput {
  x: AWithIdWithBCreateOneWithoutXInput
}

"""An edge in a connection."""
type BWithAEdge {
  """The item at the end of the edge."""
  node: BWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithAOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithA
  updatedFields: [String!]
}

input BWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithAWhereInput
}

input BWithAUpdateOneRequiredWithoutXInput {
  create: BWithACreateWithoutXInput
  update: BWithAUpdateWithoutXDataInput
  upsert: BWithAUpsertWithoutXInput
}

input BWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithBUpdateOneWithoutXInput
}

input BWithAUpsertWithoutXInput {
  update: BWithAUpdateWithoutXDataInput!
  create: BWithACreateWithoutXInput!
}

input BWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithAWhereInput!]
  x: AWithIdWithBWhereInput
  y: AWithoutIdWithBWhereInput
}

type BWithB {
  x: BWithIdWithB
  y: BWithoutIdWithB
}

"""A connection to a list of items."""
type BWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithBEdge]!
  aggregate: AggregateBWithB!
}

input BWithBCreateInput {
  x: BWithIdWithBCreateOneWithoutXInput
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
}

input BWithBCreateOneWithoutYInput {
  create: BWithBCreateWithoutYInput
}

input BWithBCreateWithoutXInput {
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateWithoutYInput {
  x: BWithIdWithBCreateOneWithoutXInput
}

"""An edge in a connection."""
type BWithBEdge {
  """The item at the end of the edge."""
  node: BWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithBOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithB
  updatedFields: [String!]
}

input BWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithBWhereInput
}

input BWithBUpdateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: BWithBUpdateWithoutXDataInput
  upsert: BWithBUpsertWithoutXInput
}

input BWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithBUpdateOneWithoutXInput
}

input BWithBUpsertWithoutXInput {
  update: BWithBUpdateWithoutXDataInput!
  create: BWithBCreateWithoutXInput!
}

input BWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithBWhereInput!]
  x: BWithIdWithBWhereInput
  y: BWithoutIdWithBWhereInput
}

type BWithC {
  x: CWithIdWithB
  y: CWithoutIdWithB
}

"""A connection to a list of items."""
type BWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithCEdge]!
  aggregate: AggregateBWithC!
}

input BWithCCreateInput {
  x: CWithIdWithBCreateOneWithoutXInput
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
}

input BWithCCreateManyWithoutYInput {
  create: [BWithCCreateWithoutYInput!]
}

input BWithCCreateWithoutXInput {
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateWithoutYInput {
  x: CWithIdWithBCreateOneWithoutXInput
}

"""An edge in a connection."""
type BWithCEdge {
  """The item at the end of the edge."""
  node: BWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithCOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithC
  updatedFields: [String!]
}

input BWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithCWhereInput
}

input BWithCUpdateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
}

input BWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithCWhereInput!]
  x: CWithIdWithBWhereInput
  y: CWithoutIdWithBWhereInput
}

type BWithIdWithA implements Node {
  id: ID!
  field: String!
  x: AWithB
}

"""A connection to a list of items."""
type BWithIdWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithIdWithAEdge]!
  aggregate: AggregateBWithIdWithA!
}

input BWithIdWithACreateInput {
  field: String!
  x: AWithBCreateOneWithoutXInput
}

input BWithIdWithACreateOneWithoutXInput {
  create: BWithIdWithACreateWithoutXInput
  connect: BWithIdWithAWhereUniqueInput
}

input BWithIdWithACreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type BWithIdWithAEdge {
  """The item at the end of the edge."""
  node: BWithIdWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithA
  updatedFields: [String!]
  previousValues: BWithIdWithAPreviousValues
}

input BWithIdWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithIdWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithIdWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithIdWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithAWhereInput
}

input BWithIdWithAUpdateInput {
  field: String
  x: AWithBUpdateOneWithoutXInput
}

input BWithIdWithAUpdateManyMutationInput {
  field: String
}

input BWithIdWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithIdWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithIdWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithIdWithAWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: AWithBWhereInput
}

input BWithIdWithAWhereUniqueInput {
  id: ID
}

type BWithIdWithB implements Node {
  id: ID!
  field: String!
  x: BWithB
}

"""A connection to a list of items."""
type BWithIdWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithIdWithBEdge]!
  aggregate: AggregateBWithIdWithB!
}

input BWithIdWithBCreateInput {
  field: String!
  x: BWithBCreateOneWithoutXInput
}

input BWithIdWithBCreateOneWithoutXInput {
  create: BWithIdWithBCreateWithoutXInput
  connect: BWithIdWithBWhereUniqueInput
}

input BWithIdWithBCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type BWithIdWithBEdge {
  """The item at the end of the edge."""
  node: BWithIdWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithB
  updatedFields: [String!]
  previousValues: BWithIdWithBPreviousValues
}

input BWithIdWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithIdWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithIdWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithIdWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithBWhereInput
}

input BWithIdWithBUpdateInput {
  field: String
  x: BWithBUpdateOneWithoutXInput
}

input BWithIdWithBUpdateManyMutationInput {
  field: String
}

input BWithIdWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithIdWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithIdWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithIdWithBWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: BWithBWhereInput
}

input BWithIdWithBWhereUniqueInput {
  id: ID
}

type BWithIdWithC implements Node {
  id: ID!
  field: String!
  x: CWithB
}

"""A connection to a list of items."""
type BWithIdWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithIdWithCEdge]!
  aggregate: AggregateBWithIdWithC!
}

input BWithIdWithCCreateInput {
  field: String!
  x: CWithBCreateOneWithoutXInput
}

input BWithIdWithCCreateManyWithoutXInput {
  create: [BWithIdWithCCreateWithoutXInput!]
  connect: [BWithIdWithCWhereUniqueInput!]
}

input BWithIdWithCCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type BWithIdWithCEdge {
  """The item at the end of the edge."""
  node: BWithIdWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithC
  updatedFields: [String!]
  previousValues: BWithIdWithCPreviousValues
}

input BWithIdWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithIdWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithIdWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithIdWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithCWhereInput
}

input BWithIdWithCUpdateInput {
  field: String
  x: CWithBUpdateOneWithoutXInput
}

input BWithIdWithCUpdateManyMutationInput {
  field: String
}

input BWithIdWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithIdWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithIdWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithIdWithCWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: CWithBWhereInput
}

input BWithIdWithCWhereUniqueInput {
  id: ID
}

type BWithoutIdWithA {
  field: String!
  x: AWithB
}

"""A connection to a list of items."""
type BWithoutIdWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithoutIdWithAEdge]!
  aggregate: AggregateBWithoutIdWithA!
}

input BWithoutIdWithACreateInput {
  field: String!
  x: AWithBCreateOneWithoutYInput
}

input BWithoutIdWithACreateOneWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
}

input BWithoutIdWithACreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type BWithoutIdWithAEdge {
  """The item at the end of the edge."""
  node: BWithoutIdWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithoutIdWithAPreviousValues {
  field: String!
}

type BWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithA
  updatedFields: [String!]
  previousValues: BWithoutIdWithAPreviousValues
}

input BWithoutIdWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithAWhereInput
}

input BWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
  update: BWithoutIdWithAUpdateWithoutXDataInput
  upsert: BWithoutIdWithAUpsertWithoutXInput
}

input BWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithAUpsertWithoutXInput {
  update: BWithoutIdWithAUpdateWithoutXDataInput!
  create: BWithoutIdWithACreateWithoutXInput!
}

input BWithoutIdWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithAWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: AWithBWhereInput
}

type BWithoutIdWithB {
  field: String!
  x: BWithB
}

"""A connection to a list of items."""
type BWithoutIdWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithoutIdWithBEdge]!
  aggregate: AggregateBWithoutIdWithB!
}

input BWithoutIdWithBCreateInput {
  field: String!
  x: BWithBCreateOneWithoutYInput
}

input BWithoutIdWithBCreateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
}

input BWithoutIdWithBCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type BWithoutIdWithBEdge {
  """The item at the end of the edge."""
  node: BWithoutIdWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithoutIdWithBPreviousValues {
  field: String!
}

type BWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithB
  updatedFields: [String!]
  previousValues: BWithoutIdWithBPreviousValues
}

input BWithoutIdWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithBWhereInput
}

input BWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithBUpdateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: BWithoutIdWithBUpdateWithoutXDataInput
  upsert: BWithoutIdWithBUpsertWithoutXInput
}

input BWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithBUpsertWithoutXInput {
  update: BWithoutIdWithBUpdateWithoutXDataInput!
  create: BWithoutIdWithBCreateWithoutXInput!
}

input BWithoutIdWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithBWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: BWithBWhereInput
}

type BWithoutIdWithC {
  field: String!
  x: CWithB
}

"""A connection to a list of items."""
type BWithoutIdWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BWithoutIdWithCEdge]!
  aggregate: AggregateBWithoutIdWithC!
}

input BWithoutIdWithCCreateInput {
  field: String!
  x: CWithBCreateOneWithoutYInput
}

input BWithoutIdWithCCreateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
}

input BWithoutIdWithCCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type BWithoutIdWithCEdge {
  """The item at the end of the edge."""
  node: BWithoutIdWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithoutIdWithCPreviousValues {
  field: String!
}

input BWithoutIdWithCScalarWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithCScalarWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithCScalarWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithCScalarWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
}

type BWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithC
  updatedFields: [String!]
  previousValues: BWithoutIdWithCPreviousValues
}

input BWithoutIdWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithCWhereInput
}

input BWithoutIdWithCUpdateManyDataInput {
  field: String
}

input BWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithCUpdateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
  updateMany: [BWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [BWithoutIdWithCScalarWhereInput!]
}

input BWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: BWithoutIdWithCScalarWhereInput!
  data: BWithoutIdWithCUpdateManyDataInput!
}

input BWithoutIdWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [BWithoutIdWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [BWithoutIdWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BWithoutIdWithCWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x: CWithBWhereInput
}

type CWithA {
  x(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC!]
  y(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC!]
}

"""A connection to a list of items."""
type CWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithAEdge]!
  aggregate: AggregateCWithA!
}

input CWithACreateInput {
  x: AWithIdWithCCreateManyWithoutXInput
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateOneWithoutXInput {
  create: CWithACreateWithoutXInput
}

input CWithACreateOneWithoutYInput {
  create: CWithACreateWithoutYInput
}

input CWithACreateWithoutXInput {
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateWithoutYInput {
  x: AWithIdWithCCreateManyWithoutXInput
}

"""An edge in a connection."""
type CWithAEdge {
  """The item at the end of the edge."""
  node: CWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithAOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithA
  updatedFields: [String!]
}

input CWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithAWhereInput
}

input CWithAUpdateOneRequiredWithoutXInput {
  create: CWithACreateWithoutXInput
  update: CWithAUpdateWithoutXDataInput
  upsert: CWithAUpsertWithoutXInput
}

input CWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithCUpdateManyWithoutXInput
}

input CWithAUpsertWithoutXInput {
  update: CWithAUpdateWithoutXDataInput!
  create: CWithACreateWithoutXInput!
}

input CWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithAWhereInput!]
  x_every: AWithIdWithCWhereInput
  x_some: AWithIdWithCWhereInput
  x_none: AWithIdWithCWhereInput
  y_every: AWithoutIdWithCWhereInput
  y_some: AWithoutIdWithCWhereInput
  y_none: AWithoutIdWithCWhereInput
}

type CWithB {
  x(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC!]
  y(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC!]
}

"""A connection to a list of items."""
type CWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithBEdge]!
  aggregate: AggregateCWithB!
}

input CWithBCreateInput {
  x: BWithIdWithCCreateManyWithoutXInput
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
}

input CWithBCreateOneWithoutYInput {
  create: CWithBCreateWithoutYInput
}

input CWithBCreateWithoutXInput {
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateWithoutYInput {
  x: BWithIdWithCCreateManyWithoutXInput
}

"""An edge in a connection."""
type CWithBEdge {
  """The item at the end of the edge."""
  node: CWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithBOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithB
  updatedFields: [String!]
}

input CWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithBWhereInput
}

input CWithBUpdateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: CWithBUpdateWithoutXDataInput
  upsert: CWithBUpsertWithoutXInput
}

input CWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithCUpdateManyWithoutXInput
}

input CWithBUpsertWithoutXInput {
  update: CWithBUpdateWithoutXDataInput!
  create: CWithBCreateWithoutXInput!
}

input CWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithBWhereInput!]
  x_every: BWithIdWithCWhereInput
  x_some: BWithIdWithCWhereInput
  x_none: BWithIdWithCWhereInput
  y_every: BWithoutIdWithCWhereInput
  y_some: BWithoutIdWithCWhereInput
  y_none: BWithoutIdWithCWhereInput
}

type CWithC {
  x(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC!]
  y(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC!]
}

"""A connection to a list of items."""
type CWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithCEdge]!
  aggregate: AggregateCWithC!
}

input CWithCCreateInput {
  x: CWithIdWithCCreateManyWithoutXInput
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
}

input CWithCCreateManyWithoutYInput {
  create: [CWithCCreateWithoutYInput!]
}

input CWithCCreateWithoutXInput {
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateWithoutYInput {
  x: CWithIdWithCCreateManyWithoutXInput
}

"""An edge in a connection."""
type CWithCEdge {
  """The item at the end of the edge."""
  node: CWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithCOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithC
  updatedFields: [String!]
}

input CWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithCWhereInput
}

input CWithCUpdateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
}

input CWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithCWhereInput!]
  x_every: CWithIdWithCWhereInput
  x_some: CWithIdWithCWhereInput
  x_none: CWithIdWithCWhereInput
  y_every: CWithoutIdWithCWhereInput
  y_some: CWithoutIdWithCWhereInput
  y_none: CWithoutIdWithCWhereInput
}

type CWithIdWithA implements Node {
  id: ID!
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

"""A connection to a list of items."""
type CWithIdWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithIdWithAEdge]!
  aggregate: AggregateCWithIdWithA!
}

input CWithIdWithACreateInput {
  field: String!
  x: AWithCCreateManyWithoutXInput
}

input CWithIdWithACreateOneWithoutXInput {
  create: CWithIdWithACreateWithoutXInput
  connect: CWithIdWithAWhereUniqueInput
}

input CWithIdWithACreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type CWithIdWithAEdge {
  """The item at the end of the edge."""
  node: CWithIdWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithA
  updatedFields: [String!]
  previousValues: CWithIdWithAPreviousValues
}

input CWithIdWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithIdWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithIdWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithIdWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithAWhereInput
}

input CWithIdWithAUpdateInput {
  field: String
  x: AWithCUpdateManyWithoutXInput
}

input CWithIdWithAUpdateManyMutationInput {
  field: String
}

input CWithIdWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithIdWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithIdWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithIdWithAWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x_every: AWithCWhereInput
  x_some: AWithCWhereInput
  x_none: AWithCWhereInput
}

input CWithIdWithAWhereUniqueInput {
  id: ID
}

type CWithIdWithB implements Node {
  id: ID!
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

"""A connection to a list of items."""
type CWithIdWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithIdWithBEdge]!
  aggregate: AggregateCWithIdWithB!
}

input CWithIdWithBCreateInput {
  field: String!
  x: BWithCCreateManyWithoutXInput
}

input CWithIdWithBCreateOneWithoutXInput {
  create: CWithIdWithBCreateWithoutXInput
  connect: CWithIdWithBWhereUniqueInput
}

input CWithIdWithBCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type CWithIdWithBEdge {
  """The item at the end of the edge."""
  node: CWithIdWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithB
  updatedFields: [String!]
  previousValues: CWithIdWithBPreviousValues
}

input CWithIdWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithIdWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithIdWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithIdWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithBWhereInput
}

input CWithIdWithBUpdateInput {
  field: String
  x: BWithCUpdateManyWithoutXInput
}

input CWithIdWithBUpdateManyMutationInput {
  field: String
}

input CWithIdWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithIdWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithIdWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithIdWithBWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x_every: BWithCWhereInput
  x_some: BWithCWhereInput
  x_none: BWithCWhereInput
}

input CWithIdWithBWhereUniqueInput {
  id: ID
}

type CWithIdWithC implements Node {
  id: ID!
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

"""A connection to a list of items."""
type CWithIdWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithIdWithCEdge]!
  aggregate: AggregateCWithIdWithC!
}

input CWithIdWithCCreateInput {
  field: String!
  x: CWithCCreateManyWithoutXInput
}

input CWithIdWithCCreateManyWithoutXInput {
  create: [CWithIdWithCCreateWithoutXInput!]
  connect: [CWithIdWithCWhereUniqueInput!]
}

input CWithIdWithCCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type CWithIdWithCEdge {
  """The item at the end of the edge."""
  node: CWithIdWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithC
  updatedFields: [String!]
  previousValues: CWithIdWithCPreviousValues
}

input CWithIdWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithIdWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithIdWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithIdWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithCWhereInput
}

input CWithIdWithCUpdateInput {
  field: String
  x: CWithCUpdateManyWithoutXInput
}

input CWithIdWithCUpdateManyMutationInput {
  field: String
}

input CWithIdWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithIdWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithIdWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithIdWithCWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x_every: CWithCWhereInput
  x_some: CWithCWhereInput
  x_none: CWithCWhereInput
}

input CWithIdWithCWhereUniqueInput {
  id: ID
}

type CWithoutIdWithA {
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

"""A connection to a list of items."""
type CWithoutIdWithAConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithoutIdWithAEdge]!
  aggregate: AggregateCWithoutIdWithA!
}

input CWithoutIdWithACreateInput {
  field: String!
  x: AWithCCreateManyWithoutYInput
}

input CWithoutIdWithACreateOneWithoutXInput {
  create: CWithoutIdWithACreateWithoutXInput
}

input CWithoutIdWithACreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type CWithoutIdWithAEdge {
  """The item at the end of the edge."""
  node: CWithoutIdWithA!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithoutIdWithAPreviousValues {
  field: String!
}

type CWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithA
  updatedFields: [String!]
  previousValues: CWithoutIdWithAPreviousValues
}

input CWithoutIdWithASubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithoutIdWithASubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithoutIdWithASubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithoutIdWithASubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithAWhereInput
}

input CWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithAWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithoutIdWithAWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithoutIdWithAWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithoutIdWithAWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x_every: AWithCWhereInput
  x_some: AWithCWhereInput
  x_none: AWithCWhereInput
}

type CWithoutIdWithB {
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

"""A connection to a list of items."""
type CWithoutIdWithBConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithoutIdWithBEdge]!
  aggregate: AggregateCWithoutIdWithB!
}

input CWithoutIdWithBCreateInput {
  field: String!
  x: BWithCCreateManyWithoutYInput
}

input CWithoutIdWithBCreateOneWithoutXInput {
  create: CWithoutIdWithBCreateWithoutXInput
}

input CWithoutIdWithBCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type CWithoutIdWithBEdge {
  """The item at the end of the edge."""
  node: CWithoutIdWithB!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithoutIdWithBPreviousValues {
  field: String!
}

type CWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithB
  updatedFields: [String!]
  previousValues: CWithoutIdWithBPreviousValues
}

input CWithoutIdWithBSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithoutIdWithBSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithoutIdWithBSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithoutIdWithBSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithBWhereInput
}

input CWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithBWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithoutIdWithBWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithoutIdWithBWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithoutIdWithBWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x_every: BWithCWhereInput
  x_some: BWithCWhereInput
  x_none: BWithCWhereInput
}

type CWithoutIdWithC {
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

"""A connection to a list of items."""
type CWithoutIdWithCConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CWithoutIdWithCEdge]!
  aggregate: AggregateCWithoutIdWithC!
}

input CWithoutIdWithCCreateInput {
  field: String!
  x: CWithCCreateManyWithoutYInput
}

input CWithoutIdWithCCreateManyWithoutXInput {
  create: [CWithoutIdWithCCreateWithoutXInput!]
}

input CWithoutIdWithCCreateWithoutXInput {
  field: String!
}

"""An edge in a connection."""
type CWithoutIdWithCEdge {
  """The item at the end of the edge."""
  node: CWithoutIdWithC!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithoutIdWithCPreviousValues {
  field: String!
}

type CWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithC
  updatedFields: [String!]
  previousValues: CWithoutIdWithCPreviousValues
}

input CWithoutIdWithCSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithoutIdWithCSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithoutIdWithCSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithoutIdWithCSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithCWhereInput
}

input CWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithCWhereInput {
  """Logical AND on all given filters."""
  AND: [CWithoutIdWithCWhereInput!]

  """Logical OR on all given filters."""
  OR: [CWithoutIdWithCWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CWithoutIdWithCWhereInput!]
  field: String

  """All values that are not equal to given value."""
  field_not: String

  """All values that are contained in given list."""
  field_in: [String!]

  """All values that are not contained in given list."""
  field_not_in: [String!]

  """All values less than the given value."""
  field_lt: String

  """All values less than or equal the given value."""
  field_lte: String

  """All values greater than the given value."""
  field_gt: String

  """All values greater than or equal the given value."""
  field_gte: String

  """All values containing the given string."""
  field_contains: String

  """All values not containing the given string."""
  field_not_contains: String

  """All values starting with the given string."""
  field_starts_with: String

  """All values not starting with the given string."""
  field_not_starts_with: String

  """All values ending with the given string."""
  field_ends_with: String

  """All values not ending with the given string."""
  field_not_ends_with: String
  x_every: CWithCWhereInput
  x_some: CWithCWhereInput
  x_none: CWithCWhereInput
}

"""Raw JSON value"""
scalar Json

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createAWithIdWithA(data: AWithIdWithACreateInput!): AWithIdWithA!
  createAWithoutIdWithA(data: AWithoutIdWithACreateInput!): AWithoutIdWithA!
  createBWithIdWithA(data: BWithIdWithACreateInput!): BWithIdWithA!
  createBWithoutIdWithA(data: BWithoutIdWithACreateInput!): BWithoutIdWithA!
  createCWithIdWithA(data: CWithIdWithACreateInput!): CWithIdWithA!
  createCWithoutIdWithA(data: CWithoutIdWithACreateInput!): CWithoutIdWithA!
  createAWithIdWithB(data: AWithIdWithBCreateInput!): AWithIdWithB!
  createAWithoutIdWithB(data: AWithoutIdWithBCreateInput!): AWithoutIdWithB!
  createBWithIdWithB(data: BWithIdWithBCreateInput!): BWithIdWithB!
  createBWithoutIdWithB(data: BWithoutIdWithBCreateInput!): BWithoutIdWithB!
  createCWithIdWithB(data: CWithIdWithBCreateInput!): CWithIdWithB!
  createCWithoutIdWithB(data: CWithoutIdWithBCreateInput!): CWithoutIdWithB!
  createAWithIdWithC(data: AWithIdWithCCreateInput!): AWithIdWithC!
  createAWithoutIdWithC(data: AWithoutIdWithCCreateInput!): AWithoutIdWithC!
  createBWithIdWithC(data: BWithIdWithCCreateInput!): BWithIdWithC!
  createBWithoutIdWithC(data: BWithoutIdWithCCreateInput!): BWithoutIdWithC!
  createCWithIdWithC(data: CWithIdWithCCreateInput!): CWithIdWithC!
  createCWithoutIdWithC(data: CWithoutIdWithCCreateInput!): CWithoutIdWithC!
  createAWithA(data: AWithACreateInput!): AWithA!
  createAWithB(data: AWithBCreateInput!): AWithB!
  createAWithC(data: AWithCCreateInput!): AWithC!
  createBWithA(data: BWithACreateInput!): BWithA!
  createBWithB(data: BWithBCreateInput!): BWithB!
  createBWithC(data: BWithCCreateInput!): BWithC!
  createCWithA(data: CWithACreateInput!): CWithA!
  createCWithB(data: CWithBCreateInput!): CWithB!
  createCWithC(data: CWithCCreateInput!): CWithC!
  updateAWithIdWithA(data: AWithIdWithAUpdateInput!, where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  updateBWithIdWithA(data: BWithIdWithAUpdateInput!, where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  updateCWithIdWithA(data: CWithIdWithAUpdateInput!, where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  updateAWithIdWithB(data: AWithIdWithBUpdateInput!, where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  updateBWithIdWithB(data: BWithIdWithBUpdateInput!, where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  updateCWithIdWithB(data: CWithIdWithBUpdateInput!, where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  updateAWithIdWithC(data: AWithIdWithCUpdateInput!, where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  updateBWithIdWithC(data: BWithIdWithCUpdateInput!, where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  updateCWithIdWithC(data: CWithIdWithCUpdateInput!, where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  deleteAWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  deleteBWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  deleteCWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  deleteAWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  deleteBWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  deleteCWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  deleteAWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  deleteBWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  deleteCWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  upsertAWithIdWithA(where: AWithIdWithAWhereUniqueInput!, create: AWithIdWithACreateInput!, update: AWithIdWithAUpdateInput!): AWithIdWithA!
  upsertBWithIdWithA(where: BWithIdWithAWhereUniqueInput!, create: BWithIdWithACreateInput!, update: BWithIdWithAUpdateInput!): BWithIdWithA!
  upsertCWithIdWithA(where: CWithIdWithAWhereUniqueInput!, create: CWithIdWithACreateInput!, update: CWithIdWithAUpdateInput!): CWithIdWithA!
  upsertAWithIdWithB(where: AWithIdWithBWhereUniqueInput!, create: AWithIdWithBCreateInput!, update: AWithIdWithBUpdateInput!): AWithIdWithB!
  upsertBWithIdWithB(where: BWithIdWithBWhereUniqueInput!, create: BWithIdWithBCreateInput!, update: BWithIdWithBUpdateInput!): BWithIdWithB!
  upsertCWithIdWithB(where: CWithIdWithBWhereUniqueInput!, create: CWithIdWithBCreateInput!, update: CWithIdWithBUpdateInput!): CWithIdWithB!
  upsertAWithIdWithC(where: AWithIdWithCWhereUniqueInput!, create: AWithIdWithCCreateInput!, update: AWithIdWithCUpdateInput!): AWithIdWithC!
  upsertBWithIdWithC(where: BWithIdWithCWhereUniqueInput!, create: BWithIdWithCCreateInput!, update: BWithIdWithCUpdateInput!): BWithIdWithC!
  upsertCWithIdWithC(where: CWithIdWithCWhereUniqueInput!, create: CWithIdWithCCreateInput!, update: CWithIdWithCUpdateInput!): CWithIdWithC!
  updateManyAWithIdWithAs(data: AWithIdWithAUpdateManyMutationInput!, where: AWithIdWithAWhereInput): BatchPayload!
  updateManyAWithoutIdWithAs(data: AWithoutIdWithAUpdateManyMutationInput!, where: AWithoutIdWithAWhereInput): BatchPayload!
  updateManyBWithIdWithAs(data: BWithIdWithAUpdateManyMutationInput!, where: BWithIdWithAWhereInput): BatchPayload!
  updateManyBWithoutIdWithAs(data: BWithoutIdWithAUpdateManyMutationInput!, where: BWithoutIdWithAWhereInput): BatchPayload!
  updateManyCWithIdWithAs(data: CWithIdWithAUpdateManyMutationInput!, where: CWithIdWithAWhereInput): BatchPayload!
  updateManyCWithoutIdWithAs(data: CWithoutIdWithAUpdateManyMutationInput!, where: CWithoutIdWithAWhereInput): BatchPayload!
  updateManyAWithIdWithBs(data: AWithIdWithBUpdateManyMutationInput!, where: AWithIdWithBWhereInput): BatchPayload!
  updateManyAWithoutIdWithBs(data: AWithoutIdWithBUpdateManyMutationInput!, where: AWithoutIdWithBWhereInput): BatchPayload!
  updateManyBWithIdWithBs(data: BWithIdWithBUpdateManyMutationInput!, where: BWithIdWithBWhereInput): BatchPayload!
  updateManyBWithoutIdWithBs(data: BWithoutIdWithBUpdateManyMutationInput!, where: BWithoutIdWithBWhereInput): BatchPayload!
  updateManyCWithIdWithBs(data: CWithIdWithBUpdateManyMutationInput!, where: CWithIdWithBWhereInput): BatchPayload!
  updateManyCWithoutIdWithBs(data: CWithoutIdWithBUpdateManyMutationInput!, where: CWithoutIdWithBWhereInput): BatchPayload!
  updateManyAWithIdWithCs(data: AWithIdWithCUpdateManyMutationInput!, where: AWithIdWithCWhereInput): BatchPayload!
  updateManyAWithoutIdWithCs(data: AWithoutIdWithCUpdateManyMutationInput!, where: AWithoutIdWithCWhereInput): BatchPayload!
  updateManyBWithIdWithCs(data: BWithIdWithCUpdateManyMutationInput!, where: BWithIdWithCWhereInput): BatchPayload!
  updateManyBWithoutIdWithCs(data: BWithoutIdWithCUpdateManyMutationInput!, where: BWithoutIdWithCWhereInput): BatchPayload!
  updateManyCWithIdWithCs(data: CWithIdWithCUpdateManyMutationInput!, where: CWithIdWithCWhereInput): BatchPayload!
  updateManyCWithoutIdWithCs(data: CWithoutIdWithCUpdateManyMutationInput!, where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithIdWithAs(where: AWithIdWithAWhereInput): BatchPayload!
  deleteManyAWithoutIdWithAs(where: AWithoutIdWithAWhereInput): BatchPayload!
  deleteManyBWithIdWithAs(where: BWithIdWithAWhereInput): BatchPayload!
  deleteManyBWithoutIdWithAs(where: BWithoutIdWithAWhereInput): BatchPayload!
  deleteManyCWithIdWithAs(where: CWithIdWithAWhereInput): BatchPayload!
  deleteManyCWithoutIdWithAs(where: CWithoutIdWithAWhereInput): BatchPayload!
  deleteManyAWithIdWithBs(where: AWithIdWithBWhereInput): BatchPayload!
  deleteManyAWithoutIdWithBs(where: AWithoutIdWithBWhereInput): BatchPayload!
  deleteManyBWithIdWithBs(where: BWithIdWithBWhereInput): BatchPayload!
  deleteManyBWithoutIdWithBs(where: BWithoutIdWithBWhereInput): BatchPayload!
  deleteManyCWithIdWithBs(where: CWithIdWithBWhereInput): BatchPayload!
  deleteManyCWithoutIdWithBs(where: CWithoutIdWithBWhereInput): BatchPayload!
  deleteManyAWithIdWithCs(where: AWithIdWithCWhereInput): BatchPayload!
  deleteManyAWithoutIdWithCs(where: AWithoutIdWithCWhereInput): BatchPayload!
  deleteManyBWithIdWithCs(where: BWithIdWithCWhereInput): BatchPayload!
  deleteManyBWithoutIdWithCs(where: BWithoutIdWithCWhereInput): BatchPayload!
  deleteManyCWithIdWithCs(where: CWithIdWithCWhereInput): BatchPayload!
  deleteManyCWithoutIdWithCs(where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithAs(where: AWithAWhereInput): BatchPayload!
  deleteManyAWithBs(where: AWithBWhereInput): BatchPayload!
  deleteManyAWithCs(where: AWithCWhereInput): BatchPayload!
  deleteManyBWithAs(where: BWithAWhereInput): BatchPayload!
  deleteManyBWithBs(where: BWithBWhereInput): BatchPayload!
  deleteManyBWithCs(where: BWithCWhereInput): BatchPayload!
  deleteManyCWithAs(where: CWithAWhereInput): BatchPayload!
  deleteManyCWithBs(where: CWithBWhereInput): BatchPayload!
  deleteManyCWithCs(where: CWithCWhereInput): BatchPayload!
  executeRaw(database: PrismaDatabase, query: String!): Json!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

enum PrismaDatabase {
  default
}

type Query {
  aWithIdWithAs(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithA]!
  aWithoutIdWithAs(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithA]!
  bWithIdWithAs(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithA]!
  bWithoutIdWithAs(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithA]!
  cWithIdWithAs(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithA]!
  cWithoutIdWithAs(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithA]!
  aWithIdWithBs(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithB]!
  aWithoutIdWithBs(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithB]!
  bWithIdWithBs(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithB]!
  bWithoutIdWithBs(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithB]!
  cWithIdWithBs(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithB]!
  cWithoutIdWithBs(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithB]!
  aWithIdWithCs(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC]!
  aWithoutIdWithCs(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC]!
  bWithIdWithCs(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC]!
  bWithoutIdWithCs(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC]!
  cWithIdWithCs(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC]!
  cWithoutIdWithCs(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC]!
  aWithAs(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithA]!
  aWithBs(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithB]!
  aWithCs(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC]!
  bWithAs(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithA]!
  bWithBs(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithB]!
  bWithCs(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC]!
  cWithAs(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithA]!
  cWithBs(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithB]!
  cWithCs(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC]!
  aWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  bWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  cWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  aWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  bWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  cWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  aWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  bWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  cWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  aWithIdWithAsConnection(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithAConnection!
  aWithoutIdWithAsConnection(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithAConnection!
  bWithIdWithAsConnection(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithAConnection!
  bWithoutIdWithAsConnection(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithAConnection!
  cWithIdWithAsConnection(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithAConnection!
  cWithoutIdWithAsConnection(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithAConnection!
  aWithIdWithBsConnection(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithBConnection!
  aWithoutIdWithBsConnection(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithBConnection!
  bWithIdWithBsConnection(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithBConnection!
  bWithoutIdWithBsConnection(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithBConnection!
  cWithIdWithBsConnection(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithBConnection!
  cWithoutIdWithBsConnection(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithBConnection!
  aWithIdWithCsConnection(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithCConnection!
  aWithoutIdWithCsConnection(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithCConnection!
  bWithIdWithCsConnection(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithCConnection!
  bWithoutIdWithCsConnection(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithCConnection!
  cWithIdWithCsConnection(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithCConnection!
  cWithoutIdWithCsConnection(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithCConnection!
  aWithAsConnection(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithAConnection!
  aWithBsConnection(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithBConnection!
  aWithCsConnection(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithCConnection!
  bWithAsConnection(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithAConnection!
  bWithBsConnection(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithBConnection!
  bWithCsConnection(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithCConnection!
  cWithAsConnection(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithAConnection!
  cWithBsConnection(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithBConnection!
  cWithCsConnection(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithCConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

type Subscription {
  aWithIdWithA(where: AWithIdWithASubscriptionWhereInput): AWithIdWithASubscriptionPayload
  aWithoutIdWithA(where: AWithoutIdWithASubscriptionWhereInput): AWithoutIdWithASubscriptionPayload
  bWithIdWithA(where: BWithIdWithASubscriptionWhereInput): BWithIdWithASubscriptionPayload
  bWithoutIdWithA(where: BWithoutIdWithASubscriptionWhereInput): BWithoutIdWithASubscriptionPayload
  cWithIdWithA(where: CWithIdWithASubscriptionWhereInput): CWithIdWithASubscriptionPayload
  cWithoutIdWithA(where: CWithoutIdWithASubscriptionWhereInput): CWithoutIdWithASubscriptionPayload
  aWithIdWithB(where: AWithIdWithBSubscriptionWhereInput): AWithIdWithBSubscriptionPayload
  aWithoutIdWithB(where: AWithoutIdWithBSubscriptionWhereInput): AWithoutIdWithBSubscriptionPayload
  bWithIdWithB(where: BWithIdWithBSubscriptionWhereInput): BWithIdWithBSubscriptionPayload
  bWithoutIdWithB(where: BWithoutIdWithBSubscriptionWhereInput): BWithoutIdWithBSubscriptionPayload
  cWithIdWithB(where: CWithIdWithBSubscriptionWhereInput): CWithIdWithBSubscriptionPayload
  cWithoutIdWithB(where: CWithoutIdWithBSubscriptionWhereInput): CWithoutIdWithBSubscriptionPayload
  aWithIdWithC(where: AWithIdWithCSubscriptionWhereInput): AWithIdWithCSubscriptionPayload
  aWithoutIdWithC(where: AWithoutIdWithCSubscriptionWhereInput): AWithoutIdWithCSubscriptionPayload
  bWithIdWithC(where: BWithIdWithCSubscriptionWhereInput): BWithIdWithCSubscriptionPayload
  bWithoutIdWithC(where: BWithoutIdWithCSubscriptionWhereInput): BWithoutIdWithCSubscriptionPayload
  cWithIdWithC(where: CWithIdWithCSubscriptionWhereInput): CWithIdWithCSubscriptionPayload
  cWithoutIdWithC(where: CWithoutIdWithCSubscriptionWhereInput): CWithoutIdWithCSubscriptionPayload
  aWithA(where: AWithASubscriptionWhereInput): AWithASubscriptionPayload
  aWithB(where: AWithBSubscriptionWhereInput): AWithBSubscriptionPayload
  aWithC(where: AWithCSubscriptionWhereInput): AWithCSubscriptionPayload
  bWithA(where: BWithASubscriptionWhereInput): BWithASubscriptionPayload
  bWithB(where: BWithBSubscriptionWhereInput): BWithBSubscriptionPayload
  bWithC(where: BWithCSubscriptionWhereInput): BWithCSubscriptionPayload
  cWithA(where: CWithASubscriptionWhereInput): CWithASubscriptionPayload
  cWithB(where: CWithBSubscriptionWhereInput): CWithBSubscriptionPayload
  cWithC(where: CWithCSubscriptionWhereInput): CWithCSubscriptionPayload
}

type AggregateAWithA {
  count: Int!
}

type AggregateAWithB {
  count: Int!
}

type AggregateAWithC {
  count: Int!
}

type AggregateAWithIdWithA {
  count: Int!
}

type AggregateAWithIdWithB {
  count: Int!
}

type AggregateAWithIdWithC {
  count: Int!
}

type AggregateAWithoutIdWithA {
  count: Int!
}

type AggregateAWithoutIdWithB {
  count: Int!
}

type AggregateAWithoutIdWithC {
  count: Int!
}

type AggregateBWithA {
  count: Int!
}

type AggregateBWithB {
  count: Int!
}

type AggregateBWithC {
  count: Int!
}

type AggregateBWithIdWithA {
  count: Int!
}

type AggregateBWithIdWithB {
  count: Int!
}

type AggregateBWithIdWithC {
  count: Int!
}

type AggregateBWithoutIdWithA {
  count: Int!
}

type AggregateBWithoutIdWithB {
  count: Int!
}

type AggregateBWithoutIdWithC {
  count: Int!
}

type AggregateCWithA {
  count: Int!
}

type AggregateCWithB {
  count: Int!
}

type AggregateCWithC {
  count: Int!
}

type AggregateCWithIdWithA {
  count: Int!
}

type AggregateCWithIdWithB {
  count: Int!
}

type AggregateCWithIdWithC {
  count: Int!
}

type AggregateCWithoutIdWithA {
  count: Int!
}

type AggregateCWithoutIdWithB {
  count: Int!
}

type AggregateCWithoutIdWithC {
  count: Int!
}

type AWithA {
  x: AWithIdWithA!
  y: AWithoutIdWithA!
}

"""
A connection to a list of items.
"""
type AWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithAEdge]!
  aggregate: AggregateAWithA!
}

input AWithACreateInput {
  x: AWithIdWithACreateOneWithoutXInput!
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateOneWithoutXInput {
  create: AWithACreateWithoutXInput
}

input AWithACreateOneWithoutYInput {
  create: AWithACreateWithoutYInput
}

input AWithACreateWithoutXInput {
  y: AWithoutIdWithACreateOneWithoutXInput!
}

input AWithACreateWithoutYInput {
  x: AWithIdWithACreateOneWithoutXInput!
}

"""
An edge in a connection.
"""
type AWithAEdge {
  """
  The item at the end of the edge.
  """
  node: AWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithAOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithA
  updatedFields: [String!]
}

input AWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithAWhereInput
}

input AWithAUpdateOneRequiredWithoutXInput {
  create: AWithACreateWithoutXInput
  update: AWithAUpdateWithoutXDataInput
  upsert: AWithAUpsertWithoutXInput
}

input AWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithAUpsertWithoutXInput {
  update: AWithAUpdateWithoutXDataInput!
  create: AWithACreateWithoutXInput!
}

input AWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithAWhereInput!]
  x: AWithIdWithAWhereInput
  y: AWithoutIdWithAWhereInput
}

type AWithB {
  x: BWithIdWithA!
  y: BWithoutIdWithA!
}

"""
A connection to a list of items.
"""
type AWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithBEdge]!
  aggregate: AggregateAWithB!
}

input AWithBCreateInput {
  x: BWithIdWithACreateOneWithoutXInput!
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
}

input AWithBCreateOneWithoutYInput {
  create: AWithBCreateWithoutYInput
}

input AWithBCreateWithoutXInput {
  y: BWithoutIdWithACreateOneWithoutXInput!
}

input AWithBCreateWithoutYInput {
  x: BWithIdWithACreateOneWithoutXInput!
}

"""
An edge in a connection.
"""
type AWithBEdge {
  """
  The item at the end of the edge.
  """
  node: AWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithBOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithB
  updatedFields: [String!]
}

input AWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithBWhereInput
}

input AWithBUpdateOneWithoutXInput {
  create: AWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: AWithBUpdateWithoutXDataInput
  upsert: AWithBUpsertWithoutXInput
}

input AWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithAUpdateOneRequiredWithoutXInput
}

input AWithBUpsertWithoutXInput {
  update: AWithBUpdateWithoutXDataInput!
  create: AWithBCreateWithoutXInput!
}

input AWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithBWhereInput!]
  x: BWithIdWithAWhereInput
  y: BWithoutIdWithAWhereInput
}

type AWithC {
  x: CWithIdWithA!
  y: CWithoutIdWithA!
}

"""
A connection to a list of items.
"""
type AWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithCEdge]!
  aggregate: AggregateAWithC!
}

input AWithCCreateInput {
  x: CWithIdWithACreateOneWithoutXInput!
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
}

input AWithCCreateManyWithoutYInput {
  create: [AWithCCreateWithoutYInput!]
}

input AWithCCreateWithoutXInput {
  y: CWithoutIdWithACreateOneWithoutXInput!
}

input AWithCCreateWithoutYInput {
  x: CWithIdWithACreateOneWithoutXInput!
}

"""
An edge in a connection.
"""
type AWithCEdge {
  """
  The item at the end of the edge.
  """
  node: AWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithCOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithC
  updatedFields: [String!]
}

input AWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithCWhereInput
}

input AWithCUpdateManyWithoutXInput {
  create: [AWithCCreateWithoutXInput!]
}

input AWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithCWhereInput!]
  x: CWithIdWithAWhereInput
  y: CWithoutIdWithAWhereInput
}

type AWithIdWithA implements Node {
  id: ID!
  field: String!
  x: AWithA!
}

"""
A connection to a list of items.
"""
type AWithIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithIdWithAEdge]!
  aggregate: AggregateAWithIdWithA!
}

input AWithIdWithACreateInput {
  field: String!
  x: AWithACreateOneWithoutXInput!
}

input AWithIdWithACreateOneWithoutXInput {
  create: AWithIdWithACreateWithoutXInput
  connect: AWithIdWithAWhereUniqueInput
}

input AWithIdWithACreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type AWithIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: AWithIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithA
  updatedFields: [String!]
  previousValues: AWithIdWithAPreviousValues
}

input AWithIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithAWhereInput
}

input AWithIdWithAUpdateInput {
  field: String
  x: AWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithAUpdateManyMutationInput {
  field: String
}

input AWithIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithAWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithAWhereInput
}

input AWithIdWithAWhereUniqueInput {
  id: ID
}

type AWithIdWithB implements Node {
  id: ID!
  field: String!
  x: BWithA!
}

"""
A connection to a list of items.
"""
type AWithIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithIdWithBEdge]!
  aggregate: AggregateAWithIdWithB!
}

input AWithIdWithBCreateInput {
  field: String!
  x: BWithACreateOneWithoutXInput!
}

input AWithIdWithBCreateOneWithoutXInput {
  create: AWithIdWithBCreateWithoutXInput
  connect: AWithIdWithBWhereUniqueInput
}

input AWithIdWithBCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type AWithIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: AWithIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithB
  updatedFields: [String!]
  previousValues: AWithIdWithBPreviousValues
}

input AWithIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithBWhereInput
}

input AWithIdWithBUpdateInput {
  field: String
  x: BWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithBUpdateManyMutationInput {
  field: String
}

input AWithIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithBWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithAWhereInput
}

input AWithIdWithBWhereUniqueInput {
  id: ID
}

type AWithIdWithC implements Node {
  id: ID!
  field: String!
  x: CWithA!
}

"""
A connection to a list of items.
"""
type AWithIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithIdWithCEdge]!
  aggregate: AggregateAWithIdWithC!
}

input AWithIdWithCCreateInput {
  field: String!
  x: CWithACreateOneWithoutXInput!
}

input AWithIdWithCCreateManyWithoutXInput {
  create: [AWithIdWithCCreateWithoutXInput!]
  connect: [AWithIdWithCWhereUniqueInput!]
}

input AWithIdWithCCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type AWithIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: AWithIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type AWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithIdWithC
  updatedFields: [String!]
  previousValues: AWithIdWithCPreviousValues
}

input AWithIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithIdWithCWhereInput
}

input AWithIdWithCUpdateInput {
  field: String
  x: CWithAUpdateOneRequiredWithoutXInput
}

input AWithIdWithCUpdateManyMutationInput {
  field: String
}

input AWithIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithIdWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithIdWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithIdWithCWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithAWhereInput
}

input AWithIdWithCWhereUniqueInput {
  id: ID
}

type AWithoutIdWithA {
  field: String!
  x: AWithA!
}

"""
A connection to a list of items.
"""
type AWithoutIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithoutIdWithAEdge]!
  aggregate: AggregateAWithoutIdWithA!
}

input AWithoutIdWithACreateInput {
  field: String!
  x: AWithACreateOneWithoutYInput!
}

input AWithoutIdWithACreateOneWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
}

input AWithoutIdWithACreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type AWithoutIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: AWithoutIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithoutIdWithAPreviousValues {
  field: String!
}

type AWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithA
  updatedFields: [String!]
  previousValues: AWithoutIdWithAPreviousValues
}

input AWithoutIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithAWhereInput
}

input AWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: AWithoutIdWithACreateWithoutXInput
  update: AWithoutIdWithAUpdateWithoutXDataInput
  upsert: AWithoutIdWithAUpsertWithoutXInput
}

input AWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithAUpsertWithoutXInput {
  update: AWithoutIdWithAUpdateWithoutXDataInput!
  create: AWithoutIdWithACreateWithoutXInput!
}

input AWithoutIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithAWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithAWhereInput
}

type AWithoutIdWithB {
  field: String!
  x: BWithA!
}

"""
A connection to a list of items.
"""
type AWithoutIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithoutIdWithBEdge]!
  aggregate: AggregateAWithoutIdWithB!
}

input AWithoutIdWithBCreateInput {
  field: String!
  x: BWithACreateOneWithoutYInput!
}

input AWithoutIdWithBCreateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
}

input AWithoutIdWithBCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type AWithoutIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: AWithoutIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithoutIdWithBPreviousValues {
  field: String!
}

type AWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithB
  updatedFields: [String!]
  previousValues: AWithoutIdWithBPreviousValues
}

input AWithoutIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithBWhereInput
}

input AWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithBUpdateOneWithoutXInput {
  create: AWithoutIdWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: AWithoutIdWithBUpdateWithoutXDataInput
  upsert: AWithoutIdWithBUpsertWithoutXInput
}

input AWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input AWithoutIdWithBUpsertWithoutXInput {
  update: AWithoutIdWithBUpdateWithoutXDataInput!
  create: AWithoutIdWithBCreateWithoutXInput!
}

input AWithoutIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithBWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithAWhereInput
}

type AWithoutIdWithC {
  field: String!
  x: CWithA!
}

"""
A connection to a list of items.
"""
type AWithoutIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [AWithoutIdWithCEdge]!
  aggregate: AggregateAWithoutIdWithC!
}

input AWithoutIdWithCCreateInput {
  field: String!
  x: CWithACreateOneWithoutYInput!
}

input AWithoutIdWithCCreateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
}

input AWithoutIdWithCCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type AWithoutIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: AWithoutIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum AWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AWithoutIdWithCPreviousValues {
  field: String!
}

input AWithoutIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithCScalarWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type AWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: AWithoutIdWithC
  updatedFields: [String!]
  previousValues: AWithoutIdWithCPreviousValues
}

input AWithoutIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AWithoutIdWithCWhereInput
}

input AWithoutIdWithCUpdateManyDataInput {
  field: String
}

input AWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input AWithoutIdWithCUpdateManyWithoutXInput {
  create: [AWithoutIdWithCCreateWithoutXInput!]
  updateMany: [AWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [AWithoutIdWithCScalarWhereInput!]
}

input AWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: AWithoutIdWithCScalarWhereInput!
  data: AWithoutIdWithCUpdateManyDataInput!
}

input AWithoutIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [AWithoutIdWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [AWithoutIdWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [AWithoutIdWithCWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithAWhereInput
}

type BatchPayload {
  """
  The number of nodes that have been affected by the Batch operation.
  """
  count: Long!
}

type BWithA {
  x: AWithIdWithB
  y: AWithoutIdWithB
}

"""
A connection to a list of items.
"""
type BWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithAEdge]!
  aggregate: AggregateBWithA!
}

input BWithACreateInput {
  x: AWithIdWithBCreateOneWithoutXInput
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateOneWithoutXInput {
  create: BWithACreateWithoutXInput
}

input BWithACreateOneWithoutYInput {
  create: BWithACreateWithoutYInput
}

input BWithACreateWithoutXInput {
  y: AWithoutIdWithBCreateOneWithoutXInput
}

input BWithACreateWithoutYInput {
  x: AWithIdWithBCreateOneWithoutXInput
}

"""
An edge in a connection.
"""
type BWithAEdge {
  """
  The item at the end of the edge.
  """
  node: BWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithAOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithA
  updatedFields: [String!]
}

input BWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithAWhereInput
}

input BWithAUpdateOneRequiredWithoutXInput {
  create: BWithACreateWithoutXInput
  update: BWithAUpdateWithoutXDataInput
  upsert: BWithAUpsertWithoutXInput
}

input BWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithBUpdateOneWithoutXInput
}

input BWithAUpsertWithoutXInput {
  update: BWithAUpdateWithoutXDataInput!
  create: BWithACreateWithoutXInput!
}

input BWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithAWhereInput!]
  x: AWithIdWithBWhereInput
  y: AWithoutIdWithBWhereInput
}

type BWithB {
  x: BWithIdWithB
  y: BWithoutIdWithB
}

"""
A connection to a list of items.
"""
type BWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithBEdge]!
  aggregate: AggregateBWithB!
}

input BWithBCreateInput {
  x: BWithIdWithBCreateOneWithoutXInput
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
}

input BWithBCreateOneWithoutYInput {
  create: BWithBCreateWithoutYInput
}

input BWithBCreateWithoutXInput {
  y: BWithoutIdWithBCreateOneWithoutXInput
}

input BWithBCreateWithoutYInput {
  x: BWithIdWithBCreateOneWithoutXInput
}

"""
An edge in a connection.
"""
type BWithBEdge {
  """
  The item at the end of the edge.
  """
  node: BWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithBOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithB
  updatedFields: [String!]
}

input BWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithBWhereInput
}

input BWithBUpdateOneWithoutXInput {
  create: BWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: BWithBUpdateWithoutXDataInput
  upsert: BWithBUpsertWithoutXInput
}

input BWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithBUpdateOneWithoutXInput
}

input BWithBUpsertWithoutXInput {
  update: BWithBUpdateWithoutXDataInput!
  create: BWithBCreateWithoutXInput!
}

input BWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithBWhereInput!]
  x: BWithIdWithBWhereInput
  y: BWithoutIdWithBWhereInput
}

type BWithC {
  x: CWithIdWithB
  y: CWithoutIdWithB
}

"""
A connection to a list of items.
"""
type BWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithCEdge]!
  aggregate: AggregateBWithC!
}

input BWithCCreateInput {
  x: CWithIdWithBCreateOneWithoutXInput
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
}

input BWithCCreateManyWithoutYInput {
  create: [BWithCCreateWithoutYInput!]
}

input BWithCCreateWithoutXInput {
  y: CWithoutIdWithBCreateOneWithoutXInput
}

input BWithCCreateWithoutYInput {
  x: CWithIdWithBCreateOneWithoutXInput
}

"""
An edge in a connection.
"""
type BWithCEdge {
  """
  The item at the end of the edge.
  """
  node: BWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithCOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithC
  updatedFields: [String!]
}

input BWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithCWhereInput
}

input BWithCUpdateManyWithoutXInput {
  create: [BWithCCreateWithoutXInput!]
}

input BWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithCWhereInput!]
  x: CWithIdWithBWhereInput
  y: CWithoutIdWithBWhereInput
}

type BWithIdWithA implements Node {
  id: ID!
  field: String!
  x: AWithB
}

"""
A connection to a list of items.
"""
type BWithIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithIdWithAEdge]!
  aggregate: AggregateBWithIdWithA!
}

input BWithIdWithACreateInput {
  field: String!
  x: AWithBCreateOneWithoutXInput
}

input BWithIdWithACreateOneWithoutXInput {
  create: BWithIdWithACreateWithoutXInput
  connect: BWithIdWithAWhereUniqueInput
}

input BWithIdWithACreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type BWithIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: BWithIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithA
  updatedFields: [String!]
  previousValues: BWithIdWithAPreviousValues
}

input BWithIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithAWhereInput
}

input BWithIdWithAUpdateInput {
  field: String
  x: AWithBUpdateOneWithoutXInput
}

input BWithIdWithAUpdateManyMutationInput {
  field: String
}

input BWithIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithAWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithBWhereInput
}

input BWithIdWithAWhereUniqueInput {
  id: ID
}

type BWithIdWithB implements Node {
  id: ID!
  field: String!
  x: BWithB
}

"""
A connection to a list of items.
"""
type BWithIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithIdWithBEdge]!
  aggregate: AggregateBWithIdWithB!
}

input BWithIdWithBCreateInput {
  field: String!
  x: BWithBCreateOneWithoutXInput
}

input BWithIdWithBCreateOneWithoutXInput {
  create: BWithIdWithBCreateWithoutXInput
  connect: BWithIdWithBWhereUniqueInput
}

input BWithIdWithBCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type BWithIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: BWithIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithB
  updatedFields: [String!]
  previousValues: BWithIdWithBPreviousValues
}

input BWithIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithBWhereInput
}

input BWithIdWithBUpdateInput {
  field: String
  x: BWithBUpdateOneWithoutXInput
}

input BWithIdWithBUpdateManyMutationInput {
  field: String
}

input BWithIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithBWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithBWhereInput
}

input BWithIdWithBWhereUniqueInput {
  id: ID
}

type BWithIdWithC implements Node {
  id: ID!
  field: String!
  x: CWithB
}

"""
A connection to a list of items.
"""
type BWithIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithIdWithCEdge]!
  aggregate: AggregateBWithIdWithC!
}

input BWithIdWithCCreateInput {
  field: String!
  x: CWithBCreateOneWithoutXInput
}

input BWithIdWithCCreateManyWithoutXInput {
  create: [BWithIdWithCCreateWithoutXInput!]
  connect: [BWithIdWithCWhereUniqueInput!]
}

input BWithIdWithCCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type BWithIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: BWithIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type BWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithIdWithC
  updatedFields: [String!]
  previousValues: BWithIdWithCPreviousValues
}

input BWithIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithIdWithCWhereInput
}

input BWithIdWithCUpdateInput {
  field: String
  x: CWithBUpdateOneWithoutXInput
}

input BWithIdWithCUpdateManyMutationInput {
  field: String
}

input BWithIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithIdWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithIdWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithIdWithCWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithBWhereInput
}

input BWithIdWithCWhereUniqueInput {
  id: ID
}

type BWithoutIdWithA {
  field: String!
  x: AWithB
}

"""
A connection to a list of items.
"""
type BWithoutIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithoutIdWithAEdge]!
  aggregate: AggregateBWithoutIdWithA!
}

input BWithoutIdWithACreateInput {
  field: String!
  x: AWithBCreateOneWithoutYInput
}

input BWithoutIdWithACreateOneWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
}

input BWithoutIdWithACreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type BWithoutIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: BWithoutIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithoutIdWithAPreviousValues {
  field: String!
}

type BWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithA
  updatedFields: [String!]
  previousValues: BWithoutIdWithAPreviousValues
}

input BWithoutIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithAWhereInput
}

input BWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithAUpdateOneRequiredWithoutXInput {
  create: BWithoutIdWithACreateWithoutXInput
  update: BWithoutIdWithAUpdateWithoutXDataInput
  upsert: BWithoutIdWithAUpsertWithoutXInput
}

input BWithoutIdWithAUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithAUpsertWithoutXInput {
  update: BWithoutIdWithAUpdateWithoutXDataInput!
  create: BWithoutIdWithACreateWithoutXInput!
}

input BWithoutIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithAWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: AWithBWhereInput
}

type BWithoutIdWithB {
  field: String!
  x: BWithB
}

"""
A connection to a list of items.
"""
type BWithoutIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithoutIdWithBEdge]!
  aggregate: AggregateBWithoutIdWithB!
}

input BWithoutIdWithBCreateInput {
  field: String!
  x: BWithBCreateOneWithoutYInput
}

input BWithoutIdWithBCreateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
}

input BWithoutIdWithBCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type BWithoutIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: BWithoutIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithoutIdWithBPreviousValues {
  field: String!
}

type BWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithB
  updatedFields: [String!]
  previousValues: BWithoutIdWithBPreviousValues
}

input BWithoutIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithBWhereInput
}

input BWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithBUpdateOneWithoutXInput {
  create: BWithoutIdWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: BWithoutIdWithBUpdateWithoutXDataInput
  upsert: BWithoutIdWithBUpsertWithoutXInput
}

input BWithoutIdWithBUpdateWithoutXDataInput {
  field: String
}

input BWithoutIdWithBUpsertWithoutXInput {
  update: BWithoutIdWithBUpdateWithoutXDataInput!
  create: BWithoutIdWithBCreateWithoutXInput!
}

input BWithoutIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithBWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: BWithBWhereInput
}

type BWithoutIdWithC {
  field: String!
  x: CWithB
}

"""
A connection to a list of items.
"""
type BWithoutIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [BWithoutIdWithCEdge]!
  aggregate: AggregateBWithoutIdWithC!
}

input BWithoutIdWithCCreateInput {
  field: String!
  x: CWithBCreateOneWithoutYInput
}

input BWithoutIdWithCCreateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
}

input BWithoutIdWithCCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type BWithoutIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: BWithoutIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum BWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BWithoutIdWithCPreviousValues {
  field: String!
}

input BWithoutIdWithCScalarWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithCScalarWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithCScalarWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithCScalarWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
}

type BWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: BWithoutIdWithC
  updatedFields: [String!]
  previousValues: BWithoutIdWithCPreviousValues
}

input BWithoutIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BWithoutIdWithCWhereInput
}

input BWithoutIdWithCUpdateManyDataInput {
  field: String
}

input BWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input BWithoutIdWithCUpdateManyWithoutXInput {
  create: [BWithoutIdWithCCreateWithoutXInput!]
  updateMany: [BWithoutIdWithCUpdateManyWithWhereNestedInput!]
  deleteMany: [BWithoutIdWithCScalarWhereInput!]
}

input BWithoutIdWithCUpdateManyWithWhereNestedInput {
  where: BWithoutIdWithCScalarWhereInput!
  data: BWithoutIdWithCUpdateManyDataInput!
}

input BWithoutIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [BWithoutIdWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [BWithoutIdWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [BWithoutIdWithCWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x: CWithBWhereInput
}

type CWithA {
  x(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC!]
  y(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC!]
}

"""
A connection to a list of items.
"""
type CWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithAEdge]!
  aggregate: AggregateCWithA!
}

input CWithACreateInput {
  x: AWithIdWithCCreateManyWithoutXInput
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateOneWithoutXInput {
  create: CWithACreateWithoutXInput
}

input CWithACreateOneWithoutYInput {
  create: CWithACreateWithoutYInput
}

input CWithACreateWithoutXInput {
  y: AWithoutIdWithCCreateManyWithoutXInput
}

input CWithACreateWithoutYInput {
  x: AWithIdWithCCreateManyWithoutXInput
}

"""
An edge in a connection.
"""
type CWithAEdge {
  """
  The item at the end of the edge.
  """
  node: CWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithAOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithA
  updatedFields: [String!]
}

input CWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithAWhereInput
}

input CWithAUpdateOneRequiredWithoutXInput {
  create: CWithACreateWithoutXInput
  update: CWithAUpdateWithoutXDataInput
  upsert: CWithAUpsertWithoutXInput
}

input CWithAUpdateWithoutXDataInput {
  y: AWithoutIdWithCUpdateManyWithoutXInput
}

input CWithAUpsertWithoutXInput {
  update: CWithAUpdateWithoutXDataInput!
  create: CWithACreateWithoutXInput!
}

input CWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithAWhereInput!]
  x_every: AWithIdWithCWhereInput
  x_some: AWithIdWithCWhereInput
  x_none: AWithIdWithCWhereInput
  y_every: AWithoutIdWithCWhereInput
  y_some: AWithoutIdWithCWhereInput
  y_none: AWithoutIdWithCWhereInput
}

type CWithB {
  x(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC!]
  y(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC!]
}

"""
A connection to a list of items.
"""
type CWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithBEdge]!
  aggregate: AggregateCWithB!
}

input CWithBCreateInput {
  x: BWithIdWithCCreateManyWithoutXInput
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
}

input CWithBCreateOneWithoutYInput {
  create: CWithBCreateWithoutYInput
}

input CWithBCreateWithoutXInput {
  y: BWithoutIdWithCCreateManyWithoutXInput
}

input CWithBCreateWithoutYInput {
  x: BWithIdWithCCreateManyWithoutXInput
}

"""
An edge in a connection.
"""
type CWithBEdge {
  """
  The item at the end of the edge.
  """
  node: CWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithBOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithB
  updatedFields: [String!]
}

input CWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithBWhereInput
}

input CWithBUpdateOneWithoutXInput {
  create: CWithBCreateWithoutXInput
  disconnect: Boolean
  delete: Boolean
  update: CWithBUpdateWithoutXDataInput
  upsert: CWithBUpsertWithoutXInput
}

input CWithBUpdateWithoutXDataInput {
  y: BWithoutIdWithCUpdateManyWithoutXInput
}

input CWithBUpsertWithoutXInput {
  update: CWithBUpdateWithoutXDataInput!
  create: CWithBCreateWithoutXInput!
}

input CWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithBWhereInput!]
  x_every: BWithIdWithCWhereInput
  x_some: BWithIdWithCWhereInput
  x_none: BWithIdWithCWhereInput
  y_every: BWithoutIdWithCWhereInput
  y_some: BWithoutIdWithCWhereInput
  y_none: BWithoutIdWithCWhereInput
}

type CWithC {
  x(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC!]
  y(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC!]
}

"""
A connection to a list of items.
"""
type CWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithCEdge]!
  aggregate: AggregateCWithC!
}

input CWithCCreateInput {
  x: CWithIdWithCCreateManyWithoutXInput
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
}

input CWithCCreateManyWithoutYInput {
  create: [CWithCCreateWithoutYInput!]
}

input CWithCCreateWithoutXInput {
  y: CWithoutIdWithCCreateManyWithoutXInput
}

input CWithCCreateWithoutYInput {
  x: CWithIdWithCCreateManyWithoutXInput
}

"""
An edge in a connection.
"""
type CWithCEdge {
  """
  The item at the end of the edge.
  """
  node: CWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithCOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithC
  updatedFields: [String!]
}

input CWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithCWhereInput
}

input CWithCUpdateManyWithoutXInput {
  create: [CWithCCreateWithoutXInput!]
}

input CWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithCWhereInput!]
  x_every: CWithIdWithCWhereInput
  x_some: CWithIdWithCWhereInput
  x_none: CWithIdWithCWhereInput
  y_every: CWithoutIdWithCWhereInput
  y_some: CWithoutIdWithCWhereInput
  y_none: CWithoutIdWithCWhereInput
}

type CWithIdWithA implements Node {
  id: ID!
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

"""
A connection to a list of items.
"""
type CWithIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithIdWithAEdge]!
  aggregate: AggregateCWithIdWithA!
}

input CWithIdWithACreateInput {
  field: String!
  x: AWithCCreateManyWithoutXInput
}

input CWithIdWithACreateOneWithoutXInput {
  create: CWithIdWithACreateWithoutXInput
  connect: CWithIdWithAWhereUniqueInput
}

input CWithIdWithACreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type CWithIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: CWithIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithIdWithAOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithIdWithAPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithA
  updatedFields: [String!]
  previousValues: CWithIdWithAPreviousValues
}

input CWithIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithAWhereInput
}

input CWithIdWithAUpdateInput {
  field: String
  x: AWithCUpdateManyWithoutXInput
}

input CWithIdWithAUpdateManyMutationInput {
  field: String
}

input CWithIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithAWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_every: AWithCWhereInput
  x_some: AWithCWhereInput
  x_none: AWithCWhereInput
}

input CWithIdWithAWhereUniqueInput {
  id: ID
}

type CWithIdWithB implements Node {
  id: ID!
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

"""
A connection to a list of items.
"""
type CWithIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithIdWithBEdge]!
  aggregate: AggregateCWithIdWithB!
}

input CWithIdWithBCreateInput {
  field: String!
  x: BWithCCreateManyWithoutXInput
}

input CWithIdWithBCreateOneWithoutXInput {
  create: CWithIdWithBCreateWithoutXInput
  connect: CWithIdWithBWhereUniqueInput
}

input CWithIdWithBCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type CWithIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: CWithIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithIdWithBOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithIdWithBPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithB
  updatedFields: [String!]
  previousValues: CWithIdWithBPreviousValues
}

input CWithIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithBWhereInput
}

input CWithIdWithBUpdateInput {
  field: String
  x: BWithCUpdateManyWithoutXInput
}

input CWithIdWithBUpdateManyMutationInput {
  field: String
}

input CWithIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithBWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_every: BWithCWhereInput
  x_some: BWithCWhereInput
  x_none: BWithCWhereInput
}

input CWithIdWithBWhereUniqueInput {
  id: ID
}

type CWithIdWithC implements Node {
  id: ID!
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

"""
A connection to a list of items.
"""
type CWithIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithIdWithCEdge]!
  aggregate: AggregateCWithIdWithC!
}

input CWithIdWithCCreateInput {
  field: String!
  x: CWithCCreateManyWithoutXInput
}

input CWithIdWithCCreateManyWithoutXInput {
  create: [CWithIdWithCCreateWithoutXInput!]
  connect: [CWithIdWithCWhereUniqueInput!]
}

input CWithIdWithCCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type CWithIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: CWithIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithIdWithCOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithIdWithCPreviousValues {
  id: ID!
  field: String!
}

type CWithIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithIdWithC
  updatedFields: [String!]
  previousValues: CWithIdWithCPreviousValues
}

input CWithIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithIdWithCWhereInput
}

input CWithIdWithCUpdateInput {
  field: String
  x: CWithCUpdateManyWithoutXInput
}

input CWithIdWithCUpdateManyMutationInput {
  field: String
}

input CWithIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithIdWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithIdWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithIdWithCWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_every: CWithCWhereInput
  x_some: CWithCWhereInput
  x_none: CWithCWhereInput
}

input CWithIdWithCWhereUniqueInput {
  id: ID
}

type CWithoutIdWithA {
  field: String!
  x(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC!]
}

"""
A connection to a list of items.
"""
type CWithoutIdWithAConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithoutIdWithAEdge]!
  aggregate: AggregateCWithoutIdWithA!
}

input CWithoutIdWithACreateInput {
  field: String!
  x: AWithCCreateManyWithoutYInput
}

input CWithoutIdWithACreateOneWithoutXInput {
  create: CWithoutIdWithACreateWithoutXInput
}

input CWithoutIdWithACreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type CWithoutIdWithAEdge {
  """
  The item at the end of the edge.
  """
  node: CWithoutIdWithA!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithoutIdWithAOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithoutIdWithAPreviousValues {
  field: String!
}

type CWithoutIdWithASubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithA
  updatedFields: [String!]
  previousValues: CWithoutIdWithAPreviousValues
}

input CWithoutIdWithASubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithASubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithASubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithASubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithAWhereInput
}

input CWithoutIdWithAUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithAWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithAWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithAWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithAWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_every: AWithCWhereInput
  x_some: AWithCWhereInput
  x_none: AWithCWhereInput
}

type CWithoutIdWithB {
  field: String!
  x(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC!]
}

"""
A connection to a list of items.
"""
type CWithoutIdWithBConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithoutIdWithBEdge]!
  aggregate: AggregateCWithoutIdWithB!
}

input CWithoutIdWithBCreateInput {
  field: String!
  x: BWithCCreateManyWithoutYInput
}

input CWithoutIdWithBCreateOneWithoutXInput {
  create: CWithoutIdWithBCreateWithoutXInput
}

input CWithoutIdWithBCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type CWithoutIdWithBEdge {
  """
  The item at the end of the edge.
  """
  node: CWithoutIdWithB!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithoutIdWithBOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithoutIdWithBPreviousValues {
  field: String!
}

type CWithoutIdWithBSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithB
  updatedFields: [String!]
  previousValues: CWithoutIdWithBPreviousValues
}

input CWithoutIdWithBSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithBSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithBSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithBSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithBWhereInput
}

input CWithoutIdWithBUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithBWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithBWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithBWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithBWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_every: BWithCWhereInput
  x_some: BWithCWhereInput
  x_none: BWithCWhereInput
}

type CWithoutIdWithC {
  field: String!
  x(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC!]
}

"""
A connection to a list of items.
"""
type CWithoutIdWithCConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [CWithoutIdWithCEdge]!
  aggregate: AggregateCWithoutIdWithC!
}

input CWithoutIdWithCCreateInput {
  field: String!
  x: CWithCCreateManyWithoutYInput
}

input CWithoutIdWithCCreateManyWithoutXInput {
  create: [CWithoutIdWithCCreateWithoutXInput!]
}

input CWithoutIdWithCCreateWithoutXInput {
  field: String!
}

"""
An edge in a connection.
"""
type CWithoutIdWithCEdge {
  """
  The item at the end of the edge.
  """
  node: CWithoutIdWithC!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum CWithoutIdWithCOrderByInput {
  field_ASC
  field_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CWithoutIdWithCPreviousValues {
  field: String!
}

type CWithoutIdWithCSubscriptionPayload {
  mutation: MutationType!
  node: CWithoutIdWithC
  updatedFields: [String!]
  previousValues: CWithoutIdWithCPreviousValues
}

input CWithoutIdWithCSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithCSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithCSubscriptionWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithCSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CWithoutIdWithCWhereInput
}

input CWithoutIdWithCUpdateManyMutationInput {
  field: String
}

input CWithoutIdWithCWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [CWithoutIdWithCWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [CWithoutIdWithCWhereInput!]
  """
  Logical NOT on all given filters combined by AND.
  """
  NOT: [CWithoutIdWithCWhereInput!]
  field: String
  """
  All values that are not equal to given value.
  """
  field_not: String
  """
  All values that are contained in given list.
  """
  field_in: [String!]
  """
  All values that are not contained in given list.
  """
  field_not_in: [String!]
  """
  All values less than the given value.
  """
  field_lt: String
  """
  All values less than or equal the given value.
  """
  field_lte: String
  """
  All values greater than the given value.
  """
  field_gt: String
  """
  All values greater than or equal the given value.
  """
  field_gte: String
  """
  All values containing the given string.
  """
  field_contains: String
  """
  All values not containing the given string.
  """
  field_not_contains: String
  """
  All values starting with the given string.
  """
  field_starts_with: String
  """
  All values not starting with the given string.
  """
  field_not_starts_with: String
  """
  All values ending with the given string.
  """
  field_ends_with: String
  """
  All values not ending with the given string.
  """
  field_not_ends_with: String
  x_every: CWithCWhereInput
  x_some: CWithCWhereInput
  x_none: CWithCWhereInput
}

"""
Raw JSON value
"""
scalar Json

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createAWithIdWithA(data: AWithIdWithACreateInput!): AWithIdWithA!
  createAWithoutIdWithA(data: AWithoutIdWithACreateInput!): AWithoutIdWithA!
  createBWithIdWithA(data: BWithIdWithACreateInput!): BWithIdWithA!
  createBWithoutIdWithA(data: BWithoutIdWithACreateInput!): BWithoutIdWithA!
  createCWithIdWithA(data: CWithIdWithACreateInput!): CWithIdWithA!
  createCWithoutIdWithA(data: CWithoutIdWithACreateInput!): CWithoutIdWithA!
  createAWithIdWithB(data: AWithIdWithBCreateInput!): AWithIdWithB!
  createAWithoutIdWithB(data: AWithoutIdWithBCreateInput!): AWithoutIdWithB!
  createBWithIdWithB(data: BWithIdWithBCreateInput!): BWithIdWithB!
  createBWithoutIdWithB(data: BWithoutIdWithBCreateInput!): BWithoutIdWithB!
  createCWithIdWithB(data: CWithIdWithBCreateInput!): CWithIdWithB!
  createCWithoutIdWithB(data: CWithoutIdWithBCreateInput!): CWithoutIdWithB!
  createAWithIdWithC(data: AWithIdWithCCreateInput!): AWithIdWithC!
  createAWithoutIdWithC(data: AWithoutIdWithCCreateInput!): AWithoutIdWithC!
  createBWithIdWithC(data: BWithIdWithCCreateInput!): BWithIdWithC!
  createBWithoutIdWithC(data: BWithoutIdWithCCreateInput!): BWithoutIdWithC!
  createCWithIdWithC(data: CWithIdWithCCreateInput!): CWithIdWithC!
  createCWithoutIdWithC(data: CWithoutIdWithCCreateInput!): CWithoutIdWithC!
  createAWithA(data: AWithACreateInput!): AWithA!
  createAWithB(data: AWithBCreateInput!): AWithB!
  createAWithC(data: AWithCCreateInput!): AWithC!
  createBWithA(data: BWithACreateInput!): BWithA!
  createBWithB(data: BWithBCreateInput!): BWithB!
  createBWithC(data: BWithCCreateInput!): BWithC!
  createCWithA(data: CWithACreateInput!): CWithA!
  createCWithB(data: CWithBCreateInput!): CWithB!
  createCWithC(data: CWithCCreateInput!): CWithC!
  updateAWithIdWithA(data: AWithIdWithAUpdateInput!, where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  updateBWithIdWithA(data: BWithIdWithAUpdateInput!, where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  updateCWithIdWithA(data: CWithIdWithAUpdateInput!, where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  updateAWithIdWithB(data: AWithIdWithBUpdateInput!, where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  updateBWithIdWithB(data: BWithIdWithBUpdateInput!, where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  updateCWithIdWithB(data: CWithIdWithBUpdateInput!, where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  updateAWithIdWithC(data: AWithIdWithCUpdateInput!, where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  updateBWithIdWithC(data: BWithIdWithCUpdateInput!, where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  updateCWithIdWithC(data: CWithIdWithCUpdateInput!, where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  deleteAWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  deleteBWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  deleteCWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  deleteAWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  deleteBWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  deleteCWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  deleteAWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  deleteBWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  deleteCWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  upsertAWithIdWithA(where: AWithIdWithAWhereUniqueInput!, create: AWithIdWithACreateInput!, update: AWithIdWithAUpdateInput!): AWithIdWithA!
  upsertBWithIdWithA(where: BWithIdWithAWhereUniqueInput!, create: BWithIdWithACreateInput!, update: BWithIdWithAUpdateInput!): BWithIdWithA!
  upsertCWithIdWithA(where: CWithIdWithAWhereUniqueInput!, create: CWithIdWithACreateInput!, update: CWithIdWithAUpdateInput!): CWithIdWithA!
  upsertAWithIdWithB(where: AWithIdWithBWhereUniqueInput!, create: AWithIdWithBCreateInput!, update: AWithIdWithBUpdateInput!): AWithIdWithB!
  upsertBWithIdWithB(where: BWithIdWithBWhereUniqueInput!, create: BWithIdWithBCreateInput!, update: BWithIdWithBUpdateInput!): BWithIdWithB!
  upsertCWithIdWithB(where: CWithIdWithBWhereUniqueInput!, create: CWithIdWithBCreateInput!, update: CWithIdWithBUpdateInput!): CWithIdWithB!
  upsertAWithIdWithC(where: AWithIdWithCWhereUniqueInput!, create: AWithIdWithCCreateInput!, update: AWithIdWithCUpdateInput!): AWithIdWithC!
  upsertBWithIdWithC(where: BWithIdWithCWhereUniqueInput!, create: BWithIdWithCCreateInput!, update: BWithIdWithCUpdateInput!): BWithIdWithC!
  upsertCWithIdWithC(where: CWithIdWithCWhereUniqueInput!, create: CWithIdWithCCreateInput!, update: CWithIdWithCUpdateInput!): CWithIdWithC!
  updateManyAWithIdWithAs(data: AWithIdWithAUpdateManyMutationInput!, where: AWithIdWithAWhereInput): BatchPayload!
  updateManyAWithoutIdWithAs(data: AWithoutIdWithAUpdateManyMutationInput!, where: AWithoutIdWithAWhereInput): BatchPayload!
  updateManyBWithIdWithAs(data: BWithIdWithAUpdateManyMutationInput!, where: BWithIdWithAWhereInput): BatchPayload!
  updateManyBWithoutIdWithAs(data: BWithoutIdWithAUpdateManyMutationInput!, where: BWithoutIdWithAWhereInput): BatchPayload!
  updateManyCWithIdWithAs(data: CWithIdWithAUpdateManyMutationInput!, where: CWithIdWithAWhereInput): BatchPayload!
  updateManyCWithoutIdWithAs(data: CWithoutIdWithAUpdateManyMutationInput!, where: CWithoutIdWithAWhereInput): BatchPayload!
  updateManyAWithIdWithBs(data: AWithIdWithBUpdateManyMutationInput!, where: AWithIdWithBWhereInput): BatchPayload!
  updateManyAWithoutIdWithBs(data: AWithoutIdWithBUpdateManyMutationInput!, where: AWithoutIdWithBWhereInput): BatchPayload!
  updateManyBWithIdWithBs(data: BWithIdWithBUpdateManyMutationInput!, where: BWithIdWithBWhereInput): BatchPayload!
  updateManyBWithoutIdWithBs(data: BWithoutIdWithBUpdateManyMutationInput!, where: BWithoutIdWithBWhereInput): BatchPayload!
  updateManyCWithIdWithBs(data: CWithIdWithBUpdateManyMutationInput!, where: CWithIdWithBWhereInput): BatchPayload!
  updateManyCWithoutIdWithBs(data: CWithoutIdWithBUpdateManyMutationInput!, where: CWithoutIdWithBWhereInput): BatchPayload!
  updateManyAWithIdWithCs(data: AWithIdWithCUpdateManyMutationInput!, where: AWithIdWithCWhereInput): BatchPayload!
  updateManyAWithoutIdWithCs(data: AWithoutIdWithCUpdateManyMutationInput!, where: AWithoutIdWithCWhereInput): BatchPayload!
  updateManyBWithIdWithCs(data: BWithIdWithCUpdateManyMutationInput!, where: BWithIdWithCWhereInput): BatchPayload!
  updateManyBWithoutIdWithCs(data: BWithoutIdWithCUpdateManyMutationInput!, where: BWithoutIdWithCWhereInput): BatchPayload!
  updateManyCWithIdWithCs(data: CWithIdWithCUpdateManyMutationInput!, where: CWithIdWithCWhereInput): BatchPayload!
  updateManyCWithoutIdWithCs(data: CWithoutIdWithCUpdateManyMutationInput!, where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithIdWithAs(where: AWithIdWithAWhereInput): BatchPayload!
  deleteManyAWithoutIdWithAs(where: AWithoutIdWithAWhereInput): BatchPayload!
  deleteManyBWithIdWithAs(where: BWithIdWithAWhereInput): BatchPayload!
  deleteManyBWithoutIdWithAs(where: BWithoutIdWithAWhereInput): BatchPayload!
  deleteManyCWithIdWithAs(where: CWithIdWithAWhereInput): BatchPayload!
  deleteManyCWithoutIdWithAs(where: CWithoutIdWithAWhereInput): BatchPayload!
  deleteManyAWithIdWithBs(where: AWithIdWithBWhereInput): BatchPayload!
  deleteManyAWithoutIdWithBs(where: AWithoutIdWithBWhereInput): BatchPayload!
  deleteManyBWithIdWithBs(where: BWithIdWithBWhereInput): BatchPayload!
  deleteManyBWithoutIdWithBs(where: BWithoutIdWithBWhereInput): BatchPayload!
  deleteManyCWithIdWithBs(where: CWithIdWithBWhereInput): BatchPayload!
  deleteManyCWithoutIdWithBs(where: CWithoutIdWithBWhereInput): BatchPayload!
  deleteManyAWithIdWithCs(where: AWithIdWithCWhereInput): BatchPayload!
  deleteManyAWithoutIdWithCs(where: AWithoutIdWithCWhereInput): BatchPayload!
  deleteManyBWithIdWithCs(where: BWithIdWithCWhereInput): BatchPayload!
  deleteManyBWithoutIdWithCs(where: BWithoutIdWithCWhereInput): BatchPayload!
  deleteManyCWithIdWithCs(where: CWithIdWithCWhereInput): BatchPayload!
  deleteManyCWithoutIdWithCs(where: CWithoutIdWithCWhereInput): BatchPayload!
  deleteManyAWithAs(where: AWithAWhereInput): BatchPayload!
  deleteManyAWithBs(where: AWithBWhereInput): BatchPayload!
  deleteManyAWithCs(where: AWithCWhereInput): BatchPayload!
  deleteManyBWithAs(where: BWithAWhereInput): BatchPayload!
  deleteManyBWithBs(where: BWithBWhereInput): BatchPayload!
  deleteManyBWithCs(where: BWithCWhereInput): BatchPayload!
  deleteManyCWithAs(where: CWithAWhereInput): BatchPayload!
  deleteManyCWithBs(where: CWithBWhereInput): BatchPayload!
  deleteManyCWithCs(where: CWithCWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""
An object with an ID
"""
interface Node {
  """
  The id of the object.
  """
  id: ID!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

type Query {
  aWithIdWithAs(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithA]!
  aWithoutIdWithAs(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithA]!
  bWithIdWithAs(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithA]!
  bWithoutIdWithAs(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithA]!
  cWithIdWithAs(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithA]!
  cWithoutIdWithAs(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithA]!
  aWithIdWithBs(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithB]!
  aWithoutIdWithBs(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithB]!
  bWithIdWithBs(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithB]!
  bWithoutIdWithBs(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithB]!
  cWithIdWithBs(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithB]!
  cWithoutIdWithBs(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithB]!
  aWithIdWithCs(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithIdWithC]!
  aWithoutIdWithCs(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithoutIdWithC]!
  bWithIdWithCs(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithIdWithC]!
  bWithoutIdWithCs(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithoutIdWithC]!
  cWithIdWithCs(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithIdWithC]!
  cWithoutIdWithCs(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithoutIdWithC]!
  aWithAs(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithA]!
  aWithBs(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithB]!
  aWithCs(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AWithC]!
  bWithAs(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithA]!
  bWithBs(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithB]!
  bWithCs(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BWithC]!
  cWithAs(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithA]!
  cWithBs(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithB]!
  cWithCs(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CWithC]!
  aWithIdWithA(where: AWithIdWithAWhereUniqueInput!): AWithIdWithA
  bWithIdWithA(where: BWithIdWithAWhereUniqueInput!): BWithIdWithA
  cWithIdWithA(where: CWithIdWithAWhereUniqueInput!): CWithIdWithA
  aWithIdWithB(where: AWithIdWithBWhereUniqueInput!): AWithIdWithB
  bWithIdWithB(where: BWithIdWithBWhereUniqueInput!): BWithIdWithB
  cWithIdWithB(where: CWithIdWithBWhereUniqueInput!): CWithIdWithB
  aWithIdWithC(where: AWithIdWithCWhereUniqueInput!): AWithIdWithC
  bWithIdWithC(where: BWithIdWithCWhereUniqueInput!): BWithIdWithC
  cWithIdWithC(where: CWithIdWithCWhereUniqueInput!): CWithIdWithC
  aWithIdWithAsConnection(where: AWithIdWithAWhereInput, orderBy: AWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithAConnection!
  aWithoutIdWithAsConnection(where: AWithoutIdWithAWhereInput, orderBy: AWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithAConnection!
  bWithIdWithAsConnection(where: BWithIdWithAWhereInput, orderBy: BWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithAConnection!
  bWithoutIdWithAsConnection(where: BWithoutIdWithAWhereInput, orderBy: BWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithAConnection!
  cWithIdWithAsConnection(where: CWithIdWithAWhereInput, orderBy: CWithIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithAConnection!
  cWithoutIdWithAsConnection(where: CWithoutIdWithAWhereInput, orderBy: CWithoutIdWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithAConnection!
  aWithIdWithBsConnection(where: AWithIdWithBWhereInput, orderBy: AWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithBConnection!
  aWithoutIdWithBsConnection(where: AWithoutIdWithBWhereInput, orderBy: AWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithBConnection!
  bWithIdWithBsConnection(where: BWithIdWithBWhereInput, orderBy: BWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithBConnection!
  bWithoutIdWithBsConnection(where: BWithoutIdWithBWhereInput, orderBy: BWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithBConnection!
  cWithIdWithBsConnection(where: CWithIdWithBWhereInput, orderBy: CWithIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithBConnection!
  cWithoutIdWithBsConnection(where: CWithoutIdWithBWhereInput, orderBy: CWithoutIdWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithBConnection!
  aWithIdWithCsConnection(where: AWithIdWithCWhereInput, orderBy: AWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithIdWithCConnection!
  aWithoutIdWithCsConnection(where: AWithoutIdWithCWhereInput, orderBy: AWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithoutIdWithCConnection!
  bWithIdWithCsConnection(where: BWithIdWithCWhereInput, orderBy: BWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithIdWithCConnection!
  bWithoutIdWithCsConnection(where: BWithoutIdWithCWhereInput, orderBy: BWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithoutIdWithCConnection!
  cWithIdWithCsConnection(where: CWithIdWithCWhereInput, orderBy: CWithIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithIdWithCConnection!
  cWithoutIdWithCsConnection(where: CWithoutIdWithCWhereInput, orderBy: CWithoutIdWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithoutIdWithCConnection!
  aWithAsConnection(where: AWithAWhereInput, orderBy: AWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithAConnection!
  aWithBsConnection(where: AWithBWhereInput, orderBy: AWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithBConnection!
  aWithCsConnection(where: AWithCWhereInput, orderBy: AWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AWithCConnection!
  bWithAsConnection(where: BWithAWhereInput, orderBy: BWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithAConnection!
  bWithBsConnection(where: BWithBWhereInput, orderBy: BWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithBConnection!
  bWithCsConnection(where: BWithCWhereInput, orderBy: BWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BWithCConnection!
  cWithAsConnection(where: CWithAWhereInput, orderBy: CWithAOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithAConnection!
  cWithBsConnection(where: CWithBWhereInput, orderBy: CWithBOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithBConnection!
  cWithCsConnection(where: CWithCWhereInput, orderBy: CWithCOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CWithCConnection!
  """
  Fetches an object given its ID
  """
  node(
    """
    The ID of an object
    """
    id: ID!
  ): Node
}

type Subscription {
  aWithIdWithA(where: AWithIdWithASubscriptionWhereInput): AWithIdWithASubscriptionPayload
  aWithoutIdWithA(where: AWithoutIdWithASubscriptionWhereInput): AWithoutIdWithASubscriptionPayload
  bWithIdWithA(where: BWithIdWithASubscriptionWhereInput): BWithIdWithASubscriptionPayload
  bWithoutIdWithA(where: BWithoutIdWithASubscriptionWhereInput): BWithoutIdWithASubscriptionPayload
  cWithIdWithA(where: CWithIdWithASubscriptionWhereInput): CWithIdWithASubscriptionPayload
  cWithoutIdWithA(where: CWithoutIdWithASubscriptionWhereInput): CWithoutIdWithASubscriptionPayload
  aWithIdWithB(where: AWithIdWithBSubscriptionWhereInput): AWithIdWithBSubscriptionPayload
  aWithoutIdWithB(where: AWithoutIdWithBSubscriptionWhereInput): AWithoutIdWithBSubscriptionPayload
  bWithIdWithB(where: BWithIdWithBSubscriptionWhereInput): BWithIdWithBSubscriptionPayload
  bWithoutIdWithB(where: BWithoutIdWithBSubscriptionWhereInput): BWithoutIdWithBSubscriptionPayload
  cWithIdWithB(where: CWithIdWithBSubscriptionWhereInput): CWithIdWithBSubscriptionPayload
  cWithoutIdWithB(where: CWithoutIdWithBSubscriptionWhereInput): CWithoutIdWithBSubscriptionPayload
  aWithIdWithC(where: AWithIdWithCSubscriptionWhereInput): AWithIdWithCSubscriptionPayload
  aWithoutIdWithC(where: AWithoutIdWithCSubscriptionWhereInput): AWithoutIdWithCSubscriptionPayload
  bWithIdWithC(where: BWithIdWithCSubscriptionWhereInput): BWithIdWithCSubscriptionPayload
  bWithoutIdWithC(where: BWithoutIdWithCSubscriptionWhereInput): BWithoutIdWithCSubscriptionPayload
  cWithIdWithC(where: CWithIdWithCSubscriptionWhereInput): CWithIdWithCSubscriptionPayload
  cWithoutIdWithC(where: CWithoutIdWithCSubscriptionWhereInput): CWithoutIdWithCSubscriptionPayload
  aWithA(where: AWithASubscriptionWhereInput): AWithASubscriptionPayload
  aWithB(where: AWithBSubscriptionWhereInput): AWithBSubscriptionPayload
  aWithC(where: AWithCSubscriptionWhereInput): AWithCSubscriptionPayload
  bWithA(where: BWithASubscriptionWhereInput): BWithASubscriptionPayload
  bWithB(where: BWithBSubscriptionWhereInput): BWithBSubscriptionPayload
  bWithC(where: BWithCSubscriptionWhereInput): BWithCSubscriptionPayload
  cWithA(where: CWithASubscriptionWhereInput): CWithASubscriptionPayload
  cWithB(where: CWithBSubscriptionWhereInput): CWithBSubscriptionPayload
  cWithC(where: CWithCSubscriptionWhereInput): CWithCSubscriptionPayload
}

