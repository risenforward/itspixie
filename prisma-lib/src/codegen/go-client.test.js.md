# Snapshot report for `dist/codegen/go-client.test.js`

The actual snapshot is saved in `go-client.test.js.snap`.

Generated by [AVA](https://ava.li).

## go generator

> Snapshot 1

    `␊
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.␊
    package prisma␊
    ␊
    import (␊
    	"context"␊
    	"fmt"␊
    	"reflect"␊
    	"strconv"␊
    ␊
    	"github.com/machinebox/graphql"␊
    	"github.com/mitchellh/mapstructure"␊
    )␊
    ␊
    // ID docs␊
    type ID struct{}␊
    ␊
    // Queries␊
    ␊
    ␊
               ␊
    ␊
              // PostsParams docs␊
              type PostsParams struct {␊
                Where *PostWhereInput `json:"where,omitempty"`␊
    OrderBy *PostOrderByInput `json:"orderBy,omitempty"`␊
    Skip *int32 `json:"skip,omitempty"`␊
    After *string `json:"after,omitempty"`␊
    Before *string `json:"before,omitempty"`␊
    First *int32 `json:"first,omitempty"`␊
    Last *int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // Posts docs␊
              func (client Client) Posts (params *PostsParams) *PostExecArray {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereInput",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
    if params.OrderBy != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "orderBy",␊
                      Key: "orderBy",␊
                      TypeName: "PostOrderByInput",␊
                      Value: *params.OrderBy,␊
                    })␊
                  }␊
    if params.Skip != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "skip",␊
                      Key: "skip",␊
                      TypeName: "Int",␊
                      Value: *params.Skip,␊
                    })␊
                  }␊
    if params.After != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "after",␊
                      Key: "after",␊
                      TypeName: "String",␊
                      Value: *params.After,␊
                    })␊
                  }␊
    if params.Before != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "before",␊
                      Key: "before",␊
                      TypeName: "String",␊
                      Value: *params.Before,␊
                    })␊
                  }␊
    if params.First != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "first",␊
                      Key: "first",␊
                      TypeName: "Int",␊
                      Value: *params.First,␊
                    })␊
                  }␊
    if params.Last != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "last",␊
                      Key: "last",␊
                      TypeName: "Int",␊
                      Value: *params.Last,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "posts",␊
                Field: GraphQLField{␊
                  Name: "posts",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &PostExecArray{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UsersParams docs␊
              type UsersParams struct {␊
                Where *UserWhereInput `json:"where,omitempty"`␊
    OrderBy *UserOrderByInput `json:"orderBy,omitempty"`␊
    Skip *int32 `json:"skip,omitempty"`␊
    After *string `json:"after,omitempty"`␊
    Before *string `json:"before,omitempty"`␊
    First *int32 `json:"first,omitempty"`␊
    Last *int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // Users docs␊
              func (client Client) Users (params *UsersParams) *UserExecArray {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereInput",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
    if params.OrderBy != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "orderBy",␊
                      Key: "orderBy",␊
                      TypeName: "UserOrderByInput",␊
                      Value: *params.OrderBy,␊
                    })␊
                  }␊
    if params.Skip != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "skip",␊
                      Key: "skip",␊
                      TypeName: "Int",␊
                      Value: *params.Skip,␊
                    })␊
                  }␊
    if params.After != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "after",␊
                      Key: "after",␊
                      TypeName: "String",␊
                      Value: *params.After,␊
                    })␊
                  }␊
    if params.Before != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "before",␊
                      Key: "before",␊
                      TypeName: "String",␊
                      Value: *params.Before,␊
                    })␊
                  }␊
    if params.First != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "first",␊
                      Key: "first",␊
                      TypeName: "Int",␊
                      Value: *params.First,␊
                    })␊
                  }␊
    if params.Last != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "last",␊
                      Key: "last",␊
                      TypeName: "Int",␊
                      Value: *params.Last,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "users",␊
                Field: GraphQLField{␊
                  Name: "users",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &UserExecArray{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
              ␊
                  // Exists␊
    ␊
                  // Post exists docs␊
                  func (exists *Exists) Post(params *PostWhereUniqueInput) bool {␊
                    client := Client{␊
                      Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466/test/test"})[exists.Endpoint != ""],␊
                      Debug: exists.Debug,␊
                    }␊
                    data, err := client.Post(␊
                      params,␊
                    ).Exec()␊
                    if err != nil {␊
                      if client.Debug {␊
                        fmt.Println("Error Exists", err)␊
                      }␊
                      return false␊
                    }␊
                    if isZeroOfUnderlyingType(data) {␊
                      return false␊
                    }␊
                    return true␊
                  }␊
               ␊
    ␊
              // PostParams docs␊
              type PostParams struct {␊
                Where *PostWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // Post docs␊
              func (client Client) Post (params *PostWhereUniqueInput) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereUniqueInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "post",␊
                Field: GraphQLField{␊
                  Name: "post",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &PostExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
              ␊
                  // Exists␊
    ␊
                  // User exists docs␊
                  func (exists *Exists) User(params *UserWhereUniqueInput) bool {␊
                    client := Client{␊
                      Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466/test/test"})[exists.Endpoint != ""],␊
                      Debug: exists.Debug,␊
                    }␊
                    data, err := client.User(␊
                      params,␊
                    ).Exec()␊
                    if err != nil {␊
                      if client.Debug {␊
                        fmt.Println("Error Exists", err)␊
                      }␊
                      return false␊
                    }␊
                    if isZeroOfUnderlyingType(data) {␊
                      return false␊
                    }␊
                    return true␊
                  }␊
               ␊
    ␊
              // UserParams docs␊
              type UserParams struct {␊
                Where *UserWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // User docs␊
              func (client Client) User (params *UserWhereUniqueInput) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereUniqueInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "user",␊
                Field: GraphQLField{␊
                  Name: "user",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &UserExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
              ␊
                  // Exists␊
    ␊
                  // PostsConnection exists docs␊
                  func (exists *Exists) PostsConnection(params *PostWhereInput) bool {␊
                    client := Client{␊
                      Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466/test/test"})[exists.Endpoint != ""],␊
                      Debug: exists.Debug,␊
                    }␊
                    data, err := client.PostsConnection(␊
                      &PostsConnectionParams{␊
                        Where: params,␊
                      },␊
                    ).Exec()␊
                    if err != nil {␊
                      if client.Debug {␊
                        fmt.Println("Error Exists", err)␊
                      }␊
                      return false␊
                    }␊
                    if isZeroOfUnderlyingType(data) {␊
                      return false␊
                    }␊
                    return true␊
                  }␊
               ␊
    ␊
              // PostsConnectionParams docs␊
              type PostsConnectionParams struct {␊
                Where *PostWhereInput `json:"where,omitempty"`␊
    OrderBy *PostOrderByInput `json:"orderBy,omitempty"`␊
    Skip *int32 `json:"skip,omitempty"`␊
    After *string `json:"after,omitempty"`␊
    Before *string `json:"before,omitempty"`␊
    First *int32 `json:"first,omitempty"`␊
    Last *int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // PostsConnection docs␊
              func (client Client) PostsConnection (params *PostsConnectionParams) *PostConnectionExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereInput",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
    if params.OrderBy != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "orderBy",␊
                      Key: "orderBy",␊
                      TypeName: "PostOrderByInput",␊
                      Value: *params.OrderBy,␊
                    })␊
                  }␊
    if params.Skip != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "skip",␊
                      Key: "skip",␊
                      TypeName: "Int",␊
                      Value: *params.Skip,␊
                    })␊
                  }␊
    if params.After != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "after",␊
                      Key: "after",␊
                      TypeName: "String",␊
                      Value: *params.After,␊
                    })␊
                  }␊
    if params.Before != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "before",␊
                      Key: "before",␊
                      TypeName: "String",␊
                      Value: *params.Before,␊
                    })␊
                  }␊
    if params.First != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "first",␊
                      Key: "first",␊
                      TypeName: "Int",␊
                      Value: *params.First,␊
                    })␊
                  }␊
    if params.Last != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "last",␊
                      Key: "last",␊
                      TypeName: "Int",␊
                      Value: *params.Last,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "postsConnection",␊
                Field: GraphQLField{␊
                  Name: "postsConnection",␊
                  TypeName: "PostConnection",␊
                  TypeFields: []string{},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &PostConnectionExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
              ␊
                  // Exists␊
    ␊
                  // UsersConnection exists docs␊
                  func (exists *Exists) UsersConnection(params *UserWhereInput) bool {␊
                    client := Client{␊
                      Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466/test/test"})[exists.Endpoint != ""],␊
                      Debug: exists.Debug,␊
                    }␊
                    data, err := client.UsersConnection(␊
                      &UsersConnectionParams{␊
                        Where: params,␊
                      },␊
                    ).Exec()␊
                    if err != nil {␊
                      if client.Debug {␊
                        fmt.Println("Error Exists", err)␊
                      }␊
                      return false␊
                    }␊
                    if isZeroOfUnderlyingType(data) {␊
                      return false␊
                    }␊
                    return true␊
                  }␊
               ␊
    ␊
              // UsersConnectionParams docs␊
              type UsersConnectionParams struct {␊
                Where *UserWhereInput `json:"where,omitempty"`␊
    OrderBy *UserOrderByInput `json:"orderBy,omitempty"`␊
    Skip *int32 `json:"skip,omitempty"`␊
    After *string `json:"after,omitempty"`␊
    Before *string `json:"before,omitempty"`␊
    First *int32 `json:"first,omitempty"`␊
    Last *int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // UsersConnection docs␊
              func (client Client) UsersConnection (params *UsersConnectionParams) *UserConnectionExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereInput",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
    if params.OrderBy != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "orderBy",␊
                      Key: "orderBy",␊
                      TypeName: "UserOrderByInput",␊
                      Value: *params.OrderBy,␊
                    })␊
                  }␊
    if params.Skip != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "skip",␊
                      Key: "skip",␊
                      TypeName: "Int",␊
                      Value: *params.Skip,␊
                    })␊
                  }␊
    if params.After != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "after",␊
                      Key: "after",␊
                      TypeName: "String",␊
                      Value: *params.After,␊
                    })␊
                  }␊
    if params.Before != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "before",␊
                      Key: "before",␊
                      TypeName: "String",␊
                      Value: *params.Before,␊
                    })␊
                  }␊
    if params.First != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "first",␊
                      Key: "first",␊
                      TypeName: "Int",␊
                      Value: *params.First,␊
                    })␊
                  }␊
    if params.Last != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "last",␊
                      Key: "last",␊
                      TypeName: "Int",␊
                      Value: *params.Last,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "usersConnection",␊
                Field: GraphQLField{␊
                  Name: "usersConnection",␊
                  TypeName: "UserConnection",␊
                  TypeFields: []string{},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &UserConnectionExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // NodeParams docs␊
              type NodeParams struct {␊
                ID *string `json:"id"`␊
              }␊
              ␊
              // Node docs␊
              func (client Client) Node (params *ID) *NodeExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "id",␊
                      Key: "id",␊
                      TypeName: "ID!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "node",␊
                Field: GraphQLField{␊
                  Name: "node",␊
                  TypeName: "Node",␊
                  TypeFields: []string{},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
              return &NodeExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    // Mutations␊
    ␊
    ␊
               ␊
    ␊
              // CreatePostParams docs␊
              type CreatePostParams struct {␊
                Data *PostCreateInput `json:"data"`␊
              }␊
              ␊
              // CreatePost docs␊
              func (client Client) CreatePost (params *PostCreateInput) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "data",␊
                      Key: "data",␊
                      TypeName: "PostCreateInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "createPost",␊
                Field: GraphQLField{␊
                  Name: "createPost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &PostExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // CreateUserParams docs␊
              type CreateUserParams struct {␊
                Data *UserCreateInput `json:"data"`␊
              }␊
              ␊
              // CreateUser docs␊
              func (client Client) CreateUser (params *UserCreateInput) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "data",␊
                      Key: "data",␊
                      TypeName: "UserCreateInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "createUser",␊
                Field: GraphQLField{␊
                  Name: "createUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &UserExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UpdatePostParams docs␊
              type UpdatePostParams struct {␊
                Data *PostUpdateInput `json:"data"`␊
    Where *PostWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // UpdatePost docs␊
              func (client Client) UpdatePost (params *UpdatePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Data != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "data",␊
                      Key: "data",␊
                      TypeName: "PostUpdateInput!",␊
                      Value: *params.Data,␊
                    })␊
                  }␊
    if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereUniqueInput!",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updatePost",␊
                Field: GraphQLField{␊
                  Name: "updatePost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &PostExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UpdateUserParams docs␊
              type UpdateUserParams struct {␊
                Data *UserUpdateInput `json:"data"`␊
    Where *UserWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // UpdateUser docs␊
              func (client Client) UpdateUser (params *UpdateUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Data != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "data",␊
                      Key: "data",␊
                      TypeName: "UserUpdateInput!",␊
                      Value: *params.Data,␊
                    })␊
                  }␊
    if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereUniqueInput!",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updateUser",␊
                Field: GraphQLField{␊
                  Name: "updateUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &UserExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // DeletePostParams docs␊
              type DeletePostParams struct {␊
                Where *PostWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // DeletePost docs␊
              func (client Client) DeletePost (params *PostWhereUniqueInput) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereUniqueInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deletePost",␊
                Field: GraphQLField{␊
                  Name: "deletePost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &PostExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // DeleteUserParams docs␊
              type DeleteUserParams struct {␊
                Where *UserWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // DeleteUser docs␊
              func (client Client) DeleteUser (params *UserWhereUniqueInput) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereUniqueInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deleteUser",␊
                Field: GraphQLField{␊
                  Name: "deleteUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &UserExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UpsertPostParams docs␊
              type UpsertPostParams struct {␊
                Where *PostWhereUniqueInput `json:"where"`␊
    Create *PostCreateInput `json:"create"`␊
    Update *PostUpdateInput `json:"update"`␊
              }␊
              ␊
              // UpsertPost docs␊
              func (client Client) UpsertPost (params *UpsertPostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereUniqueInput!",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
    if params.Create != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "create",␊
                      Key: "create",␊
                      TypeName: "PostCreateInput!",␊
                      Value: *params.Create,␊
                    })␊
                  }␊
    if params.Update != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "update",␊
                      Key: "update",␊
                      TypeName: "PostUpdateInput!",␊
                      Value: *params.Update,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "upsertPost",␊
                Field: GraphQLField{␊
                  Name: "upsertPost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &PostExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UpsertUserParams docs␊
              type UpsertUserParams struct {␊
                Where *UserWhereUniqueInput `json:"where"`␊
    Create *UserCreateInput `json:"create"`␊
    Update *UserUpdateInput `json:"update"`␊
              }␊
              ␊
              // UpsertUser docs␊
              func (client Client) UpsertUser (params *UpsertUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereUniqueInput!",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
    if params.Create != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "create",␊
                      Key: "create",␊
                      TypeName: "UserCreateInput!",␊
                      Value: *params.Create,␊
                    })␊
                  }␊
    if params.Update != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "update",␊
                      Key: "update",␊
                      TypeName: "UserUpdateInput!",␊
                      Value: *params.Update,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "upsertUser",␊
                Field: GraphQLField{␊
                  Name: "upsertUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &UserExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UpdateManyPostsParams docs␊
              type UpdateManyPostsParams struct {␊
                Data *PostUpdateInput `json:"data"`␊
    Where *PostWhereInput `json:"where"`␊
              }␊
              ␊
              // UpdateManyPosts docs␊
              func (client Client) UpdateManyPosts (params *UpdateManyPostsParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Data != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "data",␊
                      Key: "data",␊
                      TypeName: "PostUpdateInput!",␊
                      Value: *params.Data,␊
                    })␊
                  }␊
    if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereInput!",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updateManyPosts",␊
                Field: GraphQLField{␊
                  Name: "updateManyPosts",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &BatchPayloadExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // UpdateManyUsersParams docs␊
              type UpdateManyUsersParams struct {␊
                Data *UserUpdateInput `json:"data"`␊
    Where *UserWhereInput `json:"where"`␊
              }␊
              ␊
              // UpdateManyUsers docs␊
              func (client Client) UpdateManyUsers (params *UpdateManyUsersParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params.Data != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "data",␊
                      Key: "data",␊
                      TypeName: "UserUpdateInput!",␊
                      Value: *params.Data,␊
                    })␊
                  }␊
    if params.Where != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereInput!",␊
                      Value: *params.Where,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updateManyUsers",␊
                Field: GraphQLField{␊
                  Name: "updateManyUsers",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &BatchPayloadExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // DeleteManyPostsParams docs␊
              type DeleteManyPostsParams struct {␊
                Where *PostWhereInput `json:"where"`␊
              }␊
              ␊
              // DeleteManyPosts docs␊
              func (client Client) DeleteManyPosts (params *PostWhereInput) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "PostWhereInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deleteManyPosts",␊
                Field: GraphQLField{␊
                  Name: "deleteManyPosts",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &BatchPayloadExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    ␊
               ␊
    ␊
              // DeleteManyUsersParams docs␊
              type DeleteManyUsersParams struct {␊
                Where *UserWhereInput `json:"where"`␊
              }␊
              ␊
              // DeleteManyUsers docs␊
              func (client Client) DeleteManyUsers (params *UserWhereInput) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              if params != nil {␊
                    args = append(args, GraphQLArg{␊
                      Name: "where",␊
                      Key: "where",␊
                      TypeName: "UserWhereInput!",␊
                      Value: *params,␊
                    })␊
                  }␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deleteManyUsers",␊
                Field: GraphQLField{␊
                  Name: "deleteManyUsers",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
              return &BatchPayloadExec{␊
                client: client,␊
                stack: stack,␊
              }␊
            }␊
    ␊
    // Types␊
    ␊
    ␊
                // PostOrderByInput docs␊
                type PostOrderByInput string␊
                const (␊
                    ␊
                          // IDAscPostOrderByInput docs␊
                          IDAscPostOrderByInput PostOrderByInput = "id_ASC"␊
    ␊
                          // IDDescPostOrderByInput docs␊
                          IDDescPostOrderByInput PostOrderByInput = "id_DESC"␊
    ␊
                          // CreatedAtAscPostOrderByInput docs␊
                          CreatedAtAscPostOrderByInput PostOrderByInput = "createdAt_ASC"␊
    ␊
                          // CreatedAtDescPostOrderByInput docs␊
                          CreatedAtDescPostOrderByInput PostOrderByInput = "createdAt_DESC"␊
    ␊
                          // UpdatedAtAscPostOrderByInput docs␊
                          UpdatedAtAscPostOrderByInput PostOrderByInput = "updatedAt_ASC"␊
    ␊
                          // UpdatedAtDescPostOrderByInput docs␊
                          UpdatedAtDescPostOrderByInput PostOrderByInput = "updatedAt_DESC"␊
    ␊
                          // IsPublishedAscPostOrderByInput docs␊
                          IsPublishedAscPostOrderByInput PostOrderByInput = "isPublished_ASC"␊
    ␊
                          // IsPublishedDescPostOrderByInput docs␊
                          IsPublishedDescPostOrderByInput PostOrderByInput = "isPublished_DESC"␊
    ␊
                          // TitleAscPostOrderByInput docs␊
                          TitleAscPostOrderByInput PostOrderByInput = "title_ASC"␊
    ␊
                          // TitleDescPostOrderByInput docs␊
                          TitleDescPostOrderByInput PostOrderByInput = "title_DESC"␊
    ␊
                          // TextAscPostOrderByInput docs␊
                          TextAscPostOrderByInput PostOrderByInput = "text_ASC"␊
    ␊
                          // TextDescPostOrderByInput docs␊
                          TextDescPostOrderByInput PostOrderByInput = "text_DESC"␊
                )␊
            ␊
    ␊
                // UserOrderByInput docs␊
                type UserOrderByInput string␊
                const (␊
                    ␊
                          // IDAscUserOrderByInput docs␊
                          IDAscUserOrderByInput UserOrderByInput = "id_ASC"␊
    ␊
                          // IDDescUserOrderByInput docs␊
                          IDDescUserOrderByInput UserOrderByInput = "id_DESC"␊
    ␊
                          // EmailAscUserOrderByInput docs␊
                          EmailAscUserOrderByInput UserOrderByInput = "email_ASC"␊
    ␊
                          // EmailDescUserOrderByInput docs␊
                          EmailDescUserOrderByInput UserOrderByInput = "email_DESC"␊
    ␊
                          // PasswordAscUserOrderByInput docs␊
                          PasswordAscUserOrderByInput UserOrderByInput = "password_ASC"␊
    ␊
                          // PasswordDescUserOrderByInput docs␊
                          PasswordDescUserOrderByInput UserOrderByInput = "password_DESC"␊
    ␊
                          // NameAscUserOrderByInput docs␊
                          NameAscUserOrderByInput UserOrderByInput = "name_ASC"␊
    ␊
                          // NameDescUserOrderByInput docs␊
                          NameDescUserOrderByInput UserOrderByInput = "name_DESC"␊
    ␊
                          // UpdatedAtAscUserOrderByInput docs␊
                          UpdatedAtAscUserOrderByInput UserOrderByInput = "updatedAt_ASC"␊
    ␊
                          // UpdatedAtDescUserOrderByInput docs␊
                          UpdatedAtDescUserOrderByInput UserOrderByInput = "updatedAt_DESC"␊
    ␊
                          // CreatedAtAscUserOrderByInput docs␊
                          CreatedAtAscUserOrderByInput UserOrderByInput = "createdAt_ASC"␊
    ␊
                          // CreatedAtDescUserOrderByInput docs␊
                          CreatedAtDescUserOrderByInput UserOrderByInput = "createdAt_DESC"␊
                )␊
            ␊
    ␊
                // MutationType docs␊
                type MutationType string␊
                const (␊
                    ␊
                          // CreatedMutationType docs␊
                          CreatedMutationType MutationType = "CREATED"␊
    ␊
                          // UpdatedMutationType docs␊
                          UpdatedMutationType MutationType = "UPDATED"␊
    ␊
                          // DeletedMutationType docs␊
                          DeletedMutationType MutationType = "DELETED"␊
                )␊
            ␊
    // UserCreateOneWithoutPostsInput input struct docs␊
          type UserCreateOneWithoutPostsInput struct {␊
              Create *UserCreateWithoutPostsInput `json:"create,omitempty"`␊
    Connect *UserWhereUniqueInput `json:"connect,omitempty"`␊
                }␊
            ␊
    // PostWhereInput input struct docs␊
          type PostWhereInput struct {␊
              And *PostWhereInput `json:"AND,omitempty"`␊
    Or *PostWhereInput `json:"OR,omitempty"`␊
    ID *string `json:"id,omitempty"`␊
    IDNot *string `json:"id_not,omitempty"`␊
    IDIn *string `json:"id_in,omitempty"`␊
    IDNotIn *string `json:"id_not_in,omitempty"`␊
    IDLt *string `json:"id_lt,omitempty"`␊
    IDLte *string `json:"id_lte,omitempty"`␊
    IDGt *string `json:"id_gt,omitempty"`␊
    IDGte *string `json:"id_gte,omitempty"`␊
    IDContains *string `json:"id_contains,omitempty"`␊
    IDNotContains *string `json:"id_not_contains,omitempty"`␊
    IDStartsWith *string `json:"id_starts_with,omitempty"`␊
    IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`␊
    IDEndsWith *string `json:"id_ends_with,omitempty"`␊
    IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`␊
    CreatedAt *string `json:"createdAt,omitempty"`␊
    CreatedAtNot *string `json:"createdAt_not,omitempty"`␊
    CreatedAtIn *string `json:"createdAt_in,omitempty"`␊
    CreatedAtNotIn *string `json:"createdAt_not_in,omitempty"`␊
    CreatedAtLt *string `json:"createdAt_lt,omitempty"`␊
    CreatedAtLte *string `json:"createdAt_lte,omitempty"`␊
    CreatedAtGt *string `json:"createdAt_gt,omitempty"`␊
    CreatedAtGte *string `json:"createdAt_gte,omitempty"`␊
    UpdatedAt *string `json:"updatedAt,omitempty"`␊
    UpdatedAtNot *string `json:"updatedAt_not,omitempty"`␊
    UpdatedAtIn *string `json:"updatedAt_in,omitempty"`␊
    UpdatedAtNotIn *string `json:"updatedAt_not_in,omitempty"`␊
    UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`␊
    UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`␊
    UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`␊
    UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`␊
    IsPublished *bool `json:"isPublished,omitempty"`␊
    IsPublishedNot *bool `json:"isPublished_not,omitempty"`␊
    Title *string `json:"title,omitempty"`␊
    TitleNot *string `json:"title_not,omitempty"`␊
    TitleIn *string `json:"title_in,omitempty"`␊
    TitleNotIn *string `json:"title_not_in,omitempty"`␊
    TitleLt *string `json:"title_lt,omitempty"`␊
    TitleLte *string `json:"title_lte,omitempty"`␊
    TitleGt *string `json:"title_gt,omitempty"`␊
    TitleGte *string `json:"title_gte,omitempty"`␊
    TitleContains *string `json:"title_contains,omitempty"`␊
    TitleNotContains *string `json:"title_not_contains,omitempty"`␊
    TitleStartsWith *string `json:"title_starts_with,omitempty"`␊
    TitleNotStartsWith *string `json:"title_not_starts_with,omitempty"`␊
    TitleEndsWith *string `json:"title_ends_with,omitempty"`␊
    TitleNotEndsWith *string `json:"title_not_ends_with,omitempty"`␊
    Text *string `json:"text,omitempty"`␊
    TextNot *string `json:"text_not,omitempty"`␊
    TextIn *string `json:"text_in,omitempty"`␊
    TextNotIn *string `json:"text_not_in,omitempty"`␊
    TextLt *string `json:"text_lt,omitempty"`␊
    TextLte *string `json:"text_lte,omitempty"`␊
    TextGt *string `json:"text_gt,omitempty"`␊
    TextGte *string `json:"text_gte,omitempty"`␊
    TextContains *string `json:"text_contains,omitempty"`␊
    TextNotContains *string `json:"text_not_contains,omitempty"`␊
    TextStartsWith *string `json:"text_starts_with,omitempty"`␊
    TextNotStartsWith *string `json:"text_not_starts_with,omitempty"`␊
    TextEndsWith *string `json:"text_ends_with,omitempty"`␊
    TextNotEndsWith *string `json:"text_not_ends_with,omitempty"`␊
    Author *UserWhereInput `json:"author,omitempty"`␊
                }␊
            ␊
    // PostCreateManyWithoutAuthorInput input struct docs␊
          type PostCreateManyWithoutAuthorInput struct {␊
              Create *PostCreateWithoutAuthorInput `json:"create,omitempty"`␊
    Connect *PostWhereUniqueInput `json:"connect,omitempty"`␊
                }␊
            ␊
    // UserWhereInput input struct docs␊
          type UserWhereInput struct {␊
              And *UserWhereInput `json:"AND,omitempty"`␊
    Or *UserWhereInput `json:"OR,omitempty"`␊
    ID *string `json:"id,omitempty"`␊
    IDNot *string `json:"id_not,omitempty"`␊
    IDIn *string `json:"id_in,omitempty"`␊
    IDNotIn *string `json:"id_not_in,omitempty"`␊
    IDLt *string `json:"id_lt,omitempty"`␊
    IDLte *string `json:"id_lte,omitempty"`␊
    IDGt *string `json:"id_gt,omitempty"`␊
    IDGte *string `json:"id_gte,omitempty"`␊
    IDContains *string `json:"id_contains,omitempty"`␊
    IDNotContains *string `json:"id_not_contains,omitempty"`␊
    IDStartsWith *string `json:"id_starts_with,omitempty"`␊
    IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`␊
    IDEndsWith *string `json:"id_ends_with,omitempty"`␊
    IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`␊
    Email *string `json:"email,omitempty"`␊
    EmailNot *string `json:"email_not,omitempty"`␊
    EmailIn *string `json:"email_in,omitempty"`␊
    EmailNotIn *string `json:"email_not_in,omitempty"`␊
    EmailLt *string `json:"email_lt,omitempty"`␊
    EmailLte *string `json:"email_lte,omitempty"`␊
    EmailGt *string `json:"email_gt,omitempty"`␊
    EmailGte *string `json:"email_gte,omitempty"`␊
    EmailContains *string `json:"email_contains,omitempty"`␊
    EmailNotContains *string `json:"email_not_contains,omitempty"`␊
    EmailStartsWith *string `json:"email_starts_with,omitempty"`␊
    EmailNotStartsWith *string `json:"email_not_starts_with,omitempty"`␊
    EmailEndsWith *string `json:"email_ends_with,omitempty"`␊
    EmailNotEndsWith *string `json:"email_not_ends_with,omitempty"`␊
    Password *string `json:"password,omitempty"`␊
    PasswordNot *string `json:"password_not,omitempty"`␊
    PasswordIn *string `json:"password_in,omitempty"`␊
    PasswordNotIn *string `json:"password_not_in,omitempty"`␊
    PasswordLt *string `json:"password_lt,omitempty"`␊
    PasswordLte *string `json:"password_lte,omitempty"`␊
    PasswordGt *string `json:"password_gt,omitempty"`␊
    PasswordGte *string `json:"password_gte,omitempty"`␊
    PasswordContains *string `json:"password_contains,omitempty"`␊
    PasswordNotContains *string `json:"password_not_contains,omitempty"`␊
    PasswordStartsWith *string `json:"password_starts_with,omitempty"`␊
    PasswordNotStartsWith *string `json:"password_not_starts_with,omitempty"`␊
    PasswordEndsWith *string `json:"password_ends_with,omitempty"`␊
    PasswordNotEndsWith *string `json:"password_not_ends_with,omitempty"`␊
    Name *string `json:"name,omitempty"`␊
    NameNot *string `json:"name_not,omitempty"`␊
    NameIn *string `json:"name_in,omitempty"`␊
    NameNotIn *string `json:"name_not_in,omitempty"`␊
    NameLt *string `json:"name_lt,omitempty"`␊
    NameLte *string `json:"name_lte,omitempty"`␊
    NameGt *string `json:"name_gt,omitempty"`␊
    NameGte *string `json:"name_gte,omitempty"`␊
    NameContains *string `json:"name_contains,omitempty"`␊
    NameNotContains *string `json:"name_not_contains,omitempty"`␊
    NameStartsWith *string `json:"name_starts_with,omitempty"`␊
    NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`␊
    NameEndsWith *string `json:"name_ends_with,omitempty"`␊
    NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`␊
    PostsEvery *PostWhereInput `json:"posts_every,omitempty"`␊
    PostsSome *PostWhereInput `json:"posts_some,omitempty"`␊
    PostsNone *PostWhereInput `json:"posts_none,omitempty"`␊
                }␊
            ␊
    // PostUpdateManyWithoutAuthorInput input struct docs␊
          type PostUpdateManyWithoutAuthorInput struct {␊
              Create *PostCreateWithoutAuthorInput `json:"create,omitempty"`␊
    Connect *PostWhereUniqueInput `json:"connect,omitempty"`␊
    Disconnect *PostWhereUniqueInput `json:"disconnect,omitempty"`␊
    Delete *PostWhereUniqueInput `json:"delete,omitempty"`␊
    Update *PostUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`␊
    Upsert *PostUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`␊
                }␊
            ␊
    // PostUpdateInput input struct docs␊
          type PostUpdateInput struct {␊
              IsPublished *bool `json:"isPublished,omitempty"`␊
    Title *string `json:"title,omitempty"`␊
    Text *string `json:"text,omitempty"`␊
    Author *UserUpdateOneWithoutPostsInput `json:"author,omitempty"`␊
                }␊
            ␊
    // UserUpdateInput input struct docs␊
          type UserUpdateInput struct {␊
              Email *string `json:"email,omitempty"`␊
    Password *string `json:"password,omitempty"`␊
    Name *string `json:"name,omitempty"`␊
    Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`␊
                }␊
            ␊
    // PostCreateWithoutAuthorInput input struct docs␊
          type PostCreateWithoutAuthorInput struct {␊
              IsPublished *bool `json:"isPublished,omitempty"`␊
    Title *string `json:"title,omitempty"`␊
    Text *string `json:"text,omitempty"`␊
                }␊
            ␊
    // UserUpsertWithoutPostsInput input struct docs␊
          type UserUpsertWithoutPostsInput struct {␊
              Update *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`␊
    Create *UserCreateWithoutPostsInput `json:"create,omitempty"`␊
                }␊
            ␊
    // UserSubscriptionWhereInput input struct docs␊
          type UserSubscriptionWhereInput struct {␊
              And *UserSubscriptionWhereInput `json:"AND,omitempty"`␊
    Or *UserSubscriptionWhereInput `json:"OR,omitempty"`␊
    MutationIn *MutationType `json:"mutation_in,omitempty"`␊
    UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`␊
    UpdatedFieldsContainsEvery *string `json:"updatedFields_contains_every,omitempty"`␊
    UpdatedFieldsContainsSome *string `json:"updatedFields_contains_some,omitempty"`␊
    Node *UserWhereInput `json:"node,omitempty"`␊
                }␊
            ␊
    // UserUpdateWithoutPostsDataInput input struct docs␊
          type UserUpdateWithoutPostsDataInput struct {␊
              Email *string `json:"email,omitempty"`␊
    Password *string `json:"password,omitempty"`␊
    Name *string `json:"name,omitempty"`␊
                }␊
            ␊
    // PostWhereUniqueInput input struct docs␊
          type PostWhereUniqueInput struct {␊
              ID *string `json:"id,omitempty"`␊
                }␊
            ␊
    // PostUpsertWithWhereUniqueWithoutAuthorInput input struct docs␊
          type PostUpsertWithWhereUniqueWithoutAuthorInput struct {␊
              Where *PostWhereUniqueInput `json:"where,omitempty"`␊
    Update *PostUpdateWithoutAuthorDataInput `json:"update,omitempty"`␊
    Create *PostCreateWithoutAuthorInput `json:"create,omitempty"`␊
                }␊
            ␊
    // UserCreateInput input struct docs␊
          type UserCreateInput struct {␊
              Email *string `json:"email,omitempty"`␊
    Password *string `json:"password,omitempty"`␊
    Name *string `json:"name,omitempty"`␊
    Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`␊
                }␊
            ␊
    // UserCreateWithoutPostsInput input struct docs␊
          type UserCreateWithoutPostsInput struct {␊
              Email *string `json:"email,omitempty"`␊
    Password *string `json:"password,omitempty"`␊
    Name *string `json:"name,omitempty"`␊
                }␊
            ␊
    // UserUpdateOneWithoutPostsInput input struct docs␊
          type UserUpdateOneWithoutPostsInput struct {␊
              Create *UserCreateWithoutPostsInput `json:"create,omitempty"`␊
    Connect *UserWhereUniqueInput `json:"connect,omitempty"`␊
    Delete *bool `json:"delete,omitempty"`␊
    Update *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`␊
    Upsert *UserUpsertWithoutPostsInput `json:"upsert,omitempty"`␊
                }␊
            ␊
    // PostCreateInput input struct docs␊
          type PostCreateInput struct {␊
              IsPublished *bool `json:"isPublished,omitempty"`␊
    Title *string `json:"title,omitempty"`␊
    Text *string `json:"text,omitempty"`␊
    Author *UserCreateOneWithoutPostsInput `json:"author,omitempty"`␊
                }␊
            ␊
    // PostUpdateWithoutAuthorDataInput input struct docs␊
          type PostUpdateWithoutAuthorDataInput struct {␊
              IsPublished *bool `json:"isPublished,omitempty"`␊
    Title *string `json:"title,omitempty"`␊
    Text *string `json:"text,omitempty"`␊
                }␊
            ␊
    // UserWhereUniqueInput input struct docs␊
          type UserWhereUniqueInput struct {␊
              ID *string `json:"id,omitempty"`␊
    Email *string `json:"email,omitempty"`␊
                }␊
            ␊
    // PostSubscriptionWhereInput input struct docs␊
          type PostSubscriptionWhereInput struct {␊
              And *PostSubscriptionWhereInput `json:"AND,omitempty"`␊
    Or *PostSubscriptionWhereInput `json:"OR,omitempty"`␊
    MutationIn *MutationType `json:"mutation_in,omitempty"`␊
    UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`␊
    UpdatedFieldsContainsEvery *string `json:"updatedFields_contains_every,omitempty"`␊
    UpdatedFieldsContainsSome *string `json:"updatedFields_contains_some,omitempty"`␊
    Node *PostWhereInput `json:"node,omitempty"`␊
                }␊
            ␊
    // PostUpdateWithWhereUniqueWithoutAuthorInput input struct docs␊
          type PostUpdateWithWhereUniqueWithoutAuthorInput struct {␊
              Where *PostWhereUniqueInput `json:"where,omitempty"`␊
    Data *PostUpdateWithoutAuthorDataInput `json:"data,omitempty"`␊
                }␊
            ␊
    ␊
          // NodeExec docs␊
          type NodeExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Node docs␊
          type Node interface {␊
            ID() string␊
          }␊
    ␊
          // UserPreviousValuesExec docs␊
          type UserPreviousValuesExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance UserPreviousValuesExec) Exec() (UserPreviousValues, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData UserPreviousValues␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // UserPreviousValuesExecArray docs␊
          type UserPreviousValuesExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance UserPreviousValuesExecArray) Exec() ([]UserPreviousValues, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []UserPreviousValues␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // UserPreviousValues docs - generated with types␊
          type UserPreviousValues struct {␊
              ID string `json:"id"`␊
    Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
                }␊
            ␊
    ␊
          // PostConnectionExec docs␊
          type PostConnectionExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              ␊
              // PageInfo docs - executable for types␊
            func (instance *PostConnectionExec) PageInfo() *PageInfoExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "pageInfo",␊
                    Field: GraphQLField{␊
                      Name: "pageInfo",␊
                      TypeName: "PageInfo",␊
                      TypeFields: []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PageInfoExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
              ␊
              ␊
              // Edges docs - executable for types␊
            func (instance *PostConnectionExec) Edges() *PostEdgeExecArray {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "edges",␊
                    Field: GraphQLField{␊
                      Name: "edges",␊
                      TypeName: "PostEdge",␊
                      TypeFields: []string{"cursor"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PostEdgeExecArray{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
              ␊
              ␊
              // Aggregate docs - executable for types␊
            func (instance *PostConnectionExec) Aggregate() *AggregatePostExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "aggregate",␊
                    Field: GraphQLField{␊
                      Name: "aggregate",␊
                      TypeName: "AggregatePost",␊
                      TypeFields: []string{"count"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &AggregatePostExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostConnectionExec) Exec() (PostConnection, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData PostConnection␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // PostConnectionExecArray docs␊
          type PostConnectionExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance PostConnectionExecArray) Exec() ([]PostConnection, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []PostConnection␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // PostConnection docs - generated with types␊
          type PostConnection struct {␊
              ␊
                }␊
            ␊
    ␊
          // PostExec docs␊
          type PostExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              type AuthorParams struct {␊
                where *UserWhereInput␊
            }␊
              ␊
              ␊
              // Author docs - executable for types␊
            func (instance *PostExec) Author(params *AuthorParams) *UserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
                  args = append(args, GraphQLArg{␊
                    Name: "author",␊
                    Key: "author",␊
                    TypeName: "User",␊
                    Value: params,␊
                  })␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "author",␊
                    Field: GraphQLField{␊
                      Name: "author",␊
                      TypeName: "User",␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &UserExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostExec) Exec() (Post, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData Post␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // PostExecArray docs␊
          type PostExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance PostExecArray) Exec() ([]Post, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []Post␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // Post docs - generated with types␊
          type Post struct {␊
              ID string `json:"id"`␊
    CreatedAt string `json:"createdAt"`␊
    UpdatedAt string `json:"updatedAt"`␊
    IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
                }␊
            ␊
    ␊
          // PageInfoExec docs␊
          type PageInfoExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance PageInfoExec) Exec() (PageInfo, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData PageInfo␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // PageInfoExecArray docs␊
          type PageInfoExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance PageInfoExecArray) Exec() ([]PageInfo, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []PageInfo␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // PageInfo docs - generated with types␊
          type PageInfo struct {␊
              HasNextPage bool `json:"hasNextPage"`␊
    HasPreviousPage bool `json:"hasPreviousPage"`␊
    StartCursor string `json:"startCursor,omitempty"`␊
    EndCursor string `json:"endCursor,omitempty"`␊
                }␊
            ␊
    ␊
          // PostSubscriptionPayloadExec docs␊
          type PostSubscriptionPayloadExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              ␊
              // Node docs - executable for types␊
            func (instance *PostSubscriptionPayloadExec) Node() *PostExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "Post",␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PostExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
              ␊
              ␊
              // PreviousValues docs - executable for types␊
            func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "previousValues",␊
                    Field: GraphQLField{␊
                      Name: "previousValues",␊
                      TypeName: "PostPreviousValues",␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PostPreviousValuesExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostSubscriptionPayloadExec) Exec() (PostSubscriptionPayload, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData PostSubscriptionPayload␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // PostSubscriptionPayloadExecArray docs␊
          type PostSubscriptionPayloadExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance PostSubscriptionPayloadExecArray) Exec() ([]PostSubscriptionPayload, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []PostSubscriptionPayload␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // PostSubscriptionPayload docs - generated with types␊
          type PostSubscriptionPayload struct {␊
              UpdatedFields string `json:"updatedFields"`␊
                }␊
            ␊
    ␊
          // BatchPayloadExec docs␊
          type BatchPayloadExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance BatchPayloadExec) Exec() (BatchPayload, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData BatchPayload␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // BatchPayloadExecArray docs␊
          type BatchPayloadExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance BatchPayloadExecArray) Exec() ([]BatchPayload, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []BatchPayload␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // BatchPayload docs - generated with types␊
          type BatchPayload struct {␊
              Count int64 `json:"count"`␊
                }␊
            ␊
    ␊
          // PostPreviousValuesExec docs␊
          type PostPreviousValuesExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance PostPreviousValuesExec) Exec() (PostPreviousValues, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData PostPreviousValues␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // PostPreviousValuesExecArray docs␊
          type PostPreviousValuesExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance PostPreviousValuesExecArray) Exec() ([]PostPreviousValues, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []PostPreviousValues␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // PostPreviousValues docs - generated with types␊
          type PostPreviousValues struct {␊
              ID string `json:"id"`␊
    CreatedAt string `json:"createdAt"`␊
    UpdatedAt string `json:"updatedAt"`␊
    IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
                }␊
            ␊
    ␊
          // UserExec docs␊
          type UserExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              type PostsParams struct {␊
                where *PostWhereInput␊
    orderBy *PostOrderByInput␊
    skip *int32␊
    after *string␊
    before *string␊
    first *int32␊
    last *int32␊
            }␊
              ␊
              ␊
              // Posts docs - executable for types␊
            func (instance *UserExec) Posts(params *PostsParams) *PostExecArray {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
                  args = append(args, GraphQLArg{␊
                    Name: "posts",␊
                    Key: "posts",␊
                    TypeName: "Post",␊
                    Value: params,␊
                  })␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "posts",␊
                    Field: GraphQLField{␊
                      Name: "posts",␊
                      TypeName: "Post",␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PostExecArray{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserExec) Exec() (User, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData User␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // UserExecArray docs␊
          type UserExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance UserExecArray) Exec() ([]User, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []User␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // User docs - generated with types␊
          type User struct {␊
              ID string `json:"id"`␊
    Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
                }␊
            ␊
    ␊
          // AggregateUserExec docs␊
          type AggregateUserExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance AggregateUserExec) Exec() (AggregateUser, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData AggregateUser␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // AggregateUserExecArray docs␊
          type AggregateUserExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance AggregateUserExecArray) Exec() ([]AggregateUser, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []AggregateUser␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // AggregateUser docs - generated with types␊
          type AggregateUser struct {␊
              Count int32 `json:"count"`␊
                }␊
            ␊
    ␊
          // UserSubscriptionPayloadExec docs␊
          type UserSubscriptionPayloadExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              ␊
              // Node docs - executable for types␊
            func (instance *UserSubscriptionPayloadExec) Node() *UserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "User",␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &UserExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
              ␊
              ␊
              // PreviousValues docs - executable for types␊
            func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "previousValues",␊
                    Field: GraphQLField{␊
                      Name: "previousValues",␊
                      TypeName: "UserPreviousValues",␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &UserPreviousValuesExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserSubscriptionPayloadExec) Exec() (UserSubscriptionPayload, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData UserSubscriptionPayload␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // UserSubscriptionPayloadExecArray docs␊
          type UserSubscriptionPayloadExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance UserSubscriptionPayloadExecArray) Exec() ([]UserSubscriptionPayload, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []UserSubscriptionPayload␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // UserSubscriptionPayload docs - generated with types␊
          type UserSubscriptionPayload struct {␊
              UpdatedFields string `json:"updatedFields"`␊
                }␊
            ␊
    ␊
          // UserEdgeExec docs␊
          type UserEdgeExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              ␊
              // Node docs - executable for types␊
            func (instance *UserEdgeExec) Node() *UserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "User",␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &UserExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserEdgeExec) Exec() (UserEdge, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData UserEdge␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // UserEdgeExecArray docs␊
          type UserEdgeExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance UserEdgeExecArray) Exec() ([]UserEdge, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []UserEdge␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // UserEdge docs - generated with types␊
          type UserEdge struct {␊
              Cursor string `json:"cursor"`␊
                }␊
            ␊
    ␊
          // PostEdgeExec docs␊
          type PostEdgeExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              ␊
              // Node docs - executable for types␊
            func (instance *PostEdgeExec) Node() *PostExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "Post",␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PostExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostEdgeExec) Exec() (PostEdge, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData PostEdge␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // PostEdgeExecArray docs␊
          type PostEdgeExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance PostEdgeExecArray) Exec() ([]PostEdge, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []PostEdge␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // PostEdge docs - generated with types␊
          type PostEdge struct {␊
              Cursor string `json:"cursor"`␊
                }␊
            ␊
    ␊
          // AggregatePostExec docs␊
          type AggregatePostExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance AggregatePostExec) Exec() (AggregatePost, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData AggregatePost␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // AggregatePostExecArray docs␊
          type AggregatePostExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance AggregatePostExecArray) Exec() ([]AggregatePost, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []AggregatePost␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // AggregatePost docs - generated with types␊
          type AggregatePost struct {␊
              Count int32 `json:"count"`␊
                }␊
            ␊
    ␊
          // UserConnectionExec docs␊
          type UserConnectionExec struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          ␊
              ␊
              ␊
              // PageInfo docs - executable for types␊
            func (instance *UserConnectionExec) PageInfo() *PageInfoExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "pageInfo",␊
                    Field: GraphQLField{␊
                      Name: "pageInfo",␊
                      TypeName: "PageInfo",␊
                      TypeFields: []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &PageInfoExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
              ␊
              ␊
              // Edges docs - executable for types␊
            func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "edges",␊
                    Field: GraphQLField{␊
                      Name: "edges",␊
                      TypeName: "UserEdge",␊
                      TypeFields: []string{"cursor"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &UserEdgeExecArray{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
              ␊
              ␊
              // Aggregate docs - executable for types␊
            func (instance *UserConnectionExec) Aggregate() *AggregateUserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  ␊
    ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "aggregate",␊
                    Field: GraphQLField{␊
                      Name: "aggregate",␊
                      TypeName: "AggregateUser",␊
                      TypeFields: []string{"count"},␊
                    },␊
                    Operation: "",␊
                    Args: args,␊
                  })␊
                return &AggregateUserExec{␊
                  client: instance.client,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserConnectionExec) Exec() (UserConnection, error) {␊
            var allArgs []GraphQLArg␊
            variables := make(map[string]interface{})␊
            for instructionKey := range instance.stack {␊
              instruction := &instance.stack[instructionKey]␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for argKey := range instruction.Args {␊
                arg := &instruction.Args[argKey]␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                isUnique := false␊
                for isUnique == false {␊
                  isUnique = true␊
                  for key, existingArg := range allArgs {␊
                    if existingArg.Name == arg.Name {␊
                      isUnique = false␊
                      arg.Name = arg.Name + "_" + strconv.Itoa(key)␊
                      if instance.client.Debug {␊
                        fmt.Println("Resolving Collision Arg Name: ", arg.Name)␊
                      }␊
                      break␊
                    }␊
                  }␊
                }␊
                if instance.client.Debug {␊
                  fmt.Println("Arg Name: ", arg.Name)␊
                }␊
                allArgs = append(allArgs, *arg)␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              unpackedData := data␊
              for _, instruction := range instance.stack {␊
                if instance.client.Debug {␊
                  fmt.Println("Original Unpacked Data Step Exec:", unpackedData)␊
                }␊
                unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})␊
                if instance.client.Debug {␊
                  fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)␊
                  fmt.Println("Unpacked Data Step Exec:", unpackedData)␊
                  fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))␊
                }␊
                genericData = unpackedData␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData UserConnection␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
          ␊
          // UserConnectionExecArray docs␊
          type UserConnectionExecArray struct {␊
            client    Client␊
            stack []Instruction␊
          }␊
    ␊
          // Exec docs␊
          func (instance UserConnectionExecArray) Exec() ([]UserConnection, error) {␊
            query := instance.client.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.client.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.client.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data, err := instance.client.GraphQL(query, variables)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Error Exec:", err)␊
            }␊
    ␊
            var genericData interface{} // This can handle both map[string]interface{} and []interface[]␊
    ␊
            // Is unpacking needed␊
            dataType := reflect.TypeOf(data)␊
            if !isArray(dataType) {␊
              for _, instruction := range instance.stack {␊
                unpackedData := data[instruction.Name]␊
                if isArray(unpackedData) {␊
                  genericData = (unpackedData).([]interface{})␊
                } else {␊
                  genericData = (unpackedData).(map[string]interface{})␊
                }␊
              }␊
            }␊
            if instance.client.Debug {␊
              fmt.Println("Data Unpacked Exec:", genericData)␊
            }␊
    ␊
            var decodedData []UserConnection␊
            mapstructure.Decode(genericData, &decodedData)␊
            if instance.client.Debug {␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData, err␊
          }␊
    ␊
          // UserConnection docs - generated with types␊
          type UserConnection struct {␊
              ␊
                }␊
            ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    // GraphQL Send a GraphQL operation request␊
    func (client Client) GraphQL(query string, variables map[string]interface{}) (map[string]interface{}, error) {␊
    	// TODO: Add auth support␊
    ␊
    	req := graphql.NewRequest(query)␊
    	gqlClient := graphql.NewClient(␊
          (map[bool]string{true: client.Endpoint, false: "http://localhost:4466/test/test"})[client.Endpoint != ""],␊
        )␊
    ␊
    	for key, value := range variables {␊
        req.Var(key, value)␊
    	}␊
    ␊
    	ctx := context.Background()␊
    ␊
    	// var respData ResponseStruct␊
    	var respData map[string]interface{}␊
    	if err := gqlClient.Run(ctx, req, &respData); err != nil {␊
        if client.Debug {␊
          fmt.Println("GraphQL Response:", respData)␊
        }␊
    		return nil, err␊
    	}␊
    	return respData, nil␊
    }␊
            `
