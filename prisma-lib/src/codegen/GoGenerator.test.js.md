# Snapshot report for `dist/codegen/GoGenerator.test.js`

The actual snapshot is saved in `GoGenerator.test.js.snap`.

Generated by [AVA](https://ava.li).

## go generator

> Snapshot 1

    `␊
    package prisma␊
    ␊
    import (␊
    	"context"␊
      "log"␊
      "reflect"␊
      "fmt"␊
      "bytes"␊
      "text/template"␊
    ␊
      "github.com/machinebox/graphql"␊
      "github.com/mitchellh/mapstructure"␊
    )␊
    ␊
    // GraphQLField docs␊
    type GraphQLField struct {␊
      Name string␊
      TypeName string␊
      TypeFields []string␊
    }␊
    ␊
    // GraphQLArg docs␊
    type GraphQLArg struct {␊
      Name string␊
      TypeName string␊
      Value interface{}␊
    }␊
    ␊
    // Instruction docs␊
    type Instruction struct {␊
      Name string␊
      Field GraphQLField␊
      Operation string␊
    	Args []GraphQLArg␊
    }␊
    ␊
    // DB Type to represent the client␊
    type DB struct {␊
      Endpoint string // TODO: Remove the Endpoint from here and print it where needed.␊
      Debug bool␊
    }␊
    ␊
    // ProcessInstructions docs␊
    func (db *DB) ProcessInstructions(stack []Instruction) string {␊
      query := make(map[string]interface{})␊
      // TODO: This needs to handle collisions across instructions␊
    	args := make(map[string][]GraphQLArg)␊
    	firstInstruction := stack[0]␊
    	for i := len(stack) - 1; i >= 0; i-- {␊
    		instruction := stack[i]␊
    		if db.Debug {␊
    			fmt.Println("Instruction: ", instruction)␊
    		}␊
    		if len(query) == 0 {␊
    			query[instruction.Name] = instruction.Field.TypeFields␊
    			args[instruction.Name] = instruction.Args␊
    		} else {␊
    			previousInstruction := stack[i+1]␊
    			query[instruction.Name] = map[string]interface{}{␊
    				previousInstruction.Name: query[previousInstruction.Name],␊
    			}␊
    			args[instruction.Name] = instruction.Args␊
    			delete(query, previousInstruction.Name)␊
    		}␊
    	}␊
    ␊
    	if db.Debug {␊
    		fmt.Println("Final Query:", query)␊
    		fmt.Println("Final Args:", args)␊
    	}␊
    ␊
    	// TODO: Make this recursive - current depth = 3␊
    	queryTemplateString := `␊
      {{ $.operation }} {{ $.operationName }} (␊
        {{- range $k0, $v0 := $.args }}␊
          {{- range $k1, $v1 := $v0}}␊
            ${{ $v1.Name }}: {{ $v1.TypeName }},␊
          {{- end }}␊
        {{- end }}␊
        ) {␊
        {{- range $k, $v := $.query }}␊
        {{- if isArray $v }}␊
          {{- $k }} (␊
            {{- range $argKey, $argValue := $.args }}␊
              {{- if eq $argKey $k }}␊
                {{- range $k, $arg := $argValue}}␊
                  {{ $arg.Name }}: ${{ $arg.Name }},␊
                {{- end }}␊
              {{- end }}␊
            {{- end }}␊
          ) {␊
            {{- range $k1, $v1 := $v }}␊
              {{ $v1 }}␊
            {{end}}␊
          }␊
        {{- else }}␊
          {{ $k }} (␊
            {{- range $argKey, $argValue := $.args }}␊
              {{- if eq $argKey $k }}␊
                {{- range $k, $arg := $argValue}}␊
                  {{ $arg.Name }}: ${{ $arg.Name }},␊
                {{- end }}␊
              {{- end }}␊
            {{- end }}␊
            ) {␊
            {{- range $k, $v := $v }}␊
            {{- if isArray $v }}␊
              {{ $k }} (␊
                {{- range $argKey, $argValue := $.args }}␊
                  {{- if eq $argKey $k }}␊
                    {{- range $k, $arg := $argValue}}␊
                      {{ $arg.Name }}: ${{ $arg.Name }},␊
                    {{- end }}␊
                  {{- end }}␊
                {{- end }}␊
                ) { ␊
                {{- range $k1, $v1 := $v }}␊
                  {{ $v1 }}␊
                {{end}}␊
              }␊
            {{- else }}␊
              {{ $k }} (␊
                {{- range $argKey, $argValue := $.args }}␊
                  {{- if eq $argKey $k }}␊
                    {{- range $k, $arg := $argValue}}␊
                      {{ $arg.Name }}: ${{ $arg.Name }},␊
                    {{- end }}␊
                  {{- end }}␊
                {{- end }}␊
                ) {␊
                {{- range $k, $v := $v }}␊
                  {{- if isArray $v }}␊
                    {{ $k }} { ␊
                      {{- range $k1, $v1 := $v }}␊
                        {{ $v1 }}␊
                      {{end}}␊
                    }␊
                  {{- else }}␊
                    {{ $k }} (␊
                      {{- range $argKey, $argValue := $.args }}␊
                        {{- if eq $argKey $k }}␊
                          {{- range $k, $arg := $argValue}}␊
                            {{ $arg.Name }}: ${{ $arg.Name }},␊
                          {{- end }}␊
                        {{- end }}␊
                      {{- end }}␊
                      ) {␊
                      id␊
                    }␊
                  {{- end }}␊
                  {{- end }}␊
              }␊
            {{- end }}␊
            {{- end }}␊
          }␊
        {{- end }}␊
        {{- end }}␊
        }␊
      `␊
    ␊
    	templateFunctions := template.FuncMap{␊
    		"isArray": func(i interface{}) bool {␊
    			v := reflect.ValueOf(i)␊
    			fmt.Println(v.Kind())␊
    			switch v.Kind() {␊
    			case reflect.Array:␊
    				return true␊
    			case reflect.Slice:␊
    				return true␊
    			default:␊
    				return false␊
    			}␊
    		},␊
    	}␊
    ␊
    	queryTemplate, err := template.New("query").Funcs(templateFunctions).Parse(queryTemplateString)␊
    	var queryBytes bytes.Buffer␊
    	var data = make(map[string]interface{})␊
    	data = map[string]interface{}{␊
    		"query":         query,␊
    		"args":          args,␊
    		"operation":     firstInstruction.Operation,␊
    		"operationName": firstInstruction.Name,␊
    	}␊
    	fmt.Println(args)␊
    	queryTemplate.Execute(&queryBytes, data)␊
    ␊
    	if db.Debug {␊
    		fmt.Println("Query String: ", queryBytes.String())␊
    	}␊
    	if err == nil {␊
    		return queryBytes.String()␊
    	}␊
    	return "Failed to generate query"␊
    }␊
    ␊
    // Queries␊
    ␊
              // PostsParams docs␊
              type PostsParams struct {␊
                Where PostWhereInput `json:"where,omitempty"`␊
    OrderBy PostOrderByInput `json:"orderBy,omitempty"`␊
    Skip int32 `json:"skip,omitempty"`␊
    After string `json:"after,omitempty"`␊
    Before string `json:"before,omitempty"`␊
    First int32 `json:"first,omitempty"`␊
    Last int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // Posts docs␊
              func (db DB) Posts (params PostsParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereInput",␊
                Value: params.Where,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "orderBy",␊
                TypeName: "PostOrderByInput",␊
                Value: params.OrderBy,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "skip",␊
                TypeName: "Int",␊
                Value: params.Skip,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "after",␊
                TypeName: "String",␊
                Value: params.After,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "before",␊
                TypeName: "String",␊
                Value: params.Before,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "first",␊
                TypeName: "Int",␊
                Value: params.First,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "last",␊
                TypeName: "Int",␊
                Value: params.Last,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "posts",␊
                Field: GraphQLField{␊
                  Name: "posts",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &PostExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UsersParams docs␊
              type UsersParams struct {␊
                Where UserWhereInput `json:"where,omitempty"`␊
    OrderBy UserOrderByInput `json:"orderBy,omitempty"`␊
    Skip int32 `json:"skip,omitempty"`␊
    After string `json:"after,omitempty"`␊
    Before string `json:"before,omitempty"`␊
    First int32 `json:"first,omitempty"`␊
    Last int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // Users docs␊
              func (db DB) Users (params UsersParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereInput",␊
                Value: params.Where,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "orderBy",␊
                TypeName: "UserOrderByInput",␊
                Value: params.OrderBy,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "skip",␊
                TypeName: "Int",␊
                Value: params.Skip,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "after",␊
                TypeName: "String",␊
                Value: params.After,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "before",␊
                TypeName: "String",␊
                Value: params.Before,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "first",␊
                TypeName: "Int",␊
                Value: params.First,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "last",␊
                TypeName: "Int",␊
                Value: params.Last,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "users",␊
                Field: GraphQLField{␊
                  Name: "users",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &UserExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // PostParams docs␊
              type PostParams struct {␊
                Where PostWhereUniqueInput `json:"where,omitempty"`␊
              }␊
              ␊
              // Post docs␊
              func (db DB) Post (params PostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "post",␊
                Field: GraphQLField{␊
                  Name: "post",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &PostExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UserParams docs␊
              type UserParams struct {␊
                Where UserWhereUniqueInput `json:"where,omitempty"`␊
              }␊
              ␊
              // User docs␊
              func (db DB) User (params UserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "user",␊
                Field: GraphQLField{␊
                  Name: "user",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &UserExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // PostsConnectionParams docs␊
              type PostsConnectionParams struct {␊
                Where PostWhereInput `json:"where,omitempty"`␊
    OrderBy PostOrderByInput `json:"orderBy,omitempty"`␊
    Skip int32 `json:"skip,omitempty"`␊
    After string `json:"after,omitempty"`␊
    Before string `json:"before,omitempty"`␊
    First int32 `json:"first,omitempty"`␊
    Last int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // PostsConnection docs␊
              func (db DB) PostsConnection (params PostsConnectionParams) *PostConnectionExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereInput",␊
                Value: params.Where,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "orderBy",␊
                TypeName: "PostOrderByInput",␊
                Value: params.OrderBy,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "skip",␊
                TypeName: "Int",␊
                Value: params.Skip,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "after",␊
                TypeName: "String",␊
                Value: params.After,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "before",␊
                TypeName: "String",␊
                Value: params.Before,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "first",␊
                TypeName: "Int",␊
                Value: params.First,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "last",␊
                TypeName: "Int",␊
                Value: params.Last,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "postsConnection",␊
                Field: GraphQLField{␊
                  Name: "postsConnection",␊
                  TypeName: "PostConnection",␊
                  TypeFields: []string{},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &PostConnectionExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UsersConnectionParams docs␊
              type UsersConnectionParams struct {␊
                Where UserWhereInput `json:"where,omitempty"`␊
    OrderBy UserOrderByInput `json:"orderBy,omitempty"`␊
    Skip int32 `json:"skip,omitempty"`␊
    After string `json:"after,omitempty"`␊
    Before string `json:"before,omitempty"`␊
    First int32 `json:"first,omitempty"`␊
    Last int32 `json:"last,omitempty"`␊
              }␊
              ␊
              // UsersConnection docs␊
              func (db DB) UsersConnection (params UsersConnectionParams) *UserConnectionExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereInput",␊
                Value: params.Where,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "orderBy",␊
                TypeName: "UserOrderByInput",␊
                Value: params.OrderBy,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "skip",␊
                TypeName: "Int",␊
                Value: params.Skip,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "after",␊
                TypeName: "String",␊
                Value: params.After,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "before",␊
                TypeName: "String",␊
                Value: params.Before,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "first",␊
                TypeName: "Int",␊
                Value: params.First,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "last",␊
                TypeName: "Int",␊
                Value: params.Last,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "usersConnection",␊
                Field: GraphQLField{␊
                  Name: "usersConnection",␊
                  TypeName: "UserConnection",␊
                  TypeFields: []string{},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &UserConnectionExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // NodeParams docs␊
              type NodeParams struct {␊
                ID string `json:"id,omitempty"`␊
              }␊
              ␊
              // Node docs␊
              func (db DB) Node (params NodeParams) *NodeExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "id",␊
                TypeName: "ID!",␊
                Value: params.ID,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "node",␊
                Field: GraphQLField{␊
                  Name: "node",␊
                  TypeName: "Node",␊
                  TypeFields: []string{},␊
                },␊
                Operation: "query",␊
                Args: args,␊
              })␊
    ␊
          return &NodeExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
    // Mutations␊
    ␊
              // CreatePostParams docs␊
              type CreatePostParams struct {␊
                Data PostCreateInput `json:"data,omitempty"`␊
              }␊
              ␊
              // CreatePost docs␊
              func (db DB) CreatePost (params CreatePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "data",␊
                TypeName: "PostCreateInput!",␊
                Value: params.Data,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "createPost",␊
                Field: GraphQLField{␊
                  Name: "createPost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &PostExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // CreateUserParams docs␊
              type CreateUserParams struct {␊
                Data UserCreateInput `json:"data,omitempty"`␊
              }␊
              ␊
              // CreateUser docs␊
              func (db DB) CreateUser (params CreateUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "data",␊
                TypeName: "UserCreateInput!",␊
                Value: params.Data,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "createUser",␊
                Field: GraphQLField{␊
                  Name: "createUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &UserExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdatePostParams docs␊
              type UpdatePostParams struct {␊
                Data PostUpdateInput `json:"data,omitempty"`␊
    Where PostWhereUniqueInput `json:"where,omitempty"`␊
              }␊
              ␊
              // UpdatePost docs␊
              func (db DB) UpdatePost (params UpdatePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "data",␊
                TypeName: "PostUpdateInput!",␊
                Value: params.Data,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updatePost",␊
                Field: GraphQLField{␊
                  Name: "updatePost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &PostExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdateUserParams docs␊
              type UpdateUserParams struct {␊
                Data UserUpdateInput `json:"data,omitempty"`␊
    Where UserWhereUniqueInput `json:"where,omitempty"`␊
              }␊
              ␊
              // UpdateUser docs␊
              func (db DB) UpdateUser (params UpdateUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "data",␊
                TypeName: "UserUpdateInput!",␊
                Value: params.Data,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updateUser",␊
                Field: GraphQLField{␊
                  Name: "updateUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &UserExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeletePostParams docs␊
              type DeletePostParams struct {␊
                Where PostWhereUniqueInput `json:"where,omitempty"`␊
              }␊
              ␊
              // DeletePost docs␊
              func (db DB) DeletePost (params DeletePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deletePost",␊
                Field: GraphQLField{␊
                  Name: "deletePost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &PostExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeleteUserParams docs␊
              type DeleteUserParams struct {␊
                Where UserWhereUniqueInput `json:"where,omitempty"`␊
              }␊
              ␊
              // DeleteUser docs␊
              func (db DB) DeleteUser (params DeleteUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deleteUser",␊
                Field: GraphQLField{␊
                  Name: "deleteUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &UserExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpsertPostParams docs␊
              type UpsertPostParams struct {␊
                Where PostWhereUniqueInput `json:"where,omitempty"`␊
    Create PostCreateInput `json:"create,omitempty"`␊
    Update PostUpdateInput `json:"update,omitempty"`␊
              }␊
              ␊
              // UpsertPost docs␊
              func (db DB) UpsertPost (params UpsertPostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "create",␊
                TypeName: "PostCreateInput!",␊
                Value: params.Create,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "update",␊
                TypeName: "PostUpdateInput!",␊
                Value: params.Update,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "upsertPost",␊
                Field: GraphQLField{␊
                  Name: "upsertPost",␊
                  TypeName: "Post",␊
                  TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &PostExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpsertUserParams docs␊
              type UpsertUserParams struct {␊
                Where UserWhereUniqueInput `json:"where,omitempty"`␊
    Create UserCreateInput `json:"create,omitempty"`␊
    Update UserUpdateInput `json:"update,omitempty"`␊
              }␊
              ␊
              // UpsertUser docs␊
              func (db DB) UpsertUser (params UpsertUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereUniqueInput!",␊
                Value: params.Where,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "create",␊
                TypeName: "UserCreateInput!",␊
                Value: params.Create,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "update",␊
                TypeName: "UserUpdateInput!",␊
                Value: params.Update,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "upsertUser",␊
                Field: GraphQLField{␊
                  Name: "upsertUser",␊
                  TypeName: "User",␊
                  TypeFields: []string{"id","email","password","name"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &UserExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdateManyPostsParams docs␊
              type UpdateManyPostsParams struct {␊
                Data PostUpdateInput `json:"data,omitempty"`␊
    Where PostWhereInput `json:"where,omitempty"`␊
              }␊
              ␊
              // UpdateManyPosts docs␊
              func (db DB) UpdateManyPosts (params UpdateManyPostsParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "data",␊
                TypeName: "PostUpdateInput!",␊
                Value: params.Data,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updateManyPosts",␊
                Field: GraphQLField{␊
                  Name: "updateManyPosts",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdateManyUsersParams docs␊
              type UpdateManyUsersParams struct {␊
                Data UserUpdateInput `json:"data,omitempty"`␊
    Where UserWhereInput `json:"where,omitempty"`␊
              }␊
              ␊
              // UpdateManyUsers docs␊
              func (db DB) UpdateManyUsers (params UpdateManyUsersParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "data",␊
                TypeName: "UserUpdateInput!",␊
                Value: params.Data,␊
              })␊
    args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "updateManyUsers",␊
                Field: GraphQLField{␊
                  Name: "updateManyUsers",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeleteManyPostsParams docs␊
              type DeleteManyPostsParams struct {␊
                Where PostWhereInput `json:"where,omitempty"`␊
              }␊
              ␊
              // DeleteManyPosts docs␊
              func (db DB) DeleteManyPosts (params DeleteManyPostsParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "PostWhereInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deleteManyPosts",␊
                Field: GraphQLField{␊
                  Name: "deleteManyPosts",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeleteManyUsersParams docs␊
              type DeleteManyUsersParams struct {␊
                Where UserWhereInput `json:"where,omitempty"`␊
              }␊
              ␊
              // DeleteManyUsers docs␊
              func (db DB) DeleteManyUsers (params DeleteManyUsersParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []GraphQLArg␊
              args = append(args, GraphQLArg{␊
                Name: "where",␊
                TypeName: "UserWhereInput!",␊
                Value: params.Where,␊
              })␊
              ␊
              stack = append(stack, Instruction{␊
                Name: "deleteManyUsers",␊
                Field: GraphQLField{␊
                  Name: "deleteManyUsers",␊
                  TypeName: "BatchPayload",␊
                  TypeFields: []string{"count"},␊
                },␊
                Operation: "mutation",␊
                Args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              db: db,␊
              stack: stack,␊
            }␊
            }␊
    ␊
    // Types␊
    ␊
    ␊
                // PostOrderByInput docs␊
                type PostOrderByInput string␊
                const (␊
                    ␊
                          // IDAscPostOrderByInput docs␊
                          IDAscPostOrderByInput PostOrderByInput = "id_ASC"␊
    ␊
                          // IDDescPostOrderByInput docs␊
                          IDDescPostOrderByInput PostOrderByInput = "id_DESC"␊
    ␊
                          // CreatedAtAscPostOrderByInput docs␊
                          CreatedAtAscPostOrderByInput PostOrderByInput = "createdAt_ASC"␊
    ␊
                          // CreatedAtDescPostOrderByInput docs␊
                          CreatedAtDescPostOrderByInput PostOrderByInput = "createdAt_DESC"␊
    ␊
                          // UpdatedAtAscPostOrderByInput docs␊
                          UpdatedAtAscPostOrderByInput PostOrderByInput = "updatedAt_ASC"␊
    ␊
                          // UpdatedAtDescPostOrderByInput docs␊
                          UpdatedAtDescPostOrderByInput PostOrderByInput = "updatedAt_DESC"␊
    ␊
                          // IsPublishedAscPostOrderByInput docs␊
                          IsPublishedAscPostOrderByInput PostOrderByInput = "isPublished_ASC"␊
    ␊
                          // IsPublishedDescPostOrderByInput docs␊
                          IsPublishedDescPostOrderByInput PostOrderByInput = "isPublished_DESC"␊
    ␊
                          // TitleAscPostOrderByInput docs␊
                          TitleAscPostOrderByInput PostOrderByInput = "title_ASC"␊
    ␊
                          // TitleDescPostOrderByInput docs␊
                          TitleDescPostOrderByInput PostOrderByInput = "title_DESC"␊
    ␊
                          // TextAscPostOrderByInput docs␊
                          TextAscPostOrderByInput PostOrderByInput = "text_ASC"␊
    ␊
                          // TextDescPostOrderByInput docs␊
                          TextDescPostOrderByInput PostOrderByInput = "text_DESC"␊
                )␊
            ␊
    ␊
                // UserOrderByInput docs␊
                type UserOrderByInput string␊
                const (␊
                    ␊
                          // IDAscUserOrderByInput docs␊
                          IDAscUserOrderByInput UserOrderByInput = "id_ASC"␊
    ␊
                          // IDDescUserOrderByInput docs␊
                          IDDescUserOrderByInput UserOrderByInput = "id_DESC"␊
    ␊
                          // EmailAscUserOrderByInput docs␊
                          EmailAscUserOrderByInput UserOrderByInput = "email_ASC"␊
    ␊
                          // EmailDescUserOrderByInput docs␊
                          EmailDescUserOrderByInput UserOrderByInput = "email_DESC"␊
    ␊
                          // PasswordAscUserOrderByInput docs␊
                          PasswordAscUserOrderByInput UserOrderByInput = "password_ASC"␊
    ␊
                          // PasswordDescUserOrderByInput docs␊
                          PasswordDescUserOrderByInput UserOrderByInput = "password_DESC"␊
    ␊
                          // NameAscUserOrderByInput docs␊
                          NameAscUserOrderByInput UserOrderByInput = "name_ASC"␊
    ␊
                          // NameDescUserOrderByInput docs␊
                          NameDescUserOrderByInput UserOrderByInput = "name_DESC"␊
    ␊
                          // UpdatedAtAscUserOrderByInput docs␊
                          UpdatedAtAscUserOrderByInput UserOrderByInput = "updatedAt_ASC"␊
    ␊
                          // UpdatedAtDescUserOrderByInput docs␊
                          UpdatedAtDescUserOrderByInput UserOrderByInput = "updatedAt_DESC"␊
    ␊
                          // CreatedAtAscUserOrderByInput docs␊
                          CreatedAtAscUserOrderByInput UserOrderByInput = "createdAt_ASC"␊
    ␊
                          // CreatedAtDescUserOrderByInput docs␊
                          CreatedAtDescUserOrderByInput UserOrderByInput = "createdAt_DESC"␊
                )␊
            ␊
    ␊
                // MutationType docs␊
                type MutationType string␊
                const (␊
                    ␊
                          // CreatedMutationType docs␊
                          CreatedMutationType MutationType = "CREATED"␊
    ␊
                          // UpdatedMutationType docs␊
                          UpdatedMutationType MutationType = "UPDATED"␊
    ␊
                          // DeletedMutationType docs␊
                          DeletedMutationType MutationType = "DELETED"␊
                )␊
            ␊
    // UserCreateOneWithoutPostsInput docs␊
          type UserCreateOneWithoutPostsInput struct {␊
              Create *UserCreateWithoutPostsInput `json:"create,omitempty"`␊
    Connect *UserWhereUniqueInput `json:"connect,omitempty"`␊
                }␊
            ␊
    // PostWhereInput docs␊
          type PostWhereInput struct {␊
              And *PostWhereInput `json:"AND,omitempty"`␊
    Or *PostWhereInput `json:"OR,omitempty"`␊
    ID string `json:"id,omitempty"`␊
    IDNot string `json:"id_not,omitempty"`␊
    IDIn string `json:"id_in,omitempty"`␊
    IDNotIn string `json:"id_not_in,omitempty"`␊
    IDLt string `json:"id_lt,omitempty"`␊
    IDLte string `json:"id_lte,omitempty"`␊
    IDGt string `json:"id_gt,omitempty"`␊
    IDGte string `json:"id_gte,omitempty"`␊
    IDContains string `json:"id_contains,omitempty"`␊
    IDNotContains string `json:"id_not_contains,omitempty"`␊
    IDStartsWith string `json:"id_starts_with,omitempty"`␊
    IDNotStartsWith string `json:"id_not_starts_with,omitempty"`␊
    IDEndsWith string `json:"id_ends_with,omitempty"`␊
    IDNotEndsWith string `json:"id_not_ends_with,omitempty"`␊
    CreatedAt string `json:"createdAt,omitempty"`␊
    CreatedAtNot string `json:"createdAt_not,omitempty"`␊
    CreatedAtIn string `json:"createdAt_in,omitempty"`␊
    CreatedAtNotIn string `json:"createdAt_not_in,omitempty"`␊
    CreatedAtLt string `json:"createdAt_lt,omitempty"`␊
    CreatedAtLte string `json:"createdAt_lte,omitempty"`␊
    CreatedAtGt string `json:"createdAt_gt,omitempty"`␊
    CreatedAtGte string `json:"createdAt_gte,omitempty"`␊
    UpdatedAt string `json:"updatedAt,omitempty"`␊
    UpdatedAtNot string `json:"updatedAt_not,omitempty"`␊
    UpdatedAtIn string `json:"updatedAt_in,omitempty"`␊
    UpdatedAtNotIn string `json:"updatedAt_not_in,omitempty"`␊
    UpdatedAtLt string `json:"updatedAt_lt,omitempty"`␊
    UpdatedAtLte string `json:"updatedAt_lte,omitempty"`␊
    UpdatedAtGt string `json:"updatedAt_gt,omitempty"`␊
    UpdatedAtGte string `json:"updatedAt_gte,omitempty"`␊
    IsPublished bool `json:"isPublished,omitempty"`␊
    IsPublishedNot bool `json:"isPublished_not,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    TitleNot string `json:"title_not,omitempty"`␊
    TitleIn string `json:"title_in,omitempty"`␊
    TitleNotIn string `json:"title_not_in,omitempty"`␊
    TitleLt string `json:"title_lt,omitempty"`␊
    TitleLte string `json:"title_lte,omitempty"`␊
    TitleGt string `json:"title_gt,omitempty"`␊
    TitleGte string `json:"title_gte,omitempty"`␊
    TitleContains string `json:"title_contains,omitempty"`␊
    TitleNotContains string `json:"title_not_contains,omitempty"`␊
    TitleStartsWith string `json:"title_starts_with,omitempty"`␊
    TitleNotStartsWith string `json:"title_not_starts_with,omitempty"`␊
    TitleEndsWith string `json:"title_ends_with,omitempty"`␊
    TitleNotEndsWith string `json:"title_not_ends_with,omitempty"`␊
    Text string `json:"text,omitempty"`␊
    TextNot string `json:"text_not,omitempty"`␊
    TextIn string `json:"text_in,omitempty"`␊
    TextNotIn string `json:"text_not_in,omitempty"`␊
    TextLt string `json:"text_lt,omitempty"`␊
    TextLte string `json:"text_lte,omitempty"`␊
    TextGt string `json:"text_gt,omitempty"`␊
    TextGte string `json:"text_gte,omitempty"`␊
    TextContains string `json:"text_contains,omitempty"`␊
    TextNotContains string `json:"text_not_contains,omitempty"`␊
    TextStartsWith string `json:"text_starts_with,omitempty"`␊
    TextNotStartsWith string `json:"text_not_starts_with,omitempty"`␊
    TextEndsWith string `json:"text_ends_with,omitempty"`␊
    TextNotEndsWith string `json:"text_not_ends_with,omitempty"`␊
    Author *UserWhereInput `json:"author,omitempty"`␊
                }␊
            ␊
    // PostCreateManyWithoutAuthorInput docs␊
          type PostCreateManyWithoutAuthorInput struct {␊
              Create *PostCreateWithoutAuthorInput `json:"create,omitempty"`␊
    Connect *PostWhereUniqueInput `json:"connect,omitempty"`␊
                }␊
            ␊
    // UserWhereInput docs␊
          type UserWhereInput struct {␊
              And *UserWhereInput `json:"AND,omitempty"`␊
    Or *UserWhereInput `json:"OR,omitempty"`␊
    ID string `json:"id,omitempty"`␊
    IDNot string `json:"id_not,omitempty"`␊
    IDIn string `json:"id_in,omitempty"`␊
    IDNotIn string `json:"id_not_in,omitempty"`␊
    IDLt string `json:"id_lt,omitempty"`␊
    IDLte string `json:"id_lte,omitempty"`␊
    IDGt string `json:"id_gt,omitempty"`␊
    IDGte string `json:"id_gte,omitempty"`␊
    IDContains string `json:"id_contains,omitempty"`␊
    IDNotContains string `json:"id_not_contains,omitempty"`␊
    IDStartsWith string `json:"id_starts_with,omitempty"`␊
    IDNotStartsWith string `json:"id_not_starts_with,omitempty"`␊
    IDEndsWith string `json:"id_ends_with,omitempty"`␊
    IDNotEndsWith string `json:"id_not_ends_with,omitempty"`␊
    Email string `json:"email,omitempty"`␊
    EmailNot string `json:"email_not,omitempty"`␊
    EmailIn string `json:"email_in,omitempty"`␊
    EmailNotIn string `json:"email_not_in,omitempty"`␊
    EmailLt string `json:"email_lt,omitempty"`␊
    EmailLte string `json:"email_lte,omitempty"`␊
    EmailGt string `json:"email_gt,omitempty"`␊
    EmailGte string `json:"email_gte,omitempty"`␊
    EmailContains string `json:"email_contains,omitempty"`␊
    EmailNotContains string `json:"email_not_contains,omitempty"`␊
    EmailStartsWith string `json:"email_starts_with,omitempty"`␊
    EmailNotStartsWith string `json:"email_not_starts_with,omitempty"`␊
    EmailEndsWith string `json:"email_ends_with,omitempty"`␊
    EmailNotEndsWith string `json:"email_not_ends_with,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    PasswordNot string `json:"password_not,omitempty"`␊
    PasswordIn string `json:"password_in,omitempty"`␊
    PasswordNotIn string `json:"password_not_in,omitempty"`␊
    PasswordLt string `json:"password_lt,omitempty"`␊
    PasswordLte string `json:"password_lte,omitempty"`␊
    PasswordGt string `json:"password_gt,omitempty"`␊
    PasswordGte string `json:"password_gte,omitempty"`␊
    PasswordContains string `json:"password_contains,omitempty"`␊
    PasswordNotContains string `json:"password_not_contains,omitempty"`␊
    PasswordStartsWith string `json:"password_starts_with,omitempty"`␊
    PasswordNotStartsWith string `json:"password_not_starts_with,omitempty"`␊
    PasswordEndsWith string `json:"password_ends_with,omitempty"`␊
    PasswordNotEndsWith string `json:"password_not_ends_with,omitempty"`␊
    Name string `json:"name,omitempty"`␊
    NameNot string `json:"name_not,omitempty"`␊
    NameIn string `json:"name_in,omitempty"`␊
    NameNotIn string `json:"name_not_in,omitempty"`␊
    NameLt string `json:"name_lt,omitempty"`␊
    NameLte string `json:"name_lte,omitempty"`␊
    NameGt string `json:"name_gt,omitempty"`␊
    NameGte string `json:"name_gte,omitempty"`␊
    NameContains string `json:"name_contains,omitempty"`␊
    NameNotContains string `json:"name_not_contains,omitempty"`␊
    NameStartsWith string `json:"name_starts_with,omitempty"`␊
    NameNotStartsWith string `json:"name_not_starts_with,omitempty"`␊
    NameEndsWith string `json:"name_ends_with,omitempty"`␊
    NameNotEndsWith string `json:"name_not_ends_with,omitempty"`␊
    PostsEvery *PostWhereInput `json:"posts_every,omitempty"`␊
    PostsSome *PostWhereInput `json:"posts_some,omitempty"`␊
    PostsNone *PostWhereInput `json:"posts_none,omitempty"`␊
                }␊
            ␊
    // PostUpdateManyWithoutAuthorInput docs␊
          type PostUpdateManyWithoutAuthorInput struct {␊
              Create *PostCreateWithoutAuthorInput `json:"create,omitempty"`␊
    Connect *PostWhereUniqueInput `json:"connect,omitempty"`␊
    Disconnect *PostWhereUniqueInput `json:"disconnect,omitempty"`␊
    Delete *PostWhereUniqueInput `json:"delete,omitempty"`␊
    Update *PostUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`␊
    Upsert *PostUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`␊
                }␊
            ␊
    // PostUpdateInput docs␊
          type PostUpdateInput struct {␊
              IsPublished bool `json:"isPublished,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    Text string `json:"text,omitempty"`␊
    Author *UserUpdateOneWithoutPostsInput `json:"author,omitempty"`␊
                }␊
            ␊
    // UserUpdateInput docs␊
          type UserUpdateInput struct {␊
              Email string `json:"email,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    Name string `json:"name,omitempty"`␊
    Posts *PostUpdateManyWithoutAuthorInput `json:"posts,omitempty"`␊
                }␊
            ␊
    // PostCreateWithoutAuthorInput docs␊
          type PostCreateWithoutAuthorInput struct {␊
              IsPublished bool `json:"isPublished,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    Text string `json:"text,omitempty"`␊
                }␊
            ␊
    // UserUpsertWithoutPostsInput docs␊
          type UserUpsertWithoutPostsInput struct {␊
              Update *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`␊
    Create *UserCreateWithoutPostsInput `json:"create,omitempty"`␊
                }␊
            ␊
    // UserSubscriptionWhereInput docs␊
          type UserSubscriptionWhereInput struct {␊
              And *UserSubscriptionWhereInput `json:"AND,omitempty"`␊
    Or *UserSubscriptionWhereInput `json:"OR,omitempty"`␊
    MutationIn *MutationType `json:"mutation_in,omitempty"`␊
    UpdatedFieldsContains string `json:"updatedFields_contains,omitempty"`␊
    UpdatedFieldsContainsEvery string `json:"updatedFields_contains_every,omitempty"`␊
    UpdatedFieldsContainsSome string `json:"updatedFields_contains_some,omitempty"`␊
    Node *UserWhereInput `json:"node,omitempty"`␊
                }␊
            ␊
    // UserUpdateWithoutPostsDataInput docs␊
          type UserUpdateWithoutPostsDataInput struct {␊
              Email string `json:"email,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    Name string `json:"name,omitempty"`␊
                }␊
            ␊
    // PostWhereUniqueInput docs␊
          type PostWhereUniqueInput struct {␊
              ID string `json:"id,omitempty"`␊
                }␊
            ␊
    // PostUpsertWithWhereUniqueWithoutAuthorInput docs␊
          type PostUpsertWithWhereUniqueWithoutAuthorInput struct {␊
              Where *PostWhereUniqueInput `json:"where,omitempty"`␊
    Update *PostUpdateWithoutAuthorDataInput `json:"update,omitempty"`␊
    Create *PostCreateWithoutAuthorInput `json:"create,omitempty"`␊
                }␊
            ␊
    // UserCreateInput docs␊
          type UserCreateInput struct {␊
              Email string `json:"email,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    Name string `json:"name,omitempty"`␊
    Posts *PostCreateManyWithoutAuthorInput `json:"posts,omitempty"`␊
                }␊
            ␊
    // UserCreateWithoutPostsInput docs␊
          type UserCreateWithoutPostsInput struct {␊
              Email string `json:"email,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    Name string `json:"name,omitempty"`␊
                }␊
            ␊
    // UserUpdateOneWithoutPostsInput docs␊
          type UserUpdateOneWithoutPostsInput struct {␊
              Create *UserCreateWithoutPostsInput `json:"create,omitempty"`␊
    Connect *UserWhereUniqueInput `json:"connect,omitempty"`␊
    Delete bool `json:"delete,omitempty"`␊
    Update *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`␊
    Upsert *UserUpsertWithoutPostsInput `json:"upsert,omitempty"`␊
                }␊
            ␊
    // PostCreateInput docs␊
          type PostCreateInput struct {␊
              IsPublished bool `json:"isPublished,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    Text string `json:"text,omitempty"`␊
    Author *UserCreateOneWithoutPostsInput `json:"author,omitempty"`␊
                }␊
            ␊
    // PostUpdateWithoutAuthorDataInput docs␊
          type PostUpdateWithoutAuthorDataInput struct {␊
              IsPublished bool `json:"isPublished,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    Text string `json:"text,omitempty"`␊
                }␊
            ␊
    // UserWhereUniqueInput docs␊
          type UserWhereUniqueInput struct {␊
              ID string `json:"id,omitempty"`␊
    Email string `json:"email,omitempty"`␊
                }␊
            ␊
    // PostSubscriptionWhereInput docs␊
          type PostSubscriptionWhereInput struct {␊
              And *PostSubscriptionWhereInput `json:"AND,omitempty"`␊
    Or *PostSubscriptionWhereInput `json:"OR,omitempty"`␊
    MutationIn *MutationType `json:"mutation_in,omitempty"`␊
    UpdatedFieldsContains string `json:"updatedFields_contains,omitempty"`␊
    UpdatedFieldsContainsEvery string `json:"updatedFields_contains_every,omitempty"`␊
    UpdatedFieldsContainsSome string `json:"updatedFields_contains_some,omitempty"`␊
    Node *PostWhereInput `json:"node,omitempty"`␊
                }␊
            ␊
    // PostUpdateWithWhereUniqueWithoutAuthorInput docs␊
          type PostUpdateWithWhereUniqueWithoutAuthorInput struct {␊
              Where *PostWhereUniqueInput `json:"where,omitempty"`␊
    Data *PostUpdateWithoutAuthorDataInput `json:"data,omitempty"`␊
                }␊
            ␊
    ␊
          // NodeExec docs␊
          type NodeExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
    ␊
          // Node docs␊
          type Node interface {␊
            ID() string␊
          }␊
    ␊
          // UserPreviousValuesExec docs␊
          type UserPreviousValuesExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
          ␊
    ␊
          // Exec docs␊
          func (instance UserPreviousValuesExec) Exec() UserPreviousValues {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData UserPreviousValues␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // UserPreviousValues docs␊
          type UserPreviousValues struct {␊
              ID string `json:"id,omitempty"`␊
    Email string `json:"email,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    Name string `json:"name,omitempty"`␊
                }␊
            ␊
    ␊
          // PostConnectionExec docs␊
          type PostConnectionExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // PageInfo docs - executable for types␊
            func (instance *PostConnectionExec) PageInfo() *PageInfoExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "pageInfo",␊
                    Field: GraphQLField{␊
                      Name: "pageInfo",␊
                      TypeName: "PageInfo", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PageInfoExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Edges docs - executable for types␊
            func (instance *PostConnectionExec) Edges() *PostEdgeExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "edges",␊
                    Field: GraphQLField{␊
                      Name: "edges",␊
                      TypeName: "PostEdge", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"cursor"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PostEdgeExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Aggregate docs - executable for types␊
            func (instance *PostConnectionExec) Aggregate() *AggregatePostExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "aggregate",␊
                    Field: GraphQLField{␊
                      Name: "aggregate",␊
                      TypeName: "AggregatePost", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"count"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &AggregatePostExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostConnectionExec) Exec() PostConnection {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData PostConnection␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // PostConnection docs␊
          type PostConnection struct {␊
              PageInfo *PageInfo `json:"pageInfo,omitempty"`␊
    Edges *PostEdge `json:"edges,omitempty"`␊
    Aggregate *AggregatePost `json:"aggregate,omitempty"`␊
                }␊
            ␊
    ␊
          // PostExec docs␊
          type PostExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // Author docs - executable for types␊
            func (instance *PostExec) Author(where UserWhereInput) *UserExec {␊
                  var args []GraphQLArg␊
                  args = append(args, GraphQLArg{␊
                    Name: "where",␊
                    TypeName: "UserWhereInput",␊
                    Value: where,␊
                  })␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "author",␊
                    Field: GraphQLField{␊
                      Name: "author",␊
                      TypeName: "User", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &UserExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostExec) Exec() Post {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData Post␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // Post docs␊
          type Post struct {␊
              ID string `json:"id,omitempty"`␊
    CreatedAt string `json:"createdAt,omitempty"`␊
    UpdatedAt string `json:"updatedAt,omitempty"`␊
    IsPublished bool `json:"isPublished,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    Text string `json:"text,omitempty"`␊
    Author *User `json:"author,omitempty"`␊
                }␊
            ␊
    ␊
          // PageInfoExec docs␊
          type PageInfoExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
          ␊
    ␊
          // Exec docs␊
          func (instance PageInfoExec) Exec() PageInfo {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData PageInfo␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // PageInfo docs␊
          type PageInfo struct {␊
              HasNextPage bool `json:"hasNextPage,omitempty"`␊
    HasPreviousPage bool `json:"hasPreviousPage,omitempty"`␊
    StartCursor string `json:"startCursor,omitempty"`␊
    EndCursor string `json:"endCursor,omitempty"`␊
                }␊
            ␊
    ␊
          // PostSubscriptionPayloadExec docs␊
          type PostSubscriptionPayloadExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // Node docs - executable for types␊
            func (instance *PostSubscriptionPayloadExec) Node() *PostExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "Post", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PostExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
     // PreviousValues docs - executable for types␊
            func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "previousValues",␊
                    Field: GraphQLField{␊
                      Name: "previousValues",␊
                      TypeName: "PostPreviousValues", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PostPreviousValuesExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostSubscriptionPayloadExec) Exec() PostSubscriptionPayload {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData PostSubscriptionPayload␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // PostSubscriptionPayload docs␊
          type PostSubscriptionPayload struct {␊
              Mutation *MutationType `json:"mutation,omitempty"`␊
    Node *Post `json:"node,omitempty"`␊
    UpdatedFields string `json:"updatedFields,omitempty"`␊
    PreviousValues *PostPreviousValues `json:"previousValues,omitempty"`␊
                }␊
            ␊
    ␊
          // BatchPayloadExec docs␊
          type BatchPayloadExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
          ␊
    ␊
          // Exec docs␊
          func (instance BatchPayloadExec) Exec() BatchPayload {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData BatchPayload␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // BatchPayload docs␊
          type BatchPayload struct {␊
              Count int64 `json:"count,omitempty"`␊
                }␊
            ␊
    ␊
          // PostPreviousValuesExec docs␊
          type PostPreviousValuesExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
          ␊
    ␊
          // Exec docs␊
          func (instance PostPreviousValuesExec) Exec() PostPreviousValues {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData PostPreviousValues␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // PostPreviousValues docs␊
          type PostPreviousValues struct {␊
              ID string `json:"id,omitempty"`␊
    CreatedAt string `json:"createdAt,omitempty"`␊
    UpdatedAt string `json:"updatedAt,omitempty"`␊
    IsPublished bool `json:"isPublished,omitempty"`␊
    Title string `json:"title,omitempty"`␊
    Text string `json:"text,omitempty"`␊
                }␊
            ␊
    ␊
          // UserExec docs␊
          type UserExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // Posts docs - executable for types␊
            func (instance *UserExec) Posts(where PostWhereInput,orderBy PostOrderByInput,skip Int,after String,before String,first Int,last Int) *PostExec {␊
                  var args []GraphQLArg␊
                  args = append(args, GraphQLArg{␊
                    Name: "where",␊
                    TypeName: "PostWhereInput",␊
                    Value: where,␊
                  })␊
    args = append(args, GraphQLArg{␊
                    Name: "orderBy",␊
                    TypeName: "PostOrderByInput",␊
                    Value: orderBy,␊
                  })␊
    args = append(args, GraphQLArg{␊
                    Name: "skip",␊
                    TypeName: "Int",␊
                    Value: skip,␊
                  })␊
    args = append(args, GraphQLArg{␊
                    Name: "after",␊
                    TypeName: "String",␊
                    Value: after,␊
                  })␊
    args = append(args, GraphQLArg{␊
                    Name: "before",␊
                    TypeName: "String",␊
                    Value: before,␊
                  })␊
    args = append(args, GraphQLArg{␊
                    Name: "first",␊
                    TypeName: "Int",␊
                    Value: first,␊
                  })␊
    args = append(args, GraphQLArg{␊
                    Name: "last",␊
                    TypeName: "Int",␊
                    Value: last,␊
                  })␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "posts",␊
                    Field: GraphQLField{␊
                      Name: "posts",␊
                      TypeName: "Post", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PostExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserExec) Exec() User {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData User␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // User docs␊
          type User struct {␊
              ID string `json:"id,omitempty"`␊
    Email string `json:"email,omitempty"`␊
    Password string `json:"password,omitempty"`␊
    Name string `json:"name,omitempty"`␊
    Posts *Post `json:"posts,omitempty"`␊
                }␊
            ␊
    ␊
          // AggregateUserExec docs␊
          type AggregateUserExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
          ␊
    ␊
          // Exec docs␊
          func (instance AggregateUserExec) Exec() AggregateUser {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData AggregateUser␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // AggregateUser docs␊
          type AggregateUser struct {␊
              Count int32 `json:"count,omitempty"`␊
                }␊
            ␊
    ␊
          // UserSubscriptionPayloadExec docs␊
          type UserSubscriptionPayloadExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // Node docs - executable for types␊
            func (instance *UserSubscriptionPayloadExec) Node() *UserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "User", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &UserExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
     // PreviousValues docs - executable for types␊
            func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "previousValues",␊
                    Field: GraphQLField{␊
                      Name: "previousValues",␊
                      TypeName: "UserPreviousValues", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &UserPreviousValuesExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserSubscriptionPayloadExec) Exec() UserSubscriptionPayload {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData UserSubscriptionPayload␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // UserSubscriptionPayload docs␊
          type UserSubscriptionPayload struct {␊
              Mutation *MutationType `json:"mutation,omitempty"`␊
    Node *User `json:"node,omitempty"`␊
    UpdatedFields string `json:"updatedFields,omitempty"`␊
    PreviousValues *UserPreviousValues `json:"previousValues,omitempty"`␊
                }␊
            ␊
    ␊
          // UserEdgeExec docs␊
          type UserEdgeExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // Node docs - executable for types␊
            func (instance *UserEdgeExec) Node() *UserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "User", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","email","password","name"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &UserExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserEdgeExec) Exec() UserEdge {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData UserEdge␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // UserEdge docs␊
          type UserEdge struct {␊
              Node *User `json:"node,omitempty"`␊
    Cursor string `json:"cursor,omitempty"`␊
                }␊
            ␊
    ␊
          // PostEdgeExec docs␊
          type PostEdgeExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // Node docs - executable for types␊
            func (instance *PostEdgeExec) Node() *PostExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "node",␊
                    Field: GraphQLField{␊
                      Name: "node",␊
                      TypeName: "Post", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"id","createdAt","updatedAt","isPublished","title","text"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PostExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostEdgeExec) Exec() PostEdge {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData PostEdge␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // PostEdge docs␊
          type PostEdge struct {␊
              Node *Post `json:"node,omitempty"`␊
    Cursor string `json:"cursor,omitempty"`␊
                }␊
            ␊
    ␊
          // AggregatePostExec docs␊
          type AggregatePostExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
          ␊
    ␊
          // Exec docs␊
          func (instance AggregatePostExec) Exec() AggregatePost {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData AggregatePost␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // AggregatePost docs␊
          type AggregatePost struct {␊
              Count int32 `json:"count,omitempty"`␊
                }␊
            ␊
    ␊
          // UserConnectionExec docs␊
          type UserConnectionExec struct {␊
            db    DB␊
            stack []Instruction␊
          }␊
           // PageInfo docs - executable for types␊
            func (instance *UserConnectionExec) PageInfo() *PageInfoExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "pageInfo",␊
                    Field: GraphQLField{␊
                      Name: "pageInfo",␊
                      TypeName: "PageInfo", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &PageInfoExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Edges docs - executable for types␊
            func (instance *UserConnectionExec) Edges() *UserEdgeExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "edges",␊
                    Field: GraphQLField{␊
                      Name: "edges",␊
                      TypeName: "UserEdge", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"cursor"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &UserEdgeExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Aggregate docs - executable for types␊
            func (instance *UserConnectionExec) Aggregate() *AggregateUserExec {␊
                  var args []GraphQLArg␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    Name: "aggregate",␊
                    Field: GraphQLField{␊
                      Name: "aggregate",␊
                      TypeName: "AggregateUser", // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields  // TODO: We might need to full field object later to get array and non-null properties or add them as additional fields␊
                      TypeFields: []string{"count"},␊
                    },␊
                    Operation: "", // TODO: This is not a top level query, no operation␊
                    Args: args,␊
                  })␊
                return &AggregateUserExec{␊
                  db: instance.db,␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserConnectionExec) Exec() UserConnection {␊
            query := instance.db.ProcessInstructions(instance.stack)␊
            variables := make(map[string]interface{})␊
            for _, instruction := range instance.stack {␊
              if instance.db.Debug {␊
                fmt.Println("Instruction Exec: ", instruction)␊
              }␊
              for _, arg := range instruction.Args {␊
                if instance.db.Debug {␊
                  fmt.Println("Instruction Arg Exec: ", instruction)␊
                }␊
                // TODO: Need to handle arg.Name collisions␊
                variables[arg.Name] = arg.Value␊
              }␊
            }␊
            if instance.db.Debug {␊
              fmt.Println("Query Exec:", query)␊
              fmt.Println("Variables Exec:", variables)␊
            }␊
            data := instance.db.GraphQL(query, variables)␊
            for _, instruction := range instance.stack {␊
              data = (data[instruction.Name]).(map[string]interface{})␊
            }␊
            var decodedData UserConnection␊
            mapstructure.Decode(data, &decodedData)␊
            if instance.db.Debug {␊
              fmt.Println("Data Exec:", data)␊
              fmt.Println("Data Exec Decoded:", decodedData)␊
            }␊
            return decodedData␊
          }␊
          ␊
          // UserConnection docs␊
          type UserConnection struct {␊
              PageInfo *PageInfo `json:"pageInfo,omitempty"`␊
    Edges *UserEdge `json:"edges,omitempty"`␊
    Aggregate *AggregateUser `json:"aggregate,omitempty"`␊
                }␊
            ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
          // GraphQL Send a GraphQL operation request␊
    // TODO: arg variables can be made optional via variadic func approach␊
    func (db DB) GraphQL(query string, variables map[string]interface{}) map[string]interface{} {␊
    	// TODO: Error handling (both network, GraphQL and application level (missing node etc))␊
    	// TODO: Add auth support␊
    ␊
    	req := graphql.NewRequest(query)␊
    	client := graphql.NewClient(db.Endpoint)␊
    ␊
    	for key, value := range variables {␊
        req.Var(key, value)␊
    	}␊
    ␊
    	ctx := context.Background()␊
    ␊
    	// var respData ResponseStruct␊
    	var respData map[string]interface{} // TODO: Type this properly with a struct␊
    	if err := client.Run(ctx, req, &respData); err != nil {␊
        if db.Debug {␊
          fmt.Println("GraphQL Response:", respData)␊
        }␊
    		log.Fatal(err)␊
    	}␊
    	return respData␊
    }␊
            `
