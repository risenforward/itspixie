# Snapshot report for `dist/codegen/GoGenerator.test.js`

The actual snapshot is saved in `GoGenerator.test.js.snap`.

Generated by [AVA](https://ava.li).

## go generator

> Snapshot 1

    `␊
    package prisma␊
    ␊
    import (␊
    	"context"␊
      "log"␊
      "reflect"␊
      "fmt"␊
    ␊
    	"github.com/machinebox/graphql"␊
    )␊
    ␊
    // Instruction docs␊
    type Instruction struct {␊
    	name string␊
    	args []interface{}␊
    }␊
    ␊
    // DB Type to represent the client␊
    type DB struct {␊
    	Endpoint string // TODO: Remove the Endpoint from here and print it where needed.␊
    }␊
    ␊
    // Queries␊
    ␊
              // PostsParams docs␊
              type PostsParams struct {␊
                Where PostWhereInput `json:"where"`␊
    OrderBy PostOrderByInput `json:"orderBy"`␊
    Skip int32 `json:"skip"`␊
    After string `json:"after"`␊
    Before string `json:"before"`␊
    First int32 `json:"first"`␊
    Last int32 `json:"last"`␊
              }␊
              ␊
              // Posts docs␊
              func (db DB) Posts (params PostsParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
    args = append(args, params.OrderBy)␊
    args = append(args, params.Skip)␊
    args = append(args, params.After)␊
    args = append(args, params.Before)␊
    args = append(args, params.First)␊
    args = append(args, params.Last)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "Posts",␊
                args: args,␊
              })␊
    ␊
          return &PostExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UsersParams docs␊
              type UsersParams struct {␊
                Where UserWhereInput `json:"where"`␊
    OrderBy UserOrderByInput `json:"orderBy"`␊
    Skip int32 `json:"skip"`␊
    After string `json:"after"`␊
    Before string `json:"before"`␊
    First int32 `json:"first"`␊
    Last int32 `json:"last"`␊
              }␊
              ␊
              // Users docs␊
              func (db DB) Users (params UsersParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
    args = append(args, params.OrderBy)␊
    args = append(args, params.Skip)␊
    args = append(args, params.After)␊
    args = append(args, params.Before)␊
    args = append(args, params.First)␊
    args = append(args, params.Last)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "Users",␊
                args: args,␊
              })␊
    ␊
          return &UserExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // PostParams docs␊
              type PostParams struct {␊
                Where PostWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // Post docs␊
              func (db DB) Post (params PostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "Post",␊
                args: args,␊
              })␊
    ␊
          return &PostExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UserParams docs␊
              type UserParams struct {␊
                Where UserWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // User docs␊
              func (db DB) User (params UserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "User",␊
                args: args,␊
              })␊
    ␊
          return &UserExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // PostsConnectionParams docs␊
              type PostsConnectionParams struct {␊
                Where PostWhereInput `json:"where"`␊
    OrderBy PostOrderByInput `json:"orderBy"`␊
    Skip int32 `json:"skip"`␊
    After string `json:"after"`␊
    Before string `json:"before"`␊
    First int32 `json:"first"`␊
    Last int32 `json:"last"`␊
              }␊
              ␊
              // PostsConnection docs␊
              func (db DB) PostsConnection (params PostsConnectionParams) *PostConnectionExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
    args = append(args, params.OrderBy)␊
    args = append(args, params.Skip)␊
    args = append(args, params.After)␊
    args = append(args, params.Before)␊
    args = append(args, params.First)␊
    args = append(args, params.Last)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "PostsConnection",␊
                args: args,␊
              })␊
    ␊
          return &PostConnectionExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UsersConnectionParams docs␊
              type UsersConnectionParams struct {␊
                Where UserWhereInput `json:"where"`␊
    OrderBy UserOrderByInput `json:"orderBy"`␊
    Skip int32 `json:"skip"`␊
    After string `json:"after"`␊
    Before string `json:"before"`␊
    First int32 `json:"first"`␊
    Last int32 `json:"last"`␊
              }␊
              ␊
              // UsersConnection docs␊
              func (db DB) UsersConnection (params UsersConnectionParams) *UserConnectionExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
    args = append(args, params.OrderBy)␊
    args = append(args, params.Skip)␊
    args = append(args, params.After)␊
    args = append(args, params.Before)␊
    args = append(args, params.First)␊
    args = append(args, params.Last)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UsersConnection",␊
                args: args,␊
              })␊
    ␊
          return &UserConnectionExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // NodeParams docs␊
              type NodeParams struct {␊
                ID string `json:"id"`␊
              }␊
              ␊
              // Node docs␊
              func (db DB) Node (params NodeParams) *NodeExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.ID)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "Node",␊
                args: args,␊
              })␊
    ␊
          return &NodeExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
    // Mutations␊
    ␊
              // CreatePostParams docs␊
              type CreatePostParams struct {␊
                Data PostCreateInput `json:"data"`␊
              }␊
              ␊
              // CreatePost docs␊
              func (db DB) CreatePost (params CreatePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Data)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "CreatePost",␊
                args: args,␊
              })␊
    ␊
          return &PostExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // CreateUserParams docs␊
              type CreateUserParams struct {␊
                Data UserCreateInput `json:"data"`␊
              }␊
              ␊
              // CreateUser docs␊
              func (db DB) CreateUser (params CreateUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Data)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "CreateUser",␊
                args: args,␊
              })␊
    ␊
          return &UserExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdatePostParams docs␊
              type UpdatePostParams struct {␊
                Data PostUpdateInput `json:"data"`␊
    Where PostWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // UpdatePost docs␊
              func (db DB) UpdatePost (params UpdatePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Data)␊
    args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UpdatePost",␊
                args: args,␊
              })␊
    ␊
          return &PostExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdateUserParams docs␊
              type UpdateUserParams struct {␊
                Data UserUpdateInput `json:"data"`␊
    Where UserWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // UpdateUser docs␊
              func (db DB) UpdateUser (params UpdateUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Data)␊
    args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UpdateUser",␊
                args: args,␊
              })␊
    ␊
          return &UserExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeletePostParams docs␊
              type DeletePostParams struct {␊
                Where PostWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // DeletePost docs␊
              func (db DB) DeletePost (params DeletePostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "DeletePost",␊
                args: args,␊
              })␊
    ␊
          return &PostExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeleteUserParams docs␊
              type DeleteUserParams struct {␊
                Where UserWhereUniqueInput `json:"where"`␊
              }␊
              ␊
              // DeleteUser docs␊
              func (db DB) DeleteUser (params DeleteUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "DeleteUser",␊
                args: args,␊
              })␊
    ␊
          return &UserExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpsertPostParams docs␊
              type UpsertPostParams struct {␊
                Where PostWhereUniqueInput `json:"where"`␊
    Create PostCreateInput `json:"create"`␊
    Update PostUpdateInput `json:"update"`␊
              }␊
              ␊
              // UpsertPost docs␊
              func (db DB) UpsertPost (params UpsertPostParams) *PostExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
    args = append(args, params.Create)␊
    args = append(args, params.Update)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UpsertPost",␊
                args: args,␊
              })␊
    ␊
          return &PostExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpsertUserParams docs␊
              type UpsertUserParams struct {␊
                Where UserWhereUniqueInput `json:"where"`␊
    Create UserCreateInput `json:"create"`␊
    Update UserUpdateInput `json:"update"`␊
              }␊
              ␊
              // UpsertUser docs␊
              func (db DB) UpsertUser (params UpsertUserParams) *UserExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
    args = append(args, params.Create)␊
    args = append(args, params.Update)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UpsertUser",␊
                args: args,␊
              })␊
    ␊
          return &UserExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdateManyPostsParams docs␊
              type UpdateManyPostsParams struct {␊
                Data PostUpdateInput `json:"data"`␊
    Where PostWhereInput `json:"where"`␊
              }␊
              ␊
              // UpdateManyPosts docs␊
              func (db DB) UpdateManyPosts (params UpdateManyPostsParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Data)␊
    args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UpdateManyPosts",␊
                args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // UpdateManyUsersParams docs␊
              type UpdateManyUsersParams struct {␊
                Data UserUpdateInput `json:"data"`␊
    Where UserWhereInput `json:"where"`␊
              }␊
              ␊
              // UpdateManyUsers docs␊
              func (db DB) UpdateManyUsers (params UpdateManyUsersParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Data)␊
    args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "UpdateManyUsers",␊
                args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeleteManyPostsParams docs␊
              type DeleteManyPostsParams struct {␊
                Where PostWhereInput `json:"where"`␊
              }␊
              ␊
              // DeleteManyPosts docs␊
              func (db DB) DeleteManyPosts (params DeleteManyPostsParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "DeleteManyPosts",␊
                args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
              // DeleteManyUsersParams docs␊
              type DeleteManyUsersParams struct {␊
                Where UserWhereInput `json:"where"`␊
              }␊
              ␊
              // DeleteManyUsers docs␊
              func (db DB) DeleteManyUsers (params DeleteManyUsersParams) *BatchPayloadExec {␊
    ␊
              stack := make([]Instruction, 0)␊
              var args []interface{}␊
              args = append(args, params.Where)␊
              ␊
              stack = append(stack, Instruction{␊
                name: "DeleteManyUsers",␊
                args: args,␊
              })␊
    ␊
          return &BatchPayloadExec{␊
              stack: stack,␊
            }␊
            }␊
    ␊
    // Types␊
    ␊
    ␊
                // PostOrderByInput docs␊
                type PostOrderByInput string␊
                const (␊
                    ␊
                          // IDAscPostOrderByInput docs␊
                          IDAscPostOrderByInput PostOrderByInput = "id_ASC"␊
    ␊
                          // IDDescPostOrderByInput docs␊
                          IDDescPostOrderByInput PostOrderByInput = "id_DESC"␊
    ␊
                          // CreatedAtAscPostOrderByInput docs␊
                          CreatedAtAscPostOrderByInput PostOrderByInput = "createdAt_ASC"␊
    ␊
                          // CreatedAtDescPostOrderByInput docs␊
                          CreatedAtDescPostOrderByInput PostOrderByInput = "createdAt_DESC"␊
    ␊
                          // UpdatedAtAscPostOrderByInput docs␊
                          UpdatedAtAscPostOrderByInput PostOrderByInput = "updatedAt_ASC"␊
    ␊
                          // UpdatedAtDescPostOrderByInput docs␊
                          UpdatedAtDescPostOrderByInput PostOrderByInput = "updatedAt_DESC"␊
    ␊
                          // IsPublishedAscPostOrderByInput docs␊
                          IsPublishedAscPostOrderByInput PostOrderByInput = "isPublished_ASC"␊
    ␊
                          // IsPublishedDescPostOrderByInput docs␊
                          IsPublishedDescPostOrderByInput PostOrderByInput = "isPublished_DESC"␊
    ␊
                          // TitleAscPostOrderByInput docs␊
                          TitleAscPostOrderByInput PostOrderByInput = "title_ASC"␊
    ␊
                          // TitleDescPostOrderByInput docs␊
                          TitleDescPostOrderByInput PostOrderByInput = "title_DESC"␊
    ␊
                          // TextAscPostOrderByInput docs␊
                          TextAscPostOrderByInput PostOrderByInput = "text_ASC"␊
    ␊
                          // TextDescPostOrderByInput docs␊
                          TextDescPostOrderByInput PostOrderByInput = "text_DESC"␊
                )␊
            ␊
    ␊
                // UserOrderByInput docs␊
                type UserOrderByInput string␊
                const (␊
                    ␊
                          // IDAscUserOrderByInput docs␊
                          IDAscUserOrderByInput UserOrderByInput = "id_ASC"␊
    ␊
                          // IDDescUserOrderByInput docs␊
                          IDDescUserOrderByInput UserOrderByInput = "id_DESC"␊
    ␊
                          // EmailAscUserOrderByInput docs␊
                          EmailAscUserOrderByInput UserOrderByInput = "email_ASC"␊
    ␊
                          // EmailDescUserOrderByInput docs␊
                          EmailDescUserOrderByInput UserOrderByInput = "email_DESC"␊
    ␊
                          // PasswordAscUserOrderByInput docs␊
                          PasswordAscUserOrderByInput UserOrderByInput = "password_ASC"␊
    ␊
                          // PasswordDescUserOrderByInput docs␊
                          PasswordDescUserOrderByInput UserOrderByInput = "password_DESC"␊
    ␊
                          // NameAscUserOrderByInput docs␊
                          NameAscUserOrderByInput UserOrderByInput = "name_ASC"␊
    ␊
                          // NameDescUserOrderByInput docs␊
                          NameDescUserOrderByInput UserOrderByInput = "name_DESC"␊
    ␊
                          // UpdatedAtAscUserOrderByInput docs␊
                          UpdatedAtAscUserOrderByInput UserOrderByInput = "updatedAt_ASC"␊
    ␊
                          // UpdatedAtDescUserOrderByInput docs␊
                          UpdatedAtDescUserOrderByInput UserOrderByInput = "updatedAt_DESC"␊
    ␊
                          // CreatedAtAscUserOrderByInput docs␊
                          CreatedAtAscUserOrderByInput UserOrderByInput = "createdAt_ASC"␊
    ␊
                          // CreatedAtDescUserOrderByInput docs␊
                          CreatedAtDescUserOrderByInput UserOrderByInput = "createdAt_DESC"␊
                )␊
            ␊
    ␊
                // MutationType docs␊
                type MutationType string␊
                const (␊
                    ␊
                          // CreatedMutationType docs␊
                          CreatedMutationType MutationType = "CREATED"␊
    ␊
                          // UpdatedMutationType docs␊
                          UpdatedMutationType MutationType = "UPDATED"␊
    ␊
                          // DeletedMutationType docs␊
                          DeletedMutationType MutationType = "DELETED"␊
                )␊
            ␊
    // UserCreateOneWithoutPostsInput docs␊
          type UserCreateOneWithoutPostsInput struct {␊
              Create UserCreateWithoutPostsInput `json:"create"`␊
    Connect UserWhereUniqueInput `json:"connect"`␊
                }␊
            ␊
    // PostWhereInput docs␊
          type PostWhereInput struct {␊
              And *PostWhereInput `json:"AND"`␊
    Or *PostWhereInput `json:"OR"`␊
    ID string `json:"id"`␊
    IDNot string `json:"id_not"`␊
    IDIn string `json:"id_in"`␊
    IDNotIn string `json:"id_not_in"`␊
    IDLt string `json:"id_lt"`␊
    IDLte string `json:"id_lte"`␊
    IDGt string `json:"id_gt"`␊
    IDGte string `json:"id_gte"`␊
    IDContains string `json:"id_contains"`␊
    IDNotContains string `json:"id_not_contains"`␊
    IDStartsWith string `json:"id_starts_with"`␊
    IDNotStartsWith string `json:"id_not_starts_with"`␊
    IDEndsWith string `json:"id_ends_with"`␊
    IDNotEndsWith string `json:"id_not_ends_with"`␊
    CreatedAt string `json:"createdAt"`␊
    CreatedAtNot string `json:"createdAt_not"`␊
    CreatedAtIn string `json:"createdAt_in"`␊
    CreatedAtNotIn string `json:"createdAt_not_in"`␊
    CreatedAtLt string `json:"createdAt_lt"`␊
    CreatedAtLte string `json:"createdAt_lte"`␊
    CreatedAtGt string `json:"createdAt_gt"`␊
    CreatedAtGte string `json:"createdAt_gte"`␊
    UpdatedAt string `json:"updatedAt"`␊
    UpdatedAtNot string `json:"updatedAt_not"`␊
    UpdatedAtIn string `json:"updatedAt_in"`␊
    UpdatedAtNotIn string `json:"updatedAt_not_in"`␊
    UpdatedAtLt string `json:"updatedAt_lt"`␊
    UpdatedAtLte string `json:"updatedAt_lte"`␊
    UpdatedAtGt string `json:"updatedAt_gt"`␊
    UpdatedAtGte string `json:"updatedAt_gte"`␊
    IsPublished bool `json:"isPublished"`␊
    IsPublishedNot bool `json:"isPublished_not"`␊
    Title string `json:"title"`␊
    TitleNot string `json:"title_not"`␊
    TitleIn string `json:"title_in"`␊
    TitleNotIn string `json:"title_not_in"`␊
    TitleLt string `json:"title_lt"`␊
    TitleLte string `json:"title_lte"`␊
    TitleGt string `json:"title_gt"`␊
    TitleGte string `json:"title_gte"`␊
    TitleContains string `json:"title_contains"`␊
    TitleNotContains string `json:"title_not_contains"`␊
    TitleStartsWith string `json:"title_starts_with"`␊
    TitleNotStartsWith string `json:"title_not_starts_with"`␊
    TitleEndsWith string `json:"title_ends_with"`␊
    TitleNotEndsWith string `json:"title_not_ends_with"`␊
    Text string `json:"text"`␊
    TextNot string `json:"text_not"`␊
    TextIn string `json:"text_in"`␊
    TextNotIn string `json:"text_not_in"`␊
    TextLt string `json:"text_lt"`␊
    TextLte string `json:"text_lte"`␊
    TextGt string `json:"text_gt"`␊
    TextGte string `json:"text_gte"`␊
    TextContains string `json:"text_contains"`␊
    TextNotContains string `json:"text_not_contains"`␊
    TextStartsWith string `json:"text_starts_with"`␊
    TextNotStartsWith string `json:"text_not_starts_with"`␊
    TextEndsWith string `json:"text_ends_with"`␊
    TextNotEndsWith string `json:"text_not_ends_with"`␊
    Author UserWhereInput `json:"author"`␊
                }␊
            ␊
    // PostCreateManyWithoutAuthorInput docs␊
          type PostCreateManyWithoutAuthorInput struct {␊
              Create PostCreateWithoutAuthorInput `json:"create"`␊
    Connect PostWhereUniqueInput `json:"connect"`␊
                }␊
            ␊
    // UserWhereInput docs␊
          type UserWhereInput struct {␊
              And *UserWhereInput `json:"AND"`␊
    Or *UserWhereInput `json:"OR"`␊
    ID string `json:"id"`␊
    IDNot string `json:"id_not"`␊
    IDIn string `json:"id_in"`␊
    IDNotIn string `json:"id_not_in"`␊
    IDLt string `json:"id_lt"`␊
    IDLte string `json:"id_lte"`␊
    IDGt string `json:"id_gt"`␊
    IDGte string `json:"id_gte"`␊
    IDContains string `json:"id_contains"`␊
    IDNotContains string `json:"id_not_contains"`␊
    IDStartsWith string `json:"id_starts_with"`␊
    IDNotStartsWith string `json:"id_not_starts_with"`␊
    IDEndsWith string `json:"id_ends_with"`␊
    IDNotEndsWith string `json:"id_not_ends_with"`␊
    Email string `json:"email"`␊
    EmailNot string `json:"email_not"`␊
    EmailIn string `json:"email_in"`␊
    EmailNotIn string `json:"email_not_in"`␊
    EmailLt string `json:"email_lt"`␊
    EmailLte string `json:"email_lte"`␊
    EmailGt string `json:"email_gt"`␊
    EmailGte string `json:"email_gte"`␊
    EmailContains string `json:"email_contains"`␊
    EmailNotContains string `json:"email_not_contains"`␊
    EmailStartsWith string `json:"email_starts_with"`␊
    EmailNotStartsWith string `json:"email_not_starts_with"`␊
    EmailEndsWith string `json:"email_ends_with"`␊
    EmailNotEndsWith string `json:"email_not_ends_with"`␊
    Password string `json:"password"`␊
    PasswordNot string `json:"password_not"`␊
    PasswordIn string `json:"password_in"`␊
    PasswordNotIn string `json:"password_not_in"`␊
    PasswordLt string `json:"password_lt"`␊
    PasswordLte string `json:"password_lte"`␊
    PasswordGt string `json:"password_gt"`␊
    PasswordGte string `json:"password_gte"`␊
    PasswordContains string `json:"password_contains"`␊
    PasswordNotContains string `json:"password_not_contains"`␊
    PasswordStartsWith string `json:"password_starts_with"`␊
    PasswordNotStartsWith string `json:"password_not_starts_with"`␊
    PasswordEndsWith string `json:"password_ends_with"`␊
    PasswordNotEndsWith string `json:"password_not_ends_with"`␊
    Name string `json:"name"`␊
    NameNot string `json:"name_not"`␊
    NameIn string `json:"name_in"`␊
    NameNotIn string `json:"name_not_in"`␊
    NameLt string `json:"name_lt"`␊
    NameLte string `json:"name_lte"`␊
    NameGt string `json:"name_gt"`␊
    NameGte string `json:"name_gte"`␊
    NameContains string `json:"name_contains"`␊
    NameNotContains string `json:"name_not_contains"`␊
    NameStartsWith string `json:"name_starts_with"`␊
    NameNotStartsWith string `json:"name_not_starts_with"`␊
    NameEndsWith string `json:"name_ends_with"`␊
    NameNotEndsWith string `json:"name_not_ends_with"`␊
    PostsEvery PostWhereInput `json:"posts_every"`␊
    PostsSome PostWhereInput `json:"posts_some"`␊
    PostsNone PostWhereInput `json:"posts_none"`␊
                }␊
            ␊
    // PostUpdateManyWithoutAuthorInput docs␊
          type PostUpdateManyWithoutAuthorInput struct {␊
              Create PostCreateWithoutAuthorInput `json:"create"`␊
    Connect PostWhereUniqueInput `json:"connect"`␊
    Disconnect PostWhereUniqueInput `json:"disconnect"`␊
    Delete PostWhereUniqueInput `json:"delete"`␊
    Update PostUpdateWithWhereUniqueWithoutAuthorInput `json:"update"`␊
    Upsert PostUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert"`␊
                }␊
            ␊
    // PostUpdateInput docs␊
          type PostUpdateInput struct {␊
              IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
    Author UserUpdateOneWithoutPostsInput `json:"author"`␊
                }␊
            ␊
    // UserUpdateInput docs␊
          type UserUpdateInput struct {␊
              Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
    Posts PostUpdateManyWithoutAuthorInput `json:"posts"`␊
                }␊
            ␊
    // PostCreateWithoutAuthorInput docs␊
          type PostCreateWithoutAuthorInput struct {␊
              IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
                }␊
            ␊
    // UserUpsertWithoutPostsInput docs␊
          type UserUpsertWithoutPostsInput struct {␊
              Update UserUpdateWithoutPostsDataInput `json:"update"`␊
    Create UserCreateWithoutPostsInput `json:"create"`␊
                }␊
            ␊
    // UserSubscriptionWhereInput docs␊
          type UserSubscriptionWhereInput struct {␊
              And *UserSubscriptionWhereInput `json:"AND"`␊
    Or *UserSubscriptionWhereInput `json:"OR"`␊
    MutationIn MutationType `json:"mutation_in"`␊
    UpdatedFieldsContains string `json:"updatedFields_contains"`␊
    UpdatedFieldsContainsEvery string `json:"updatedFields_contains_every"`␊
    UpdatedFieldsContainsSome string `json:"updatedFields_contains_some"`␊
    Node UserWhereInput `json:"node"`␊
                }␊
            ␊
    // UserUpdateWithoutPostsDataInput docs␊
          type UserUpdateWithoutPostsDataInput struct {␊
              Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
                }␊
            ␊
    // PostWhereUniqueInput docs␊
          type PostWhereUniqueInput struct {␊
              ID string `json:"id"`␊
                }␊
            ␊
    // PostUpsertWithWhereUniqueWithoutAuthorInput docs␊
          type PostUpsertWithWhereUniqueWithoutAuthorInput struct {␊
              Where PostWhereUniqueInput `json:"where"`␊
    Update PostUpdateWithoutAuthorDataInput `json:"update"`␊
    Create PostCreateWithoutAuthorInput `json:"create"`␊
                }␊
            ␊
    // UserCreateInput docs␊
          type UserCreateInput struct {␊
              Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
    Posts PostCreateManyWithoutAuthorInput `json:"posts"`␊
                }␊
            ␊
    // UserCreateWithoutPostsInput docs␊
          type UserCreateWithoutPostsInput struct {␊
              Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
                }␊
            ␊
    // UserUpdateOneWithoutPostsInput docs␊
          type UserUpdateOneWithoutPostsInput struct {␊
              Create UserCreateWithoutPostsInput `json:"create"`␊
    Connect UserWhereUniqueInput `json:"connect"`␊
    Delete bool `json:"delete"`␊
    Update UserUpdateWithoutPostsDataInput `json:"update"`␊
    Upsert UserUpsertWithoutPostsInput `json:"upsert"`␊
                }␊
            ␊
    // PostCreateInput docs␊
          type PostCreateInput struct {␊
              IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
    Author UserCreateOneWithoutPostsInput `json:"author"`␊
                }␊
            ␊
    // PostUpdateWithoutAuthorDataInput docs␊
          type PostUpdateWithoutAuthorDataInput struct {␊
              IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
                }␊
            ␊
    // UserWhereUniqueInput docs␊
          type UserWhereUniqueInput struct {␊
              ID string `json:"id"`␊
    Email string `json:"email"`␊
                }␊
            ␊
    // PostSubscriptionWhereInput docs␊
          type PostSubscriptionWhereInput struct {␊
              And *PostSubscriptionWhereInput `json:"AND"`␊
    Or *PostSubscriptionWhereInput `json:"OR"`␊
    MutationIn MutationType `json:"mutation_in"`␊
    UpdatedFieldsContains string `json:"updatedFields_contains"`␊
    UpdatedFieldsContainsEvery string `json:"updatedFields_contains_every"`␊
    UpdatedFieldsContainsSome string `json:"updatedFields_contains_some"`␊
    Node PostWhereInput `json:"node"`␊
                }␊
            ␊
    // PostUpdateWithWhereUniqueWithoutAuthorInput docs␊
          type PostUpdateWithWhereUniqueWithoutAuthorInput struct {␊
              Where PostWhereUniqueInput `json:"where"`␊
    Data PostUpdateWithoutAuthorDataInput `json:"data"`␊
                }␊
            ␊
    ␊
          // NodeExec docs␊
          type NodeExec struct {␊
            stack []Instruction␊
          }␊
    ␊
          // Node docs␊
          type Node interface {␊
            ID() string␊
          }␊
    ␊
          // UserPreviousValuesExec docs␊
          type UserPreviousValuesExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance UserPreviousValuesExec) Exec() UserPreviousValues {␊
            fmt.Println(instance.stack)␊
            return UserPreviousValues{}␊
          }␊
          ␊
          // UserPreviousValues docs␊
          type UserPreviousValues struct {␊
              ID string `json:"id"`␊
    Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
                }␊
            ␊
    ␊
          // PostConnectionExec docs␊
          type PostConnectionExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // PageInfo docs␊
            func (instance *PostConnectionExec) PageInfo() *PageInfoExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "PageInfo",␊
                    args: args,␊
                  })␊
                return &PageInfoExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Edges docs␊
            func (instance *PostConnectionExec) Edges() *PostEdgeExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Edges",␊
                    args: args,␊
                  })␊
                return &PostEdgeExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Aggregate docs␊
            func (instance *PostConnectionExec) Aggregate() *AggregatePostExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Aggregate",␊
                    args: args,␊
                  })␊
                return &AggregatePostExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostConnectionExec) Exec() PostConnection {␊
            fmt.Println(instance.stack)␊
            return PostConnection{}␊
          }␊
          ␊
          // PostConnection docs␊
          type PostConnection struct {␊
              PageInfo PageInfo `json:"pageInfo"`␊
    Edges PostEdge `json:"edges"`␊
    Aggregate AggregatePost `json:"aggregate"`␊
                }␊
            ␊
    ␊
          // PostExec docs␊
          type PostExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // Author docs␊
            func (instance *PostExec) Author(where UserWhereInput) *UserExec {␊
                  var args []interface{}␊
                  args = append(args, where)␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Author",␊
                    args: args,␊
                  })␊
                return &UserExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostExec) Exec() Post {␊
            fmt.Println(instance.stack)␊
            return Post{}␊
          }␊
          ␊
          // Post docs␊
          type Post struct {␊
              ID string `json:"id"`␊
    CreatedAt string `json:"createdAt"`␊
    UpdatedAt string `json:"updatedAt"`␊
    IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
    Author User `json:"author"`␊
                }␊
            ␊
    ␊
          // PageInfoExec docs␊
          type PageInfoExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance PageInfoExec) Exec() PageInfo {␊
            fmt.Println(instance.stack)␊
            return PageInfo{}␊
          }␊
          ␊
          // PageInfo docs␊
          type PageInfo struct {␊
              HasNextPage bool `json:"hasNextPage"`␊
    HasPreviousPage bool `json:"hasPreviousPage"`␊
    StartCursor string `json:"startCursor"`␊
    EndCursor string `json:"endCursor"`␊
                }␊
            ␊
    ␊
          // PostSubscriptionPayloadExec docs␊
          type PostSubscriptionPayloadExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // Node docs␊
            func (instance *PostSubscriptionPayloadExec) Node() *PostExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Node",␊
                    args: args,␊
                  })␊
                return &PostExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
     // PreviousValues docs␊
            func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "PreviousValues",␊
                    args: args,␊
                  })␊
                return &PostPreviousValuesExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostSubscriptionPayloadExec) Exec() PostSubscriptionPayload {␊
            fmt.Println(instance.stack)␊
            return PostSubscriptionPayload{}␊
          }␊
          ␊
          // PostSubscriptionPayload docs␊
          type PostSubscriptionPayload struct {␊
              Mutation MutationType `json:"mutation"`␊
    Node Post `json:"node"`␊
    UpdatedFields string `json:"updatedFields"`␊
    PreviousValues PostPreviousValues `json:"previousValues"`␊
                }␊
            ␊
    ␊
          // BatchPayloadExec docs␊
          type BatchPayloadExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance BatchPayloadExec) Exec() BatchPayload {␊
            fmt.Println(instance.stack)␊
            return BatchPayload{}␊
          }␊
          ␊
          // BatchPayload docs␊
          type BatchPayload struct {␊
              Count int64 `json:"count"`␊
                }␊
            ␊
    ␊
          // PostPreviousValuesExec docs␊
          type PostPreviousValuesExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance PostPreviousValuesExec) Exec() PostPreviousValues {␊
            fmt.Println(instance.stack)␊
            return PostPreviousValues{}␊
          }␊
          ␊
          // PostPreviousValues docs␊
          type PostPreviousValues struct {␊
              ID string `json:"id"`␊
    CreatedAt string `json:"createdAt"`␊
    UpdatedAt string `json:"updatedAt"`␊
    IsPublished bool `json:"isPublished"`␊
    Title string `json:"title"`␊
    Text string `json:"text"`␊
                }␊
            ␊
    ␊
          // UserExec docs␊
          type UserExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // Posts docs␊
            func (instance *UserExec) Posts(where PostWhereInput,orderBy PostOrderByInput,skip Int,after String,before String,first Int,last Int) *PostExec {␊
                  var args []interface{}␊
                  args = append(args, where),args = append(args, orderBy),args = append(args, skip),args = append(args, after),args = append(args, before),args = append(args, first),args = append(args, last)␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Posts",␊
                    args: args,␊
                  })␊
                return &PostExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserExec) Exec() User {␊
            fmt.Println(instance.stack)␊
            return User{}␊
          }␊
          ␊
          // User docs␊
          type User struct {␊
              ID string `json:"id"`␊
    Email string `json:"email"`␊
    Password string `json:"password"`␊
    Name string `json:"name"`␊
    Posts Post `json:"posts"`␊
                }␊
            ␊
    ␊
          // AggregateUserExec docs␊
          type AggregateUserExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance AggregateUserExec) Exec() AggregateUser {␊
            fmt.Println(instance.stack)␊
            return AggregateUser{}␊
          }␊
          ␊
          // AggregateUser docs␊
          type AggregateUser struct {␊
              Count int32 `json:"count"`␊
                }␊
            ␊
    ␊
          // UserSubscriptionPayloadExec docs␊
          type UserSubscriptionPayloadExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // Node docs␊
            func (instance *UserSubscriptionPayloadExec) Node() *UserExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Node",␊
                    args: args,␊
                  })␊
                return &UserExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
     // PreviousValues docs␊
            func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "PreviousValues",␊
                    args: args,␊
                  })␊
                return &UserPreviousValuesExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserSubscriptionPayloadExec) Exec() UserSubscriptionPayload {␊
            fmt.Println(instance.stack)␊
            return UserSubscriptionPayload{}␊
          }␊
          ␊
          // UserSubscriptionPayload docs␊
          type UserSubscriptionPayload struct {␊
              Mutation MutationType `json:"mutation"`␊
    Node User `json:"node"`␊
    UpdatedFields string `json:"updatedFields"`␊
    PreviousValues UserPreviousValues `json:"previousValues"`␊
                }␊
            ␊
    ␊
          // UserEdgeExec docs␊
          type UserEdgeExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // Node docs␊
            func (instance *UserEdgeExec) Node() *UserExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Node",␊
                    args: args,␊
                  })␊
                return &UserExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserEdgeExec) Exec() UserEdge {␊
            fmt.Println(instance.stack)␊
            return UserEdge{}␊
          }␊
          ␊
          // UserEdge docs␊
          type UserEdge struct {␊
              Node User `json:"node"`␊
    Cursor string `json:"cursor"`␊
                }␊
            ␊
    ␊
          // PostEdgeExec docs␊
          type PostEdgeExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // Node docs␊
            func (instance *PostEdgeExec) Node() *PostExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Node",␊
                    args: args,␊
                  })␊
                return &PostExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance PostEdgeExec) Exec() PostEdge {␊
            fmt.Println(instance.stack)␊
            return PostEdge{}␊
          }␊
          ␊
          // PostEdge docs␊
          type PostEdge struct {␊
              Node Post `json:"node"`␊
    Cursor string `json:"cursor"`␊
                }␊
            ␊
    ␊
          // AggregatePostExec docs␊
          type AggregatePostExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
          ␊
    ␊
          // Exec docs␊
          func (instance AggregatePostExec) Exec() AggregatePost {␊
            fmt.Println(instance.stack)␊
            return AggregatePost{}␊
          }␊
          ␊
          // AggregatePost docs␊
          type AggregatePost struct {␊
              Count int32 `json:"count"`␊
                }␊
            ␊
    ␊
          // UserConnectionExec docs␊
          type UserConnectionExec struct {␊
              stack []Instruction // TODO: This will be map[string]interface{} to support parallel stacks␊
          }␊
    ␊
           // PageInfo docs␊
            func (instance *UserConnectionExec) PageInfo() *PageInfoExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "PageInfo",␊
                    args: args,␊
                  })␊
                return &PageInfoExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Edges docs␊
            func (instance *UserConnectionExec) Edges() *UserEdgeExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Edges",␊
                    args: args,␊
                  })␊
                return &UserEdgeExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
     // Aggregate docs␊
            func (instance *UserConnectionExec) Aggregate() *AggregateUserExec {␊
                  var args []interface{}␊
                  ␊
                  instance.stack = append(instance.stack, Instruction{␊
                    name: "Aggregate",␊
                    args: args,␊
                  })␊
                return &AggregateUserExec{␊
                  stack: instance.stack,␊
                }␊
              }␊
    ␊
          // Exec docs␊
          func (instance UserConnectionExec) Exec() UserConnection {␊
            fmt.Println(instance.stack)␊
            return UserConnection{}␊
          }␊
          ␊
          // UserConnection docs␊
          type UserConnection struct {␊
              PageInfo PageInfo `json:"pageInfo"`␊
    Edges UserEdge `json:"edges"`␊
    Aggregate AggregateUser `json:"aggregate"`␊
                }␊
            ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
    ␊
          func isZeroOfUnderlyingType(x interface{}) bool {␊
            return reflect.DeepEqual(x, reflect.Zero(reflect.TypeOf(x)).Interface())␊
          }␊
    ␊
          // Request Send a GraphQL operation request␊
    // TODO: arg variables can be made optional via variadic func approach␊
    func (db DB) Request(query string, variables map[string]interface{}) map[string]interface{} {␊
    	// TODO: Error handling (both network, GraphQL and application level (missing node etc))␊
    	// TODO: Add auth support␊
    ␊
    	req := graphql.NewRequest(query)␊
    	client := graphql.NewClient(db.Endpoint)␊
    ␊
    	for key, value := range variables {␊
    		if !isZeroOfUnderlyingType(value) {␊
    			req.Var(key, value)␊
    		}␊
    	}␊
    ␊
    	ctx := context.Background()␊
    ␊
    	// var respData ResponseStruct␊
    	var respData map[string]interface{} // TODO: Type this properly with a struct␊
    	if err := client.Run(ctx, req, &respData); err != nil {␊
    		log.Fatal(err)␊
    	}␊
    	return respData␊
    }␊
            `
