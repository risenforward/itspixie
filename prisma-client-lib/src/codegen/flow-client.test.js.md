# Snapshot report for `dist/codegen/flow-client.test.js`

The actual snapshot is saved in `flow-client.test.js.snap`.

Generated by [AVA](https://ava.li).

## flow generator

> Snapshot 1

    `/**␊
     * @flow␊
     */␊
    import type { GraphQLResolveInfo, GraphQLSchema } from "graphql";␊
    import type { IResolvers } from "graphql-tools/dist/Interfaces";␊
    import type { BasePrismaOptions as BPOType, Options } from "prisma-client-lib";␊
    import { makePrismaClientClass } from "prisma-client-lib";␊
    import { typeDefs } from "./graphql";␊
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.␊
    ␊
    type AtLeastOne<T> = $Shape<T>;␊
    ␊
    export interface Exists {␊
      Post(where?: PostWhereInput): Promise<boolean>;␊
      User(where?: UserWhereInput): Promise<boolean>;␊
    }␊
    ␊
    export interface Node {}␊
    ␊
    interface PrismaInterface {␊
      $exists: Exists;␊
      $graphql: <T: any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
      $delegate: Delegate;␊
      $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      posts: <T: Promise<Array<PostNode>>>(␊
        args?: {␊
          where?: PostWhereInput,␊
          orderBy?: PostOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
      users: <T: Promise<Array<UserNode>>>(␊
        args?: {␊
          where?: UserWhereInput,␊
          orderBy?: UserOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
      post: <T: Post>(where: PostWhereUniqueInput, fragment?: string | Object) => T;␊
      user: <T: User>(where: UserWhereUniqueInput, fragment?: string | Object) => T;␊
      postsConnection: <T: PostConnection>(␊
        args?: {␊
          where?: PostWhereInput,␊
          orderBy?: PostOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
      usersConnection: <T: UserConnection>(␊
        args?: {␊
          where?: UserWhereInput,␊
          orderBy?: UserOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
      node: <T: Node>(args: { id: ID_Output }, fragment?: string | Object) => T;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      createPost: <T: Post>(data: PostCreateInput, fragment?: string | Object) => T;␊
      createUser: <T: User>(data: UserCreateInput, fragment?: string | Object) => T;␊
      updatePost: <T: Post>(␊
        args: { data: PostUpdateInput, where: PostWhereUniqueInput },␊
        fragment?: string | Object␊
      ) => T;␊
      updateUser: <T: User>(␊
        args: { data: UserUpdateInput, where: UserWhereUniqueInput },␊
        fragment?: string | Object␊
      ) => T;␊
      deletePost: <T: Post>(␊
        where: PostWhereUniqueInput,␊
        fragment?: string | Object␊
      ) => T;␊
      deleteUser: <T: User>(␊
        where: UserWhereUniqueInput,␊
        fragment?: string | Object␊
      ) => T;␊
      upsertPost: <T: Post>(␊
        args: {␊
          where: PostWhereUniqueInput,␊
          create: PostCreateInput,␊
          update: PostUpdateInput␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
      upsertUser: <T: User>(␊
        args: {␊
          where: UserWhereUniqueInput,␊
          create: UserCreateInput,␊
          update: UserUpdateInput␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
      updateManyPosts: <T: BatchPayload>(␊
        args: { data: PostUpdateInput, where: PostWhereInput },␊
        fragment?: string | Object␊
      ) => T;␊
      updateManyUsers: <T: BatchPayload>(␊
        args: { data: UserUpdateInput, where: UserWhereInput },␊
        fragment?: string | Object␊
      ) => T;␊
      deleteManyPosts: <T: BatchPayload>(␊
        where: PostWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
      deleteManyUsers: <T: BatchPayload>(␊
        where: UserWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {␊
      post: <T: PostSubscriptionPayloadSubscription>(␊
        where?: PostSubscriptionWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
      user: <T: UserSubscriptionPayloadSubscription>(␊
        where?: UserSubscriptionWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    export interface Delegate {␊
      (␊
        operation: "query" | "mutation",␊
        fieldName: string,␊
        args: {␊
          [key: string]: any␊
        },␊
        infoOrQuery?: GraphQLResolveInfo,␊
        options?: Options␊
      ): Promise<any>;␊
      query: DelegateQuery;␊
      mutation: DelegateMutation;␊
      subscription: DelegateSubscription;␊
    }␊
    ␊
    export interface DelegateQuery {␊
      posts: <T: Promise<Array<PostNode>>>(␊
        args?: {␊
          where?: PostWhereInput,␊
          orderBy?: PostOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      users: <T: Promise<Array<UserNode>>>(␊
        args?: {␊
          where?: UserWhereInput,␊
          orderBy?: UserOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      post: <T: Promise<$Shape<PostNode | null>>>(␊
        where: PostWhereUniqueInput,␊
        fragment?: string | Object␊
      ) => T;␊
      user: <T: Promise<$Shape<UserNode | null>>>(␊
        where: UserWhereUniqueInput,␊
        fragment?: string | Object␊
      ) => T;␊
      postsConnection: <T: Promise<$Shape<PostConnectionNode>>>(␊
        args?: {␊
          where?: PostWhereInput,␊
          orderBy?: PostOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      usersConnection: <T: Promise<$Shape<UserConnectionNode>>>(␊
        args?: {␊
          where?: UserWhereInput,␊
          orderBy?: UserOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      node: <T: Promise<$Shape<NodeNode | null>>>(␊
        args: { id: ID_Output },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
    }␊
    ␊
    export interface DelegateMutation {␊
      createPost: <T: Promise<$Shape<PostNode>>>(␊
        where: PostCreateInput,␊
        fragment?: string | Object␊
      ) => T;␊
      createUser: <T: Promise<$Shape<UserNode>>>(␊
        where: UserCreateInput,␊
        fragment?: string | Object␊
      ) => T;␊
      updatePost: <T: Promise<$Shape<PostNode | null>>>(␊
        args: { data: PostUpdateInput, where: PostWhereUniqueInput },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      updateUser: <T: Promise<$Shape<UserNode | null>>>(␊
        args: { data: UserUpdateInput, where: UserWhereUniqueInput },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      deletePost: <T: Promise<$Shape<PostNode | null>>>(␊
        where: PostWhereUniqueInput,␊
        fragment?: string | Object␊
      ) => T;␊
      deleteUser: <T: Promise<$Shape<UserNode | null>>>(␊
        where: UserWhereUniqueInput,␊
        fragment?: string | Object␊
      ) => T;␊
      upsertPost: <T: Promise<$Shape<PostNode>>>(␊
        args: {␊
          where: PostWhereUniqueInput,␊
          create: PostCreateInput,␊
          update: PostUpdateInput␊
        },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      upsertUser: <T: Promise<$Shape<UserNode>>>(␊
        args: {␊
          where: UserWhereUniqueInput,␊
          create: UserCreateInput,␊
          update: UserUpdateInput␊
        },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      updateManyPosts: <T: Promise<$Shape<BatchPayloadNode>>>(␊
        args: { data: PostUpdateInput, where: PostWhereInput },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      updateManyUsers: <T: Promise<$Shape<BatchPayloadNode>>>(␊
        args: { data: UserUpdateInput, where: UserWhereInput },␊
        info?: GraphQLResolveInfo,␊
        options?: Options␊
      ) => T;␊
      deleteManyPosts: <T: Promise<$Shape<BatchPayloadNode>>>(␊
        where: PostWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
      deleteManyUsers: <T: Promise<$Shape<BatchPayloadNode>>>(␊
        where: UserWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    export interface DelegateSubscription {␊
      post: <T: Promise<AsyncIterator<$Shape<PostSubscriptionPayloadNode | null>>>>(␊
        where?: PostSubscriptionWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
      user: <T: Promise<AsyncIterator<$Shape<UserSubscriptionPayloadNode | null>>>>(␊
        where?: UserSubscriptionWhereInput,␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    export interface ClientConstructor<T> {␊
      new(options?: BPOType): T;␊
    }␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export type PostOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "createdAt_ASC"␊
      | "createdAt_DESC"␊
      | "updatedAt_ASC"␊
      | "updatedAt_DESC"␊
      | "isPublished_ASC"␊
      | "isPublished_DESC"␊
      | "title_ASC"␊
      | "title_DESC"␊
      | "text_ASC"␊
      | "text_DESC";␊
    ␊
    export type UserOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "email_ASC"␊
      | "email_DESC"␊
      | "password_ASC"␊
      | "password_DESC"␊
      | "name_ASC"␊
      | "name_DESC"␊
      | "updatedAt_ASC"␊
      | "updatedAt_DESC"␊
      | "createdAt_ASC"␊
      | "createdAt_DESC";␊
    ␊
    export type MutationType = "CREATED" | "UPDATED" | "DELETED";␊
    ␊
    export interface UserCreateOneWithoutPostsInput {␊
      create?: UserCreateWithoutPostsInput;␊
      connect?: UserWhereUniqueInput;␊
    }␊
    ␊
    export interface PostWhereInput {␊
      AND?: PostWhereInput[];␊
      OR?: PostWhereInput[];␊
      id?: ID_Input;␊
      id_not?: ID_Input;␊
      id_in?: ID_Input[];␊
      id_not_in?: ID_Input[];␊
      id_lt?: ID_Input;␊
      id_lte?: ID_Input;␊
      id_gt?: ID_Input;␊
      id_gte?: ID_Input;␊
      id_contains?: ID_Input;␊
      id_not_contains?: ID_Input;␊
      id_starts_with?: ID_Input;␊
      id_not_starts_with?: ID_Input;␊
      id_ends_with?: ID_Input;␊
      id_not_ends_with?: ID_Input;␊
      createdAt?: DateTimeInput;␊
      createdAt_not?: DateTimeInput;␊
      createdAt_in?: DateTimeInput[];␊
      createdAt_not_in?: DateTimeInput[];␊
      createdAt_lt?: DateTimeInput;␊
      createdAt_lte?: DateTimeInput;␊
      createdAt_gt?: DateTimeInput;␊
      createdAt_gte?: DateTimeInput;␊
      updatedAt?: DateTimeInput;␊
      updatedAt_not?: DateTimeInput;␊
      updatedAt_in?: DateTimeInput[];␊
      updatedAt_not_in?: DateTimeInput[];␊
      updatedAt_lt?: DateTimeInput;␊
      updatedAt_lte?: DateTimeInput;␊
      updatedAt_gt?: DateTimeInput;␊
      updatedAt_gte?: DateTimeInput;␊
      isPublished?: Boolean;␊
      isPublished_not?: Boolean;␊
      title?: String;␊
      title_not?: String;␊
      title_in?: String[];␊
      title_not_in?: String[];␊
      title_lt?: String;␊
      title_lte?: String;␊
      title_gt?: String;␊
      title_gte?: String;␊
      title_contains?: String;␊
      title_not_contains?: String;␊
      title_starts_with?: String;␊
      title_not_starts_with?: String;␊
      title_ends_with?: String;␊
      title_not_ends_with?: String;␊
      text?: String;␊
      text_not?: String;␊
      text_in?: String[];␊
      text_not_in?: String[];␊
      text_lt?: String;␊
      text_lte?: String;␊
      text_gt?: String;␊
      text_gte?: String;␊
      text_contains?: String;␊
      text_not_contains?: String;␊
      text_starts_with?: String;␊
      text_not_starts_with?: String;␊
      text_ends_with?: String;␊
      text_not_ends_with?: String;␊
      author?: UserWhereInput;␊
    }␊
    ␊
    export interface PostCreateManyWithoutAuthorInput {␊
      create?: PostCreateWithoutAuthorInput[];␊
      connect?: PostWhereUniqueInput[];␊
    }␊
    ␊
    export interface UserWhereInput {␊
      AND?: UserWhereInput[];␊
      OR?: UserWhereInput[];␊
      id?: ID_Input;␊
      id_not?: ID_Input;␊
      id_in?: ID_Input[];␊
      id_not_in?: ID_Input[];␊
      id_lt?: ID_Input;␊
      id_lte?: ID_Input;␊
      id_gt?: ID_Input;␊
      id_gte?: ID_Input;␊
      id_contains?: ID_Input;␊
      id_not_contains?: ID_Input;␊
      id_starts_with?: ID_Input;␊
      id_not_starts_with?: ID_Input;␊
      id_ends_with?: ID_Input;␊
      id_not_ends_with?: ID_Input;␊
      email?: String;␊
      email_not?: String;␊
      email_in?: String[];␊
      email_not_in?: String[];␊
      email_lt?: String;␊
      email_lte?: String;␊
      email_gt?: String;␊
      email_gte?: String;␊
      email_contains?: String;␊
      email_not_contains?: String;␊
      email_starts_with?: String;␊
      email_not_starts_with?: String;␊
      email_ends_with?: String;␊
      email_not_ends_with?: String;␊
      password?: String;␊
      password_not?: String;␊
      password_in?: String[];␊
      password_not_in?: String[];␊
      password_lt?: String;␊
      password_lte?: String;␊
      password_gt?: String;␊
      password_gte?: String;␊
      password_contains?: String;␊
      password_not_contains?: String;␊
      password_starts_with?: String;␊
      password_not_starts_with?: String;␊
      password_ends_with?: String;␊
      password_not_ends_with?: String;␊
      name?: String;␊
      name_not?: String;␊
      name_in?: String[];␊
      name_not_in?: String[];␊
      name_lt?: String;␊
      name_lte?: String;␊
      name_gt?: String;␊
      name_gte?: String;␊
      name_contains?: String;␊
      name_not_contains?: String;␊
      name_starts_with?: String;␊
      name_not_starts_with?: String;␊
      name_ends_with?: String;␊
      name_not_ends_with?: String;␊
      posts_every?: PostWhereInput;␊
      posts_some?: PostWhereInput;␊
      posts_none?: PostWhereInput;␊
    }␊
    ␊
    export interface PostUpdateManyWithoutAuthorInput {␊
      create?: PostCreateWithoutAuthorInput[];␊
      connect?: PostWhereUniqueInput[];␊
      disconnect?: PostWhereUniqueInput[];␊
      delete?: PostWhereUniqueInput[];␊
      update?: PostUpdateWithWhereUniqueWithoutAuthorInput[];␊
      upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput[];␊
    }␊
    ␊
    export interface PostUpdateInput {␊
      isPublished?: Boolean;␊
      title?: String;␊
      text?: String;␊
      author?: UserUpdateOneWithoutPostsInput;␊
    }␊
    ␊
    export interface UserUpdateInput {␊
      email?: String;␊
      password?: String;␊
      name?: String;␊
      posts?: PostUpdateManyWithoutAuthorInput;␊
    }␊
    ␊
    export interface PostCreateWithoutAuthorInput {␊
      isPublished?: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface UserUpsertWithoutPostsInput {␊
      update: UserUpdateWithoutPostsDataInput;␊
      create: UserCreateWithoutPostsInput;␊
    }␊
    ␊
    export interface UserSubscriptionWhereInput {␊
      AND?: UserSubscriptionWhereInput[];␊
      OR?: UserSubscriptionWhereInput[];␊
      mutation_in?: MutationType[];␊
      updatedFields_contains?: String;␊
      updatedFields_contains_every?: String[];␊
      updatedFields_contains_some?: String[];␊
      node?: UserWhereInput;␊
    }␊
    ␊
    export interface UserUpdateWithoutPostsDataInput {␊
      email?: String;␊
      password?: String;␊
      name?: String;␊
    }␊
    ␊
    export type PostWhereUniqueInput = AtLeastOne<{␊
      id?: ID_Input␊
    }>;␊
    ␊
    export interface PostUpsertWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      update: PostUpdateWithoutAuthorDataInput;␊
      create: PostCreateWithoutAuthorInput;␊
    }␊
    ␊
    export interface UserCreateInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
      posts?: PostCreateManyWithoutAuthorInput;␊
    }␊
    ␊
    export interface UserCreateWithoutPostsInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserUpdateOneWithoutPostsInput {␊
      create?: UserCreateWithoutPostsInput;␊
      connect?: UserWhereUniqueInput;␊
      delete?: Boolean;␊
      update?: UserUpdateWithoutPostsDataInput;␊
      upsert?: UserUpsertWithoutPostsInput;␊
    }␊
    ␊
    export interface PostCreateInput {␊
      isPublished?: Boolean;␊
      title: String;␊
      text: String;␊
      author: UserCreateOneWithoutPostsInput;␊
    }␊
    ␊
    export interface PostUpdateWithoutAuthorDataInput {␊
      isPublished?: Boolean;␊
      title?: String;␊
      text?: String;␊
    }␊
    ␊
    export type UserWhereUniqueInput = AtLeastOne<{␊
      id?: ID_Input,␊
      email?: String␊
    }>;␊
    ␊
    export interface PostSubscriptionWhereInput {␊
      AND?: PostSubscriptionWhereInput[];␊
      OR?: PostSubscriptionWhereInput[];␊
      mutation_in?: MutationType[];␊
      updatedFields_contains?: String;␊
      updatedFields_contains_every?: String[];␊
      updatedFields_contains_some?: String[];␊
      node?: PostWhereInput;␊
    }␊
    ␊
    export interface PostUpdateWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      data: PostUpdateWithoutAuthorDataInput;␊
    }␊
    ␊
    /*␊
     * An object with an ID␊
    ␊
     */␊
    export interface NodeNode {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValuesNode {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPreviousValues extends Promise<UserPreviousValuesNode> {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
    }␊
    ␊
    export interface UserPreviousValuesSubscription␊
      extends Promise<AsyncIterator<UserPreviousValuesNode>> {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnectionNode {}␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnection extends Promise<PostConnectionNode> {␊
      pageInfo: <T: PageInfo>() => T;␊
      edges: <T: Promise<Array<PostEdgeNode>>>() => T;␊
      aggregate: <T: AggregatePost>() => T;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnectionSubscription␊
      extends Promise<AsyncIterator<PostConnectionNode>> {␊
      pageInfo: <T: PageInfoSubscription>() => T;␊
      edges: <T: Promise<AsyncIterator<Array<PostEdgeSubscription>>>>() => T;␊
      aggregate: <T: AggregatePostSubscription>() => T;␊
    }␊
    ␊
    export interface PostNode extends Node {␊
      id: ID_Output;␊
      createdAt: DateTimeOutput;␊
      updatedAt: DateTimeOutput;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface Post extends Promise<PostNode>, Node {␊
      id: () => Promise<ID_Output>;␊
      createdAt: () => Promise<DateTimeOutput>;␊
      updatedAt: () => Promise<DateTimeOutput>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T: User>(␊
        args?: { where?: UserWhereInput },␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    export interface PostSubscription␊
      extends Promise<AsyncIterator<PostNode>>, Node {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
      author: <T: UserSubscription>(␊
        args?: { where?: UserWhereInput },␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfoNode {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfo extends Promise<PageInfoNode> {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfoNode>> {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadNode {␊
      mutation: MutationType;␊
      updatedFields?: String[];␊
    }␊
    ␊
    export interface PostSubscriptionPayload␊
      extends Promise<PostSubscriptionPayloadNode> {␊
      mutation: () => Promise<MutationType>;␊
      node: <T: Post>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T: PostPreviousValues>() => T;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<PostSubscriptionPayloadNode>> {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T: PostSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T: PostPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface BatchPayloadNode {␊
      count: Long;␊
    }␊
    ␊
    export interface BatchPayload extends Promise<BatchPayloadNode> {␊
      count: () => Promise<Long>;␊
    }␊
    ␊
    export interface BatchPayloadSubscription␊
      extends Promise<AsyncIterator<BatchPayloadNode>> {␊
      count: () => Promise<AsyncIterator<Long>>;␊
    }␊
    ␊
    export interface PostPreviousValuesNode {␊
      id: ID_Output;␊
      createdAt: DateTimeOutput;␊
      updatedAt: DateTimeOutput;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPreviousValues extends Promise<PostPreviousValuesNode> {␊
      id: () => Promise<ID_Output>;␊
      createdAt: () => Promise<DateTimeOutput>;␊
      updatedAt: () => Promise<DateTimeOutput>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
    }␊
    ␊
    export interface PostPreviousValuesSubscription␊
      extends Promise<AsyncIterator<PostPreviousValuesNode>> {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface UserNode extends Node {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface User extends Promise<UserNode>, Node {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T: Promise<Array<PostNode>>>(␊
        args?: {␊
          where?: PostWhereInput,␊
          orderBy?: PostOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<UserNode>>, Node {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      posts: <T: Promise<AsyncIterator<Array<PostSubscription>>>>(␊
        args?: {␊
          where?: PostWhereInput,␊
          orderBy?: PostOrderByInput,␊
          skip?: Int,␊
          after?: String,␊
          before?: String,␊
          first?: Int,␊
          last?: Int␊
        },␊
        fragment?: string | Object␊
      ) => T;␊
    }␊
    ␊
    export interface AggregateUserNode {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUser extends Promise<AggregateUserNode> {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUserNode>> {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadNode {␊
      mutation: MutationType;␊
      updatedFields?: String[];␊
    }␊
    ␊
    export interface UserSubscriptionPayload␊
      extends Promise<UserSubscriptionPayloadNode> {␊
      mutation: () => Promise<MutationType>;␊
      node: <T: User>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T: UserPreviousValues>() => T;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<UserSubscriptionPayloadNode>> {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T: UserSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T: UserPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdgeNode {␊
      cursor: String;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdge extends Promise<UserEdgeNode> {␊
      node: <T: User>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdgeNode>> {␊
      node: <T: UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdgeNode {␊
      cursor: String;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdge extends Promise<PostEdgeNode> {␊
      node: <T: Post>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdgeSubscription␊
      extends Promise<AsyncIterator<PostEdgeNode>> {␊
      node: <T: PostSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregatePostNode {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregatePost extends Promise<AggregatePostNode> {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregatePostSubscription␊
      extends Promise<AsyncIterator<AggregatePostNode>> {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnectionNode {}␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnection extends Promise<UserConnectionNode> {␊
      pageInfo: <T: PageInfo>() => T;␊
      edges: <T: Promise<Array<UserEdgeNode>>>() => T;␊
      aggregate: <T: AggregateUser>() => T;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnectionNode>> {␊
      pageInfo: <T: PageInfoSubscription>() => T;␊
      edges: <T: Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;␊
      aggregate: <T: AggregateUserSubscription>() => T;␊
    }␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /*␊
    The `Long` scalar type represents non-fractional signed whole numeric values.␊
    Long can represent values between -(2^63) and 2^63 - 1.␊
    */␊
    export type Long = string;␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    DateTime scalar input type, allowing Date␊
    */␊
    export type DateTimeInput = Date | string;␊
    ␊
    /*␊
    DateTime scalar output type, which is always a string␊
    */␊
    export type DateTimeOutput = string;␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const Prisma = makePrismaClientClass<ClientConstructor<PrismaInterface>>(␊
      { typeDefs }␊
    );␊
    export const prisma = new Prisma();␊
    `
