import Collapse from "components/Markdown/Collapse"
import Code from "components/Markdown/Code"
import Warning from "components/Markdown/Warning"

export const meta = {
  title: "API Reference (JavaScript)",
  position: 10,
  technology: "node",
  technologyOrder: 1,
  articleGroup: "API Reference",
}

## Overview

The Prisma Client is based on the operations defined in the GraphQL schema of your Prisma API. It basically _mirrors_ the GraphQL API of your Prisma Service.

For this page, we"ll assume your Prisma API is based on the following [datamodel](knul):

```graphql
type Link {
  id: ID! @unique
  createdAt: DateTime!
  description: String!
  url: String!
  postedBy: User
  votes: [Vote!]!
}

type User {
  id: ID! @unique
  name: String!
  email: String! @unique
  password: String!
  links: [Link!]!
  votes: [Vote!]!
}

type Vote {
  id: ID! @unique
  link: Link!
  user: User!
}
```

<Collapse title="View the generated GraphQL schema & Prisma Client">

- You can view what the generated GraphQL schema for the API [here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.graphql)
- You can view what the generated JavaScript client [here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.js).

</Collapse>

## Constructor

The `Prisma` constructor is used to create new instances of the Prisma Client.

```js
constructor(options: BasePrismaOptions)
```

`BasePrismaOptions` has the following properties (all are optional):

- `endpoint: string`: The endpoint of your Prisma Service. If not provided, the Client will default to the `endpoint` that was specified in prisma.yml when the Client was generated. 
- `secret: string`: The secret protecting the API of your Prisma Service. If not provided, the Client will default to the `secret` that was specified in prisma.yml when the Client was generated. 
- `debug: boolean`: If set to `true`, each invokation of a method on the Prisma Client will print the GraphQL query that is sent to the Prisma API to the console. **Default: `false`**.
- `fragmentReplacements: FragmentReplacement[]`: A list of GraphQL fragments that will be applied to each query/mutation/subscription sent to the Prisma API.

#### Examples

_Use default values for `endpoint` and `secret` that were specified in prisma.yml when the Client was generated_:

```js
const prisma = new Prisma({})
```

_Override default values for `endpoint` and `secret` that were specified in prisma.yml when the Client was generated_:

```js
const prisma = new Prisma({ 
  endpoint: "http://localhost:4466/hello-world/dev",
  secret: "mysecret42",
})
```

## Reading data

Whenever a model is queried using the Prisma Client, _all scalar fields_ of that model are fetched. This is true no matter if a single object or a list of objects is queried.

For example, the following query returns all scalar fields of a single `User`:

```js
const user = await prisma.user({ email: "bob@prisma.io" })
```

In this case, the returned `user` object will have four properties (that correspond to the scalar fields of the `User` model): `id`, `name`, `email` and `password`. 

The `links` and `votes` fields are both _relation fields_ and are therefore not included in the query.

Here is an example of fetching a _list_ of `User` objects:

```js
const users = await prisma.users()
```

Similar to the previous query, each object inside the `users` array only has the scalar and no relation fields.

### Fetching single objects

For each model type in your datamodel, there is a method generated in the Prisma Client API that allows to fetch single objects of that model. The method is named after the type but starts with a _lowercase_ character. For the sample data model from above, the three methods for fetching single `User`, `Link` and `Vote` objects are called `user`, `link` and `vote`.

The input for these functions is an object that has as properties any [unique](knul#unique-scalar-fields) field of the model. This means, for all three methods, the `id` field is accepted (as the corresponding models each have an `id` field annotated as `@unique`). The input object for the `user` method additionaly has an `email` field.

<Collapse title="View the types of the input object for `Link`, `User` and `Vote`">

- View the type of `where` for `Link` [here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
- View the type of `where` for `User` [here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
- View the type of `where` for `Link` [Vote](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

</Collapse>

#### Examples

_Fetch a single vote by its id_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const vote = await prisma.vote({ id: "cjlgpyueg001o0a239d3i07ao" })
```

```graphql
# generated query
query {
  vote(where: {
    id: "cjlgpyueg001o0a239d3i07ao"
  }) {
    id
  }
}
```

</Code>

_Fetch a single user by their email_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const user = await prisma.user({ email: "alice@prisma.io" })
```

```graphql
# generated query
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    id
  }
}
```

</Code>

### Fetching lists of objects

For each model type in your datamodel, there is a method generated in the Prisma Client API that allows to fetch a list of those model objects. The method is named after the model but starts with a _lowercase_ character and uses the _plural_ form. For the sample data model from above, the three methods for fetching lists of `User`, `Link` and `Vote` models are called `users`, `links` and `votes`.

The input arugment for these functions is an object that has properties for:

- [Filtering](): `where`
- [Ordering](): `orderBy`
- [Pagination](): `before`, `after`, `first`, `last`, `skip`

#### Examples

_Fetch all links_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const links = await prisma.links()
```

```graphql
# generated query
query {
  links {
    id
    createdAt
    url
    description
  }
}
```

</Code>

_Fetch a list of users_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const users = await prisma.users()
```

```graphql
# generated query
query {
  users {
    id
    name
    email
    passwors
  }
}
```

</Code>

### Relations

Prisma Client has a [fluent API](https://www.sitepoint.com/javascript-like-boss-understanding-fluent-apis/) to query relations in your data graph. Meaning you can simply _chain_ your method calls to navigate over certain properties of the returned models.

<Warning>

This is only possible when retrieving _single_ objects, not for lists. Meaning you can not query relation fields of objects that are returned in a list, e.g.:

```js
// not possible
const result = await prisma.users().links()
```

In this example, `users()` already returns a list, so it's not possible to query the `links` relation of each user object inside the list.

</Warning>

#### Examples

_Query all the links of a single user_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const linksByUser = await prisma
  .user({ email: "alice@prisma.io" })
  .links()
```

```graphql
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    links {
      id
      createdAt
      description
      url
    }
  }
}
```

</Code>

 _Query all the votes made by a certain user_:

<Code languages={["JavaScript", "GraphQL"]}>

 ```js
const votesForLink = await prisma
  .user({ email: "alice@prisma.io" })
  .votes()
 ```

 ```graphql
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    votes {
      id
    }
  }
}
 ```

 </Code>

### Fetching lists with basic filters

_Basic_ filters let you specify certain criteria to constrain which objects should be returned in a list. The filters are specified in the `where` object of the input argument which is accepted by any list query.

The type of the `where` object depends on the model for which it was generated.

<Collapse title="View the types of `where` for `Link`, `User` and `Vote`">

- View the type of `where` for `Link` [here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L154)
- View the type of `where` for `User` [here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L267)
- View the type of `where` for `Link` [Vote](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L219)

</Collapse>

It is also possible to _combine_ multiple filters using the `AND` and `OR` fields.

#### Examples

_Fetch users that have an `A` in their names_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const usersWithAInName = await prisma
  .users({
    where: {
      name_contains: "A"
    }
  })
```

```graphql
query {
  users(where: {
      name_contains: "A"
  }) {
    id
    name
    email
    password
  }
}
```

</Code>

<Collapse title="Use auto-completion to explore the filter system">

![](https://imgur.com/XwE5z9o.png)

</Collapse>

_Fetch users called `Alice` or `Bob`_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const usersCalledAliceOrBob = await prisma
  .users({
    where: {
      name_in: ["Alice", "Bob"]
    }
  })
```

```graphql
query {
  users(where: {
    name_in: ["Alice", "Bob"]
  }) {
    id
    name
    email
    password
  }
}
```

</Code>

_Fetch links created before December 24, 2018_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const linksBeforeChristmas = await prisma
  .links({
    where: {
      createdAt_lt: "2017-12-24" 
    }
  })
```

```graphql
query {
  links(where: {
    createdAt_lt: "2017-12-24" 
  }) {
    id
    createdAt
    description
    url
  }
}
```

</Code>

> Dates and times in the Prisma Client API follow the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard which generally is of the form: `YYYY-MM-DDThh:mm:ss`. [Learn more](knul#datetime).

_Fetch links that have `prisma` **or** `graphql` in their description **and** where created in 2018_:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const filteredLinks = await prisma
  links({
    where: {
      AND: [
        {
          OR: [{
            description_contains: "graphql",
          }, {
            description_contains: "prisma",
          }]
        }, 
        {
          AND: [{
            createdAt_gt: "2017"
          }, {
            createdAt_lt: "2019"
          }]
        }
      ],
    }
  })
```

```graphql
query {
  links(where: {
    OR: [{
      description_contains: "graphql",
    }, {
      description_contains: "prisma",
    }]
    AND: [{ 
      createdAt_lt: "2019"
    }, { 
      createdAt_gt: "2017" 
    }]
  }) {
    id
    description
  }
}
```

</Code>

<Warning>

**TODO**: Change to `Tip` component

The `AND` filter can actually be omitted since multiple filter criteria are by default combined using a _logical and_. This means the above filter can also be expressed as follows:

<Code languages={["JavaScript", "GraphQL"]}>

```js
const filteredLinks = await prisma
  .links({
    where: {
      OR: [{
        description_contains: "graphql"
      }, {
        description_contains: "prisma"
      }],
      createdAt_gt: "2017",
      createdAt_lt: "2019"
    }
  })
```

```graphql
query {
  links(where: {
    OR: [{
      description_contains: "graphql",
    }, {
      description_contains: "prisma",
    }],
    createdAt_lt: "2019",
    createdAt_gt: "2017" 
  }) {
    id
    createdAt
    description
    url
  }
}
```

</Code>

</Warning>


### Relational filters for lists

Relational filters can be used to constrain the returned objects on a relation list field. The types used for filtering are identical to basic filters, the only difference is that the filters are not applied on the first level of the method call but when querying a relation on the second level.

#### Examples

<Code languages={["JavaScript", "GraphQL"]}>

```js
const linksByUserBeforeChristmas = await prisma
  .user({ email: "alice@prisma.io" })
  .links({
    where: {
      createdAt_lt: "2017-12-24" 
    }
  })
```

```graphql
query {
 user(where: {
  email: "alice@prisma.io"
 }) {
    links(where: {
      createdAt_lt: "2017-12-24" 
    }) {
      id
      createdAt
      description
      url
  }
 }
}
```

</Code>

### Ordering lists

### Paginating through lists

When querying a list of model objects, you can fetch _chunks_ of that list by supplying pagination arguments.

#### Seeking forward and backward with `first` and `last`

## Writing data

### Simple writes

### Nested object writes

## Realtime

## Exists

## Raw GraphQL

## Raw databases access

## Schema delegation