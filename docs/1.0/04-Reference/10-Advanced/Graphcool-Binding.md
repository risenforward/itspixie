---
alias: ag2ahrohyi
description: GraphQL bindings for Graphcool services
---

# Graphcool Binding

## Overview

When using Graphcool as a database service in your server-side setup, you need to implement a web server that connects to the GraphQL API of the service.

One of the key things to understand is that you are going to work with two [GraphQL schemas](https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e) in that setup:

- the **database schema** which is auto-generated by Graphcool, it contains the full GraphQL CRUD API for your data model
- the **application schema** specifies the API that's going to be exposed to your client applications

The database schema and its corresponding API is already _executable_, meaning there is an endpoint you can send queries, mutations and subscriptions. The application schema on the other hand needs to be _defined_ and _implemented_ by you in the context of your web server.

To facilitate the process of implementing your application schema, you can use the [`graphcool-binding`](https://github.com/graphcool/graphcool-binding) package.

[`graphcool-binding`](https://github.com/graphcool/graphcool-binding) provides a convenience layer for building GraphQL servers on top of your Graphcool services. In short, it simplifies the process of implementing your GraphQL resolvers by _delegating_ execution of queries (or mutations) to the API of the underlying Graphcool database service.

Here is a general overview of the process of building your web server based on Graphcool:

1. Create your Graphcool service by defining data model and deploying it
1. Download generated database schema definition `database.graphql` (contains the full CRUD API)
1. Define your application schema, typically called `app.graphql`
1. Instantiate [`Graphcool`](https://github.com/graphcool/graphcool-binding#constructoroptions-graphcooloptions-graphcool) with information about your Graphcool service (such as its endpoint and the path to the database schema definition)
1. Implement the resolvers for your application schema by delegating to the underlying Graphcool service using the generated delegate resolver functions

## Installation

You can install `graphcool-binding` with npm or yarn:

```sh
yarn add graphcool-binding
# or
npm install --save graphcool-binding
```

## Generated delegate resolvers

The core idea of GraphQL bindings is to auto-generate dedicated resolver functions for the (root) fields of your GraphQL schema. These functions are called delegate resolvers.

Rather than having to construct a full GraphQL query/mutation and sending it to the API manually (e.g. with `fetch` or `graphql-request`), this allows to simply invoke functions for sending specific queries/mutations. GraphQL bindings in essence provide a convenience API for sending GraphQL requests!

Additionally, if the delegate resolvers are generated in a build step and based on a strongly typed language (like TypeScript or Flow), you also get compile-time safety for all interactions with your GraphQL API!

## Example

Assume you specify the following data model for your Graphcool service:

```graphql
type User {
  id: ID! @unique
  name: String
}
```

When deploying the service, Graphcool will generate a database schema similar to this:

```graphql
type Query {
  user(id: ID!): User
  users: [User!]!
}

type Mutation {
  createUser(name: String!): User
  updateUser(id: ID!, name: String): User
  deleteUser(id: ID!): User
}
```

> Note: This is a simplified version of the schema that's actually generated. This one only serves as a simple CRUD example and for example doesn't contain any filter or pagination arguments for the `users` list.

If you instantiate `Graphcool` based on this service, the resulting object exposes a number of auto-generated delegate resolver functions which are named after the root fields in the database schema. Here's an overview of the delegate resolvers you can now invoke on your `Graphcool` instance:

```js
// Instantiate `Graphcool` based on concrete service
const graphcool = Graphcool({ ... })

// Retrieve `name` of a specific user
graphcool.query.user({ id: 'abc' }, '{ name }')

// Retrieve `id` and `name` of all users
graphcool.query.users(null, '{ id name }')

// Create new user called `Sarah` and retrieve the `id`
graphcool.mutation.createUser({ name: 'Sarah' }, '{ id }')

// Update name of a specific user and retrieve the `id`
graphcool.mutation.updateUser({ id: 'abc', name: 'John' }, '{ id }')

// Delete a specific user and retrieve the `name`
graphcool.mutation.deleteUser({ id: 'abc' }, '{ id }')
```

Under the hood, each of these function calls is simply translated into an actual HTTP request against your Graphcool service (using [`graphql-request`](https://github.com/graphcool/graphql-request)). So, for example, the call to `graphcool.user({ id: 'abc' }, '{ name }')` is translated to the following:

```js
const { request } = require('graphql-request')

const query = `
query ($userId: ID!) {
  user(id: $userID) {
    name
  }
}
`

const variables = { userId: 'abc' }

request(
  __GRAPHCOOL_ENDPOINT__,
  query,
  variables
)
```

Assume your application schema now looks as follows:

```graphql
type Query {
  usersCalledSarah: [User!]!
}
```

When implementing the resolver for `usersCalledSarah`, you can write the following:

```js
const resolvers = {
  Query: {
    usersCalledSarah: async (parent, args, context, info) => {
      const usersCalledSarah = await context.db.query.users(
        { where: { name: 'Sarah' } },
        info
      )
      return usersCalledSarah
    }
  }
}
```

The second argument for any of the generated delegate resolvers is either a string to specify the selection set for the query/mutation or an object of type [`GraphQLResolveInfo`](http://graphql.org/graphql-js/type/#graphqlobjecttype) (thus effectively also a represenation of a selection set). Here, you're simply passing on the `info` object that's already passed into the resolver.

Note that the above setup requires that your `Graphcool` instance is added to the `context` object which is passed down the resolver chain. If you're using `graphql-yoga` for your GraphQL server implementation, the setup might look similar to this:

```js
import { GraphQLServer } from 'graphql-yoga'
import { Graphcool } from 'graphcool-binding'
import { importSchema } from 'graphql-import'
import { resolvers } from './resolvers'
const typeDefs = importSchema('./src/schemas/app.graphql')

const server = new GraphQLServer({
  typeDefs,
  resolvers,
  context: req => ({
    ...req,
    db: new Graphcool({
      schema: './src/schemas/database.graphql',
      endpoint: process.env.GRAPHCOOL_ENDPOINT,
    }),
  }),
})
```

## API

Instances of `Graphcool` allow you to interact with your Graphcool service, this includes:

- delegating execution of queries and mutations to the Graphcool service with auto-generated delegate resolvers
- checking if a certain node exists in the Graphcool database
- sending standard queries and mutations to the Graphcool service

### `constructor(options: GraphcoolOptions): Graphcool`

The `GraphcoolOptions` type has the following fields:

| Key | Required |  Type | Default | Note |
| ---  | --- | --- | --- | --- |
| `schemaPath` | Yes | `string` |  - | File path to the schema definition of your Graphcool service (typically a file called `database.graphql`) |
| `endpoint` | Yes | `string` |  - | The endpoint of your Graphcool service |
| `secret` | Yes | `string` |  - | The secret of your Graphcool service |
| `fragmentReplacements` | No | `FragmentReplacements` |  `null` | A list of GraphQL fragment definitions, specifying fields that are required for the resolver to function correctly |

Here is an example for you can use the constructor to create your `Graphcool` instance:

```js
const graphcool = new Graphcool({
  schemaPath: 'schemas/database.graphql',
  endpoint: 'https://api.graph.cool/simple/v1/my-graphcool-service'
  secret: 'my-super-secret-secret'
})
```

> Note that you have to add the values of your own Graphcool service for `endpoint` and `secret`.

### `query` and `mutation`

`query` and `mutation` are public properties on your `Graphcool` instance. They both are of type `Query` and expose a number of auto-generated delegate resolver functions that are named after the fields on the `Query` and `Mutation` types in your Graphcool database schema, for example:

```js
// Retrieve `name` of a single user by `id`
graphcool.query.user({ id: 'abc', '{ name }' })

// Update name of a specific user and retrieve the `id`
graphcool.mutation.updateUser({ id: 'abc', name: 'John' }, '{ id }')
```

Each of these delegate resolvers in essence provides a convenience API for sending queries/mutations to your Graphcool service, so you don't have to spell out the full query/mutation from scratch and worry about sending it over HTTP. This is all handled by the delegate resolver function under the hood.

Delegate resolver have the following interface:

```js
(args: any, info: GraphQLResolveInfo | string): Promise<T>
```

The input arguments are used as follows:

- `args`: An object carrying potential arguments for the query/mutation
- `info`: An object representing the selection set of the query/mutation, either expressed directly as a string or in the form of `GraphQLResolveInfo` (you can find more info about the `GraphQLResolveInfo` type [here](http://graphql.org/graphql-js/type/#graphqlobjecttype))

The generic type `T` corresponds to the type of the respective field. For the two examples above `graphcool.query.user` and `graphcool.mutation.updateUser`, this would be the `User` type.

### `exists`

`exists` also is a public property on your `Graphcool` instance. Similar to `query` and `mutation`, it also exposes a number of auto-generated functions. However, it exposes only a single function per type. This function is named according to the root field that allows to retrieve a single node of that type (e.g. `user` for a type called `User`). It takes a `filter` object as an input argument and returns a `boolean` value indicating whether the condition expressed with `filter` is met.

This function enables you to easily check whether a node of a specific type exists in your Graphcool database. Here is how it can be used:

```js
graphcool.exists.post({
  id: 'abc',
  author: {
    name: 'Sarah'
  }
})
```

In this example, the filter object passed to the function expresses two things:

- There must be a node of type `Post` with `abc` as its `id`
- There must be a node of type `Post` whose `author` has the `name` `Sarah`

> Note that these conditions are connected with a logical `AND`.

This example is based on the following data model:

```graphql
type User {
  id: ID! @unique
  name: String
}

type Post {
  id: ID! @unique
  author: User!
}
```

### `request`

The `request` method allows send GraphQL queries/mutations to your Graphcool service. The functionality is identical to the auto-generated delegate resolves, but the API is more verbose as you need to spell out the full query/mutation. `request` uses [`graphql-request](https://github.com/graphcool/graphql-request) under the hood.

Here is an example of how it can be used:

```js
const query = `
  query ($userId: ID!){
    user(id: $userId) {
      id
      name
    }
  }
`

const variables = { userId: 'abc' }

graphcool.request(query, variables)
  .then(result => console.log(result))
// sample result:
// {"data": { "user": { "id": "abc", "name": "Sarah" } } }
```