---
alias: uek0ohxupa 
description: An overview of your architecture when using Graphcool.
---

# Architecture

In this section, we'll discuss some architectural concepts you need to be familiar with when using Graphcool.

## Graphcool maps your GraphQL API to the database

Considering the classic [three-tier architecture](https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture) of client, (web) server and database, Graphcool is a layer which *connects your database with the server*. In that sense, it can somewhat be thought of as an [ORM](https://en.wikipedia.org/wiki/Object-relational_mapping), but comes with many additional benefits compared to conventional ORMs - most importantly: it enables an idiomatic way of building GraphQL servers!

> Note that as of today, Graphcool comes with a connected MySQL database. In the future, you will be able to connect any database with Graphcool.

When implementing your GraphQL (web) server, you can use [schema delegation](https://blog.graph.cool/graphql-schema-stitching-explained-schema-delegation-4c6caf468405), and in particular the `graphcool-binding` package, to conveniently implement your Graphcool resolvers. In short, `graphcool-binding` allows to forward an incoming query to Graphcool's CRUD API.

## High-level architecture

When working with Graphcool, you typically have the following components in your stack:

* Client apps (using a GraphQL client library, like Relay or Apollo)
* GraphQL web server (using `graphql-yoga`)
* Graphcool & Graphcool bindings
* Database

Client applications are the apps that will end up in the hands of your users. This can be a web app written with React, Angular or any other framework or a native mobile app for Android or iOS.

The GraphQL (web) server is the *server* from the three-tier architecture. It is responsible for business logic and other common pieces of functionality, like authentication and permissions. The GraphQL server exposes a GraphQL API that's defined in the **application schema**.

## Database schema vs Application schema

In general, a [GraphQL schema](https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e) defines the API of a GraphQL server. When using Graphcool, you'll always be dealing with two different schemas:

* the **database schema** is automatically generated and provides the CRUD API for your database
* the **application schema** defines a “tailored” API which is exposed to your client applications

The database schema comes with powerful filtering, sorting und pagination options to make sure clients are able to retrieve exactly the data they need. Note that your client applications are not to talk to the database API directly. Instead, they will consume the API defined by the application schema.

The core idea of Graphcool is to provide a CRUD GraphQL API for the *types* in your data model. This CRUD API manifests itself in the** **database schema that is generated by Graphcool.

In production use cases, you typically don't want to expose the database directly to your client applications. Rather, you'll have an* API layer *in between, enabling clients to interact with the data in a more convenient way. The mapping from the database to the actual API is done with a *GraphQL (web) server*. This GraphQL server also implements your business logic and common workflows like authentication functionality and permissions rules.