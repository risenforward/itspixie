package com.prisma.api.connector.jdbc.database

import java.sql.{PreparedStatement, Statement}
import java.util.Date

import com.prisma.api.connector.{Filter, PrismaArgs}
import com.prisma.gc_values._
import com.prisma.shared.models.{Model, TypeIdentifier}
import com.prisma.shared.models.TypeIdentifier.IdTypeIdentifier
import org.joda.time.{DateTime, DateTimeZone}
import org.jooq.impl.DSL.field
import slick.dbio.DBIOAction
import slick.jdbc.PositionedParameters

import scala.concurrent.ExecutionContext

trait NodeActions extends BuilderBase with FilterConditionBuilder with ScalarListActions with RelayIdActions {
  import slickDatabase.profile.api._

  def createNode(model: Model, args: PrismaArgs): DBIO[IdGCValue] = {
    SimpleDBIO { x =>
      val idIsAutoGenerated = model.idField_!.isAutoGenerated
      val argsAsRoot = if (idIsAutoGenerated) {
        args.raw.asRoot
      } else {
        args.raw.asRoot.add(model.idField_!.name, generateId(model))
      }
      val fields = model.fields.filter(field => argsAsRoot.hasArgFor(field.name))

      val query = sql
        .insertInto(modelTable(model))
        .columns(fields.map(field => modelColumn(model, field)): _*)
        .values(placeHolders(fields))

      val itemInsert: PreparedStatement = x.connection.prepareStatement(query.getSQL, Statement.RETURN_GENERATED_KEYS)

      val currentTimestamp = currentSqlTimestampUTC
      fields.map(_.name).zipWithIndex.foreach {
        case (column, index) =>
          argsAsRoot.map.get(column) match {
            case Some(NullGCValue) if column == createdAtField || column == updatedAtField => itemInsert.setTimestamp(index + 1, currentTimestamp)
            case Some(gCValue)                                                             => itemInsert.setGcValue(index + 1, gCValue)
            case None if column == createdAtField || column == updatedAtField              => itemInsert.setTimestamp(index + 1, currentTimestamp)
            case None                                                                      => itemInsert.setNull(index + 1, java.sql.Types.NULL)
          }
      }
      itemInsert.execute()

      if (idIsAutoGenerated) {
        val generatedKeys = itemInsert.getGeneratedKeys
        generatedKeys.next()
        generatedKeys.getId(model)
      } else {
        argsAsRoot.idField
      }
    }
  }

  private def generateId(model: Model) = {
    model.idField_!.typeIdentifier.asInstanceOf[IdTypeIdentifier] match {
      case TypeIdentifier.UUID => UuidGCValue.random()
      case TypeIdentifier.Cuid => CuidGCValue.random()
      case TypeIdentifier.Int  => sys.error("can't generate int ids")
    }
  }

  def updateNodeById(model: Model, id: IdGCValue, updateArgs: PrismaArgs): DBIO[_] = {
    if (updateArgs.raw.asRoot.map.isEmpty) {
      DBIOAction.successful(id)
    } else {
      SimpleDBIO { ctx =>
        val actualArgs = addUpdatedAt(model, updateArgs.raw.asRoot)
        val columns    = actualArgs.map.map { case (k, _) => model.getFieldByName_!(k).dbName }.toList
        val values     = actualArgs.map.map { case (_, v) => v }

        val query = sql
          .update(modelTable(model))
          .setColumnsWithPlaceHolders(columns)
          .where(idField(model).equal(placeHolder))

        val ps = ctx.connection.prepareStatement(query.getSQL)
        val pp = new PositionedParameters(ps)

        values.foreach(pp.setGcValue)
        pp.setGcValue(id)

        ps.execute()

        id
      }
    }
  }

  private def addUpdatedAt(model: Model, updateValues: RootGCValue): RootGCValue = {
    model.updatedAtField match {
      case Some(updatedAtField) =>
        val today              = new Date()
        val exactlyNow         = new DateTime(today).withZone(DateTimeZone.UTC)
        val currentDateGCValue = DateTimeGCValue(exactlyNow)
        updateValues.add(updatedAtField.name, currentDateGCValue)
      case None =>
        updateValues
    }
  }

  def updateNodes(model: Model, args: PrismaArgs, whereFilter: Option[Filter]): DBIO[_] = {
    val map = args.raw.asRoot.map
    if (map.nonEmpty) {
      SimpleDBIO { ctx =>
        val aliasedTable = modelTable(model).as(topLevelAlias)
        val condition    = buildConditionForFilter(whereFilter)

        val base = sql.update(aliasedTable)

        //https://www.postgresql.org/message-id/20170719174507.GA19616%40telsasoft.com
        lazy val queryString: String = if (map.size > 1) {
          val columns = map.map { case (k, _) => model.getFieldByName_!(k).dbName }.toList

          base
            .setColumnsWithPlaceHolders(columns)
            .where(condition)
            .getSQL

        } else {
          val fieldDef = map.map { case (k, _) => field(model.getFieldByName_!(k).dbName) }.head

          base
            .set(fieldDef, placeHolder)
            .where(condition)
            .getSQL
        }

        val ps = ctx.connection.prepareStatement(queryString)
        val pp = new PositionedParameters(ps)
        map.foreach { case (_, v) => pp.setGcValue(v) }
        whereFilter.foreach(filter => SetParams.setFilter(pp, filter))
        ps.executeUpdate()
      }
    } else {
      dbioUnit
    }
  }

  def deleteNodeById(model: Model, id: IdGCValue)(implicit ec: ExecutionContext) = deleteNodes(model, Vector(id))

  //Todo check how much of a performance gain it would be to chain these using andThen instead of the for comprehension
  def deleteNodes(model: Model, ids: Vector[IdGCValue])(implicit ec: ExecutionContext): DBIO[Unit] = {
    for {
      _ <- deleteScalarListEntriesByIds(model, ids)
      _ <- deleteRelayIds(ids)
      _ <- deleteNodesByIds(model, ids)
    } yield ()
  }

  private def deleteNodesByIds(model: Model, ids: Vector[IdGCValue]): DBIO[Unit] = {
    val query = sql
      .deleteFrom(modelTable(model))
      .where(idField(model).in(placeHolders(ids)))

    deleteToDBIO(query)(
      setParams = pp => ids.foreach(pp.setGcValue)
    )
  }

  private val dbioUnit = DBIO.successful(())
}
